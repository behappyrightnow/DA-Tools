<!DOCTYPE html>
<!--[if lt IE 7]>      <html lang="en" ng-app="rev" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html lang="en" ng-app="rev" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html lang="en" ng-app="rev" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en" ng-app="rev" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Swakitch</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css">
  <style>/*!
 * Bootstrap v4.4.1 (https://getbootstrap.com/)
 * Copyright 2011-2019 The Bootstrap Authors
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */:root{--blue:#007bff;--indigo:#6610f2;--purple:#6f42c1;--pink:#e83e8c;--red:#dc3545;--orange:#fd7e14;--yellow:#ffc107;--green:#28a745;--teal:#20c997;--cyan:#17a2b8;--white:#fff;--gray:#6c757d;--gray-dark:#343a40;--primary:#007bff;--secondary:#6c757d;--success:#28a745;--info:#17a2b8;--warning:#ffc107;--danger:#dc3545;--light:#f8f9fa;--dark:#343a40;--breakpoint-xs:0;--breakpoint-sm:576px;--breakpoint-md:768px;--breakpoint-lg:992px;--breakpoint-xl:1200px;--font-family-sans-serif:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-family-monospace:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}*,::after,::before{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}article,aside,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;text-align:left;background-color:#fff}[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}hr{box-sizing:content-box;height:0;overflow:visible}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem}p{margin-top:0;margin-bottom:1rem}abbr[data-original-title],abbr[title]{text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;border-bottom:0;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#007bff;text-decoration:none;background-color:transparent}a:hover{color:#0056b3;text-decoration:underline}a:not([href]){color:inherit;text-decoration:none}a:not([href]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em}pre{margin-top:0;margin-bottom:1rem;overflow:auto}figure{margin:0 0 1rem}img{vertical-align:middle;border-style:none}svg{overflow:hidden;vertical-align:middle}table{border-collapse:collapse}caption{padding-top:.75rem;padding-bottom:.75rem;color:#6c757d;text-align:left;caption-side:bottom}th{text-align:inherit}label{display:inline-block;margin-bottom:.5rem}button{border-radius:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,input{overflow:visible}button,select{text-transform:none}select{word-wrap:normal}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{padding:0;border-style:none}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=date],input[type=datetime-local],input[type=month],input[type=time]{-webkit-appearance:listbox}textarea{overflow:auto;resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;max-width:100%;padding:0;margin-bottom:.5rem;font-size:1.5rem;line-height:inherit;color:inherit;white-space:normal}progress{vertical-align:baseline}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:none}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}summary{display:list-item;cursor:pointer}template{display:none}[hidden]{display:none!important}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:500;line-height:1.2}.h1,h1{font-size:2.5rem}.h2,h2{font-size:2rem}.h3,h3{font-size:1.75rem}.h4,h4{font-size:1.5rem}.h5,h5{font-size:1.25rem}.h6,h6{font-size:1rem}.lead{font-size:1.25rem;font-weight:300}.display-1{font-size:6rem;font-weight:300;line-height:1.2}.display-2{font-size:5.5rem;font-weight:300;line-height:1.2}.display-3{font-size:4.5rem;font-weight:300;line-height:1.2}.display-4{font-size:3.5rem;font-weight:300;line-height:1.2}hr{margin-top:1rem;margin-bottom:1rem;border:0;border-top:1px solid rgba(0,0,0,.1)}.small,small{font-size:80%;font-weight:400}.mark,mark{padding:.2em;background-color:#fcf8e3}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;list-style:none}.list-inline-item{display:inline-block}.list-inline-item:not(:last-child){margin-right:.5rem}.initialism{font-size:90%;text-transform:uppercase}.blockquote{margin-bottom:1rem;font-size:1.25rem}.blockquote-footer{display:block;font-size:80%;color:#6c757d}.blockquote-footer::before{content:"\2014\00A0"}.img-fluid{max-width:100%;height:auto}.img-thumbnail{padding:.25rem;background-color:#fff;border:1px solid #dee2e6;border-radius:.25rem;max-width:100%;height:auto}.figure{display:inline-block}.figure-img{margin-bottom:.5rem;line-height:1}.figure-caption{font-size:90%;color:#6c757d}code{font-size:87.5%;color:#e83e8c;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:87.5%;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:100%;font-weight:700}pre{display:block;font-size:87.5%;color:#212529}pre code{font-size:inherit;color:inherit;word-break:normal}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:576px){.container{max-width:540px}}@media (min-width:768px){.container{max-width:720px}}@media (min-width:992px){.container{max-width:960px}}@media (min-width:1200px){.container{max-width:1140px}}.container-fluid,.container-lg,.container-md,.container-sm,.container-xl{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:576px){.container,.container-sm{max-width:540px}}@media (min-width:768px){.container,.container-md,.container-sm{max-width:720px}}@media (min-width:992px){.container,.container-lg,.container-md,.container-sm{max-width:960px}}@media (min-width:1200px){.container,.container-lg,.container-md,.container-sm,.container-xl{max-width:1140px}}.row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-15px;margin-left:-15px}.no-gutters{margin-right:0;margin-left:0}.no-gutters>.col,.no-gutters>[class*=col-]{padding-right:0;padding-left:0}.col,.col-1,.col-10,.col-11,.col-12,.col-2,.col-3,.col-4,.col-5,.col-6,.col-7,.col-8,.col-9,.col-auto,.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-auto,.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-auto,.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-auto,.col-xl,.col-xl-1,.col-xl-10,.col-xl-11,.col-xl-12,.col-xl-2,.col-xl-3,.col-xl-4,.col-xl-5,.col-xl-6,.col-xl-7,.col-xl-8,.col-xl-9,.col-xl-auto{position:relative;width:100%;padding-right:15px;padding-left:15px}.col{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.row-cols-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-first{-ms-flex-order:-1;order:-1}.order-last{-ms-flex-order:13;order:13}.order-0{-ms-flex-order:0;order:0}.order-1{-ms-flex-order:1;order:1}.order-2{-ms-flex-order:2;order:2}.order-3{-ms-flex-order:3;order:3}.order-4{-ms-flex-order:4;order:4}.order-5{-ms-flex-order:5;order:5}.order-6{-ms-flex-order:6;order:6}.order-7{-ms-flex-order:7;order:7}.order-8{-ms-flex-order:8;order:8}.order-9{-ms-flex-order:9;order:9}.order-10{-ms-flex-order:10;order:10}.order-11{-ms-flex-order:11;order:11}.order-12{-ms-flex-order:12;order:12}.offset-1{margin-left:8.333333%}.offset-2{margin-left:16.666667%}.offset-3{margin-left:25%}.offset-4{margin-left:33.333333%}.offset-5{margin-left:41.666667%}.offset-6{margin-left:50%}.offset-7{margin-left:58.333333%}.offset-8{margin-left:66.666667%}.offset-9{margin-left:75%}.offset-10{margin-left:83.333333%}.offset-11{margin-left:91.666667%}@media (min-width:576px){.col-sm{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.row-cols-sm-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-sm-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-sm-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-sm-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-sm-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-sm-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-sm-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-sm-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-sm-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-sm-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-sm-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-sm-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-sm-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-sm-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-sm-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-sm-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-sm-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-sm-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-sm-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-sm-first{-ms-flex-order:-1;order:-1}.order-sm-last{-ms-flex-order:13;order:13}.order-sm-0{-ms-flex-order:0;order:0}.order-sm-1{-ms-flex-order:1;order:1}.order-sm-2{-ms-flex-order:2;order:2}.order-sm-3{-ms-flex-order:3;order:3}.order-sm-4{-ms-flex-order:4;order:4}.order-sm-5{-ms-flex-order:5;order:5}.order-sm-6{-ms-flex-order:6;order:6}.order-sm-7{-ms-flex-order:7;order:7}.order-sm-8{-ms-flex-order:8;order:8}.order-sm-9{-ms-flex-order:9;order:9}.order-sm-10{-ms-flex-order:10;order:10}.order-sm-11{-ms-flex-order:11;order:11}.order-sm-12{-ms-flex-order:12;order:12}.offset-sm-0{margin-left:0}.offset-sm-1{margin-left:8.333333%}.offset-sm-2{margin-left:16.666667%}.offset-sm-3{margin-left:25%}.offset-sm-4{margin-left:33.333333%}.offset-sm-5{margin-left:41.666667%}.offset-sm-6{margin-left:50%}.offset-sm-7{margin-left:58.333333%}.offset-sm-8{margin-left:66.666667%}.offset-sm-9{margin-left:75%}.offset-sm-10{margin-left:83.333333%}.offset-sm-11{margin-left:91.666667%}}@media (min-width:768px){.col-md{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.row-cols-md-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-md-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-md-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-md-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-md-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-md-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-md-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-md-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-md-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-md-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-md-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-md-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-md-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-md-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-md-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-md-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-md-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-md-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-md-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-md-first{-ms-flex-order:-1;order:-1}.order-md-last{-ms-flex-order:13;order:13}.order-md-0{-ms-flex-order:0;order:0}.order-md-1{-ms-flex-order:1;order:1}.order-md-2{-ms-flex-order:2;order:2}.order-md-3{-ms-flex-order:3;order:3}.order-md-4{-ms-flex-order:4;order:4}.order-md-5{-ms-flex-order:5;order:5}.order-md-6{-ms-flex-order:6;order:6}.order-md-7{-ms-flex-order:7;order:7}.order-md-8{-ms-flex-order:8;order:8}.order-md-9{-ms-flex-order:9;order:9}.order-md-10{-ms-flex-order:10;order:10}.order-md-11{-ms-flex-order:11;order:11}.order-md-12{-ms-flex-order:12;order:12}.offset-md-0{margin-left:0}.offset-md-1{margin-left:8.333333%}.offset-md-2{margin-left:16.666667%}.offset-md-3{margin-left:25%}.offset-md-4{margin-left:33.333333%}.offset-md-5{margin-left:41.666667%}.offset-md-6{margin-left:50%}.offset-md-7{margin-left:58.333333%}.offset-md-8{margin-left:66.666667%}.offset-md-9{margin-left:75%}.offset-md-10{margin-left:83.333333%}.offset-md-11{margin-left:91.666667%}}@media (min-width:992px){.col-lg{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.row-cols-lg-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-lg-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-lg-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-lg-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-lg-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-lg-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-lg-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-lg-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-lg-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-lg-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-lg-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-lg-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-lg-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-lg-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-lg-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-lg-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-lg-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-lg-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-lg-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-lg-first{-ms-flex-order:-1;order:-1}.order-lg-last{-ms-flex-order:13;order:13}.order-lg-0{-ms-flex-order:0;order:0}.order-lg-1{-ms-flex-order:1;order:1}.order-lg-2{-ms-flex-order:2;order:2}.order-lg-3{-ms-flex-order:3;order:3}.order-lg-4{-ms-flex-order:4;order:4}.order-lg-5{-ms-flex-order:5;order:5}.order-lg-6{-ms-flex-order:6;order:6}.order-lg-7{-ms-flex-order:7;order:7}.order-lg-8{-ms-flex-order:8;order:8}.order-lg-9{-ms-flex-order:9;order:9}.order-lg-10{-ms-flex-order:10;order:10}.order-lg-11{-ms-flex-order:11;order:11}.order-lg-12{-ms-flex-order:12;order:12}.offset-lg-0{margin-left:0}.offset-lg-1{margin-left:8.333333%}.offset-lg-2{margin-left:16.666667%}.offset-lg-3{margin-left:25%}.offset-lg-4{margin-left:33.333333%}.offset-lg-5{margin-left:41.666667%}.offset-lg-6{margin-left:50%}.offset-lg-7{margin-left:58.333333%}.offset-lg-8{margin-left:66.666667%}.offset-lg-9{margin-left:75%}.offset-lg-10{margin-left:83.333333%}.offset-lg-11{margin-left:91.666667%}}@media (min-width:1200px){.col-xl{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;max-width:100%}.row-cols-xl-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-xl-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-xl-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-xl-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-xl-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-xl-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-xl-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-xl-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-xl-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-xl-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-xl-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-xl-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-xl-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-xl-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-xl-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-xl-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-xl-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-xl-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-xl-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-xl-first{-ms-flex-order:-1;order:-1}.order-xl-last{-ms-flex-order:13;order:13}.order-xl-0{-ms-flex-order:0;order:0}.order-xl-1{-ms-flex-order:1;order:1}.order-xl-2{-ms-flex-order:2;order:2}.order-xl-3{-ms-flex-order:3;order:3}.order-xl-4{-ms-flex-order:4;order:4}.order-xl-5{-ms-flex-order:5;order:5}.order-xl-6{-ms-flex-order:6;order:6}.order-xl-7{-ms-flex-order:7;order:7}.order-xl-8{-ms-flex-order:8;order:8}.order-xl-9{-ms-flex-order:9;order:9}.order-xl-10{-ms-flex-order:10;order:10}.order-xl-11{-ms-flex-order:11;order:11}.order-xl-12{-ms-flex-order:12;order:12}.offset-xl-0{margin-left:0}.offset-xl-1{margin-left:8.333333%}.offset-xl-2{margin-left:16.666667%}.offset-xl-3{margin-left:25%}.offset-xl-4{margin-left:33.333333%}.offset-xl-5{margin-left:41.666667%}.offset-xl-6{margin-left:50%}.offset-xl-7{margin-left:58.333333%}.offset-xl-8{margin-left:66.666667%}.offset-xl-9{margin-left:75%}.offset-xl-10{margin-left:83.333333%}.offset-xl-11{margin-left:91.666667%}}.table{width:100%;margin-bottom:1rem;color:#212529}.table td,.table th{padding:.75rem;vertical-align:top;border-top:1px solid #dee2e6}.table thead th{vertical-align:bottom;border-bottom:2px solid #dee2e6}.table tbody+tbody{border-top:2px solid #dee2e6}.table-sm td,.table-sm th{padding:.3rem}.table-bordered{border:1px solid #dee2e6}.table-bordered td,.table-bordered th{border:1px solid #dee2e6}.table-bordered thead td,.table-bordered thead th{border-bottom-width:2px}.table-borderless tbody+tbody,.table-borderless td,.table-borderless th,.table-borderless thead th{border:0}.table-striped tbody tr:nth-of-type(odd){background-color:rgba(0,0,0,.05)}.table-hover tbody tr:hover{color:#212529;background-color:rgba(0,0,0,.075)}.table-primary,.table-primary>td,.table-primary>th{background-color:#b8daff}.table-primary tbody+tbody,.table-primary td,.table-primary th,.table-primary thead th{border-color:#7abaff}.table-hover .table-primary:hover{background-color:#9fcdff}.table-hover .table-primary:hover>td,.table-hover .table-primary:hover>th{background-color:#9fcdff}.table-secondary,.table-secondary>td,.table-secondary>th{background-color:#d6d8db}.table-secondary tbody+tbody,.table-secondary td,.table-secondary th,.table-secondary thead th{border-color:#b3b7bb}.table-hover .table-secondary:hover{background-color:#c8cbcf}.table-hover .table-secondary:hover>td,.table-hover .table-secondary:hover>th{background-color:#c8cbcf}.table-success,.table-success>td,.table-success>th{background-color:#c3e6cb}.table-success tbody+tbody,.table-success td,.table-success th,.table-success thead th{border-color:#8fd19e}.table-hover .table-success:hover{background-color:#b1dfbb}.table-hover .table-success:hover>td,.table-hover .table-success:hover>th{background-color:#b1dfbb}.table-info,.table-info>td,.table-info>th{background-color:#bee5eb}.table-info tbody+tbody,.table-info td,.table-info th,.table-info thead th{border-color:#86cfda}.table-hover .table-info:hover{background-color:#abdde5}.table-hover .table-info:hover>td,.table-hover .table-info:hover>th{background-color:#abdde5}.table-warning,.table-warning>td,.table-warning>th{background-color:#ffeeba}.table-warning tbody+tbody,.table-warning td,.table-warning th,.table-warning thead th{border-color:#ffdf7e}.table-hover .table-warning:hover{background-color:#ffe8a1}.table-hover .table-warning:hover>td,.table-hover .table-warning:hover>th{background-color:#ffe8a1}.table-danger,.table-danger>td,.table-danger>th{background-color:#f5c6cb}.table-danger tbody+tbody,.table-danger td,.table-danger th,.table-danger thead th{border-color:#ed969e}.table-hover .table-danger:hover{background-color:#f1b0b7}.table-hover .table-danger:hover>td,.table-hover .table-danger:hover>th{background-color:#f1b0b7}.table-light,.table-light>td,.table-light>th{background-color:#fdfdfe}.table-light tbody+tbody,.table-light td,.table-light th,.table-light thead th{border-color:#fbfcfc}.table-hover .table-light:hover{background-color:#ececf6}.table-hover .table-light:hover>td,.table-hover .table-light:hover>th{background-color:#ececf6}.table-dark,.table-dark>td,.table-dark>th{background-color:#c6c8ca}.table-dark tbody+tbody,.table-dark td,.table-dark th,.table-dark thead th{border-color:#95999c}.table-hover .table-dark:hover{background-color:#b9bbbe}.table-hover .table-dark:hover>td,.table-hover .table-dark:hover>th{background-color:#b9bbbe}.table-active,.table-active>td,.table-active>th{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover>td,.table-hover .table-active:hover>th{background-color:rgba(0,0,0,.075)}.table .thead-dark th{color:#fff;background-color:#343a40;border-color:#454d55}.table .thead-light th{color:#495057;background-color:#e9ecef;border-color:#dee2e6}.table-dark{color:#fff;background-color:#343a40}.table-dark td,.table-dark th,.table-dark thead th{border-color:#454d55}.table-dark.table-bordered{border:0}.table-dark.table-striped tbody tr:nth-of-type(odd){background-color:rgba(255,255,255,.05)}.table-dark.table-hover tbody tr:hover{color:#fff;background-color:rgba(255,255,255,.075)}@media (max-width:575.98px){.table-responsive-sm{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-sm>.table-bordered{border:0}}@media (max-width:767.98px){.table-responsive-md{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-md>.table-bordered{border:0}}@media (max-width:991.98px){.table-responsive-lg{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-lg>.table-bordered{border:0}}@media (max-width:1199.98px){.table-responsive-xl{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-xl>.table-bordered{border:0}}.table-responsive{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive>.table-bordered{border:0}.form-control{display:block;width:100%;height:calc(1.5em + .75rem + 2px);padding:.375rem .75rem;font-size:1rem;font-weight:400;line-height:1.5;color:#495057;background-color:#fff;background-clip:padding-box;border:1px solid #ced4da;border-radius:.25rem;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.form-control{transition:none}}.form-control::-ms-expand{background-color:transparent;border:0}.form-control:-moz-focusring{color:transparent;text-shadow:0 0 0 #495057}.form-control:focus{color:#495057;background-color:#fff;border-color:#80bdff;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.form-control::-webkit-input-placeholder{color:#6c757d;opacity:1}.form-control::-moz-placeholder{color:#6c757d;opacity:1}.form-control:-ms-input-placeholder{color:#6c757d;opacity:1}.form-control::-ms-input-placeholder{color:#6c757d;opacity:1}.form-control::placeholder{color:#6c757d;opacity:1}.form-control:disabled,.form-control[readonly]{background-color:#e9ecef;opacity:1}select.form-control:focus::-ms-value{color:#495057;background-color:#fff}.form-control-file,.form-control-range{display:block;width:100%}.col-form-label{padding-top:calc(.375rem + 1px);padding-bottom:calc(.375rem + 1px);margin-bottom:0;font-size:inherit;line-height:1.5}.col-form-label-lg{padding-top:calc(.5rem + 1px);padding-bottom:calc(.5rem + 1px);font-size:1.25rem;line-height:1.5}.col-form-label-sm{padding-top:calc(.25rem + 1px);padding-bottom:calc(.25rem + 1px);font-size:.875rem;line-height:1.5}.form-control-plaintext{display:block;width:100%;padding:.375rem 0;margin-bottom:0;font-size:1rem;line-height:1.5;color:#212529;background-color:transparent;border:solid transparent;border-width:1px 0}.form-control-plaintext.form-control-lg,.form-control-plaintext.form-control-sm{padding-right:0;padding-left:0}.form-control-sm{height:calc(1.5em + .5rem + 2px);padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.form-control-lg{height:calc(1.5em + 1rem + 2px);padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}select.form-control[multiple],select.form-control[size]{height:auto}textarea.form-control{height:auto}.form-group{margin-bottom:1rem}.form-text{display:block;margin-top:.25rem}.form-row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-5px;margin-left:-5px}.form-row>.col,.form-row>[class*=col-]{padding-right:5px;padding-left:5px}.form-check{position:relative;display:block;padding-left:1.25rem}.form-check-input{position:absolute;margin-top:.3rem;margin-left:-1.25rem}.form-check-input:disabled~.form-check-label,.form-check-input[disabled]~.form-check-label{color:#6c757d}.form-check-label{margin-bottom:0}.form-check-inline{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;padding-left:0;margin-right:.75rem}.form-check-inline .form-check-input{position:static;margin-top:0;margin-right:.3125rem;margin-left:0}.valid-feedback{display:none;width:100%;margin-top:.25rem;font-size:80%;color:#28a745}.valid-tooltip{position:absolute;top:100%;z-index:5;display:none;max-width:100%;padding:.25rem .5rem;margin-top:.1rem;font-size:.875rem;line-height:1.5;color:#fff;background-color:rgba(40,167,69,.9);border-radius:.25rem}.is-valid~.valid-feedback,.is-valid~.valid-tooltip,.was-validated :valid~.valid-feedback,.was-validated :valid~.valid-tooltip{display:block}.form-control.is-valid,.was-validated .form-control:valid{border-color:#28a745;padding-right:calc(1.5em + .75rem);background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%2328a745' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right calc(.375em + .1875rem) center;background-size:calc(.75em + .375rem) calc(.75em + .375rem)}.form-control.is-valid:focus,.was-validated .form-control:valid:focus{border-color:#28a745;box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.was-validated textarea.form-control:valid,textarea.form-control.is-valid{padding-right:calc(1.5em + .75rem);background-position:top calc(.375em + .1875rem) right calc(.375em + .1875rem)}.custom-select.is-valid,.was-validated .custom-select:valid{border-color:#28a745;padding-right:calc(.75em + 2.3125rem);background:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23343a40' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right .75rem center/8px 10px,url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%2328a745' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3e%3c/svg%3e") #fff no-repeat center right 1.75rem/calc(.75em + .375rem) calc(.75em + .375rem)}.custom-select.is-valid:focus,.was-validated .custom-select:valid:focus{border-color:#28a745;box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.form-check-input.is-valid~.form-check-label,.was-validated .form-check-input:valid~.form-check-label{color:#28a745}.form-check-input.is-valid~.valid-feedback,.form-check-input.is-valid~.valid-tooltip,.was-validated .form-check-input:valid~.valid-feedback,.was-validated .form-check-input:valid~.valid-tooltip{display:block}.custom-control-input.is-valid~.custom-control-label,.was-validated .custom-control-input:valid~.custom-control-label{color:#28a745}.custom-control-input.is-valid~.custom-control-label::before,.was-validated .custom-control-input:valid~.custom-control-label::before{border-color:#28a745}.custom-control-input.is-valid:checked~.custom-control-label::before,.was-validated .custom-control-input:valid:checked~.custom-control-label::before{border-color:#34ce57;background-color:#34ce57}.custom-control-input.is-valid:focus~.custom-control-label::before,.was-validated .custom-control-input:valid:focus~.custom-control-label::before{box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.custom-control-input.is-valid:focus:not(:checked)~.custom-control-label::before,.was-validated .custom-control-input:valid:focus:not(:checked)~.custom-control-label::before{border-color:#28a745}.custom-file-input.is-valid~.custom-file-label,.was-validated .custom-file-input:valid~.custom-file-label{border-color:#28a745}.custom-file-input.is-valid:focus~.custom-file-label,.was-validated .custom-file-input:valid:focus~.custom-file-label{border-color:#28a745;box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.invalid-feedback{display:none;width:100%;margin-top:.25rem;font-size:80%;color:#dc3545}.invalid-tooltip{position:absolute;top:100%;z-index:5;display:none;max-width:100%;padding:.25rem .5rem;margin-top:.1rem;font-size:.875rem;line-height:1.5;color:#fff;background-color:rgba(220,53,69,.9);border-radius:.25rem}.is-invalid~.invalid-feedback,.is-invalid~.invalid-tooltip,.was-validated :invalid~.invalid-feedback,.was-validated :invalid~.invalid-tooltip{display:block}.form-control.is-invalid,.was-validated .form-control:invalid{border-color:#dc3545;padding-right:calc(1.5em + .75rem);background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right calc(.375em + .1875rem) center;background-size:calc(.75em + .375rem) calc(.75em + .375rem)}.form-control.is-invalid:focus,.was-validated .form-control:invalid:focus{border-color:#dc3545;box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.was-validated textarea.form-control:invalid,textarea.form-control.is-invalid{padding-right:calc(1.5em + .75rem);background-position:top calc(.375em + .1875rem) right calc(.375em + .1875rem)}.custom-select.is-invalid,.was-validated .custom-select:invalid{border-color:#dc3545;padding-right:calc(.75em + 2.3125rem);background:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23343a40' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right .75rem center/8px 10px,url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e") #fff no-repeat center right 1.75rem/calc(.75em + .375rem) calc(.75em + .375rem)}.custom-select.is-invalid:focus,.was-validated .custom-select:invalid:focus{border-color:#dc3545;box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.form-check-input.is-invalid~.form-check-label,.was-validated .form-check-input:invalid~.form-check-label{color:#dc3545}.form-check-input.is-invalid~.invalid-feedback,.form-check-input.is-invalid~.invalid-tooltip,.was-validated .form-check-input:invalid~.invalid-feedback,.was-validated .form-check-input:invalid~.invalid-tooltip{display:block}.custom-control-input.is-invalid~.custom-control-label,.was-validated .custom-control-input:invalid~.custom-control-label{color:#dc3545}.custom-control-input.is-invalid~.custom-control-label::before,.was-validated .custom-control-input:invalid~.custom-control-label::before{border-color:#dc3545}.custom-control-input.is-invalid:checked~.custom-control-label::before,.was-validated .custom-control-input:invalid:checked~.custom-control-label::before{border-color:#e4606d;background-color:#e4606d}.custom-control-input.is-invalid:focus~.custom-control-label::before,.was-validated .custom-control-input:invalid:focus~.custom-control-label::before{box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.custom-control-input.is-invalid:focus:not(:checked)~.custom-control-label::before,.was-validated .custom-control-input:invalid:focus:not(:checked)~.custom-control-label::before{border-color:#dc3545}.custom-file-input.is-invalid~.custom-file-label,.was-validated .custom-file-input:invalid~.custom-file-label{border-color:#dc3545}.custom-file-input.is-invalid:focus~.custom-file-label,.was-validated .custom-file-input:invalid:focus~.custom-file-label{border-color:#dc3545;box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.form-inline{display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-align:center;align-items:center}.form-inline .form-check{width:100%}@media (min-width:576px){.form-inline label{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;margin-bottom:0}.form-inline .form-group{display:-ms-flexbox;display:flex;-ms-flex:0 0 auto;flex:0 0 auto;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-align:center;align-items:center;margin-bottom:0}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-plaintext{display:inline-block}.form-inline .custom-select,.form-inline .input-group{width:auto}.form-inline .form-check{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-left:0}.form-inline .form-check-input{position:relative;-ms-flex-negative:0;flex-shrink:0;margin-top:0;margin-right:.25rem;margin-left:0}.form-inline .custom-control{-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.form-inline .custom-control-label{margin-bottom:0}}.btn{display:inline-block;font-weight:400;color:#212529;text-align:center;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:transparent;border:1px solid transparent;padding:.375rem .75rem;font-size:1rem;line-height:1.5;border-radius:.25rem;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.btn{transition:none}}.btn:hover{color:#212529;text-decoration:none}.btn.focus,.btn:focus{outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.btn.disabled,.btn:disabled{opacity:.65}a.btn.disabled,fieldset:disabled a.btn{pointer-events:none}.btn-primary{color:#fff;background-color:#007bff;border-color:#007bff}.btn-primary:hover{color:#fff;background-color:#0069d9;border-color:#0062cc}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#0069d9;border-color:#0062cc;box-shadow:0 0 0 .2rem rgba(38,143,255,.5)}.btn-primary.disabled,.btn-primary:disabled{color:#fff;background-color:#007bff;border-color:#007bff}.btn-primary:not(:disabled):not(.disabled).active,.btn-primary:not(:disabled):not(.disabled):active,.show>.btn-primary.dropdown-toggle{color:#fff;background-color:#0062cc;border-color:#005cbf}.btn-primary:not(:disabled):not(.disabled).active:focus,.btn-primary:not(:disabled):not(.disabled):active:focus,.show>.btn-primary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(38,143,255,.5)}.btn-secondary{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:hover{color:#fff;background-color:#5a6268;border-color:#545b62}.btn-secondary.focus,.btn-secondary:focus{color:#fff;background-color:#5a6268;border-color:#545b62;box-shadow:0 0 0 .2rem rgba(130,138,145,.5)}.btn-secondary.disabled,.btn-secondary:disabled{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:not(:disabled):not(.disabled).active,.btn-secondary:not(:disabled):not(.disabled):active,.show>.btn-secondary.dropdown-toggle{color:#fff;background-color:#545b62;border-color:#4e555b}.btn-secondary:not(:disabled):not(.disabled).active:focus,.btn-secondary:not(:disabled):not(.disabled):active:focus,.show>.btn-secondary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(130,138,145,.5)}.btn-success{color:#fff;background-color:#28a745;border-color:#28a745}.btn-success:hover{color:#fff;background-color:#218838;border-color:#1e7e34}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#218838;border-color:#1e7e34;box-shadow:0 0 0 .2rem rgba(72,180,97,.5)}.btn-success.disabled,.btn-success:disabled{color:#fff;background-color:#28a745;border-color:#28a745}.btn-success:not(:disabled):not(.disabled).active,.btn-success:not(:disabled):not(.disabled):active,.show>.btn-success.dropdown-toggle{color:#fff;background-color:#1e7e34;border-color:#1c7430}.btn-success:not(:disabled):not(.disabled).active:focus,.btn-success:not(:disabled):not(.disabled):active:focus,.show>.btn-success.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(72,180,97,.5)}.btn-info{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-info:hover{color:#fff;background-color:#138496;border-color:#117a8b}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#138496;border-color:#117a8b;box-shadow:0 0 0 .2rem rgba(58,176,195,.5)}.btn-info.disabled,.btn-info:disabled{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-info:not(:disabled):not(.disabled).active,.btn-info:not(:disabled):not(.disabled):active,.show>.btn-info.dropdown-toggle{color:#fff;background-color:#117a8b;border-color:#10707f}.btn-info:not(:disabled):not(.disabled).active:focus,.btn-info:not(:disabled):not(.disabled):active:focus,.show>.btn-info.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(58,176,195,.5)}.btn-warning{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-warning:hover{color:#212529;background-color:#e0a800;border-color:#d39e00}.btn-warning.focus,.btn-warning:focus{color:#212529;background-color:#e0a800;border-color:#d39e00;box-shadow:0 0 0 .2rem rgba(222,170,12,.5)}.btn-warning.disabled,.btn-warning:disabled{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-warning:not(:disabled):not(.disabled).active,.btn-warning:not(:disabled):not(.disabled):active,.show>.btn-warning.dropdown-toggle{color:#212529;background-color:#d39e00;border-color:#c69500}.btn-warning:not(:disabled):not(.disabled).active:focus,.btn-warning:not(:disabled):not(.disabled):active:focus,.show>.btn-warning.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(222,170,12,.5)}.btn-danger{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-danger:hover{color:#fff;background-color:#c82333;border-color:#bd2130}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c82333;border-color:#bd2130;box-shadow:0 0 0 .2rem rgba(225,83,97,.5)}.btn-danger.disabled,.btn-danger:disabled{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-danger:not(:disabled):not(.disabled).active,.btn-danger:not(:disabled):not(.disabled):active,.show>.btn-danger.dropdown-toggle{color:#fff;background-color:#bd2130;border-color:#b21f2d}.btn-danger:not(:disabled):not(.disabled).active:focus,.btn-danger:not(:disabled):not(.disabled):active:focus,.show>.btn-danger.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(225,83,97,.5)}.btn-light{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-light:hover{color:#212529;background-color:#e2e6ea;border-color:#dae0e5}.btn-light.focus,.btn-light:focus{color:#212529;background-color:#e2e6ea;border-color:#dae0e5;box-shadow:0 0 0 .2rem rgba(216,217,219,.5)}.btn-light.disabled,.btn-light:disabled{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-light:not(:disabled):not(.disabled).active,.btn-light:not(:disabled):not(.disabled):active,.show>.btn-light.dropdown-toggle{color:#212529;background-color:#dae0e5;border-color:#d3d9df}.btn-light:not(:disabled):not(.disabled).active:focus,.btn-light:not(:disabled):not(.disabled):active:focus,.show>.btn-light.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(216,217,219,.5)}.btn-dark{color:#fff;background-color:#343a40;border-color:#343a40}.btn-dark:hover{color:#fff;background-color:#23272b;border-color:#1d2124}.btn-dark.focus,.btn-dark:focus{color:#fff;background-color:#23272b;border-color:#1d2124;box-shadow:0 0 0 .2rem rgba(82,88,93,.5)}.btn-dark.disabled,.btn-dark:disabled{color:#fff;background-color:#343a40;border-color:#343a40}.btn-dark:not(:disabled):not(.disabled).active,.btn-dark:not(:disabled):not(.disabled):active,.show>.btn-dark.dropdown-toggle{color:#fff;background-color:#1d2124;border-color:#171a1d}.btn-dark:not(:disabled):not(.disabled).active:focus,.btn-dark:not(:disabled):not(.disabled):active:focus,.show>.btn-dark.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(82,88,93,.5)}.btn-outline-primary{color:#007bff;border-color:#007bff}.btn-outline-primary:hover{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-primary.focus,.btn-outline-primary:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-outline-primary.disabled,.btn-outline-primary:disabled{color:#007bff;background-color:transparent}.btn-outline-primary:not(:disabled):not(.disabled).active,.btn-outline-primary:not(:disabled):not(.disabled):active,.show>.btn-outline-primary.dropdown-toggle{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-primary:not(:disabled):not(.disabled).active:focus,.btn-outline-primary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-primary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-outline-secondary{color:#6c757d;border-color:#6c757d}.btn-outline-secondary:hover{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-outline-secondary.focus,.btn-outline-secondary:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-outline-secondary.disabled,.btn-outline-secondary:disabled{color:#6c757d;background-color:transparent}.btn-outline-secondary:not(:disabled):not(.disabled).active,.btn-outline-secondary:not(:disabled):not(.disabled):active,.show>.btn-outline-secondary.dropdown-toggle{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-outline-secondary:not(:disabled):not(.disabled).active:focus,.btn-outline-secondary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-secondary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-outline-success{color:#28a745;border-color:#28a745}.btn-outline-success:hover{color:#fff;background-color:#28a745;border-color:#28a745}.btn-outline-success.focus,.btn-outline-success:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-outline-success.disabled,.btn-outline-success:disabled{color:#28a745;background-color:transparent}.btn-outline-success:not(:disabled):not(.disabled).active,.btn-outline-success:not(:disabled):not(.disabled):active,.show>.btn-outline-success.dropdown-toggle{color:#fff;background-color:#28a745;border-color:#28a745}.btn-outline-success:not(:disabled):not(.disabled).active:focus,.btn-outline-success:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-success.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-outline-info{color:#17a2b8;border-color:#17a2b8}.btn-outline-info:hover{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-outline-info.focus,.btn-outline-info:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-outline-info.disabled,.btn-outline-info:disabled{color:#17a2b8;background-color:transparent}.btn-outline-info:not(:disabled):not(.disabled).active,.btn-outline-info:not(:disabled):not(.disabled):active,.show>.btn-outline-info.dropdown-toggle{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-outline-info:not(:disabled):not(.disabled).active:focus,.btn-outline-info:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-info.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-outline-warning{color:#ffc107;border-color:#ffc107}.btn-outline-warning:hover{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-outline-warning.focus,.btn-outline-warning:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-outline-warning.disabled,.btn-outline-warning:disabled{color:#ffc107;background-color:transparent}.btn-outline-warning:not(:disabled):not(.disabled).active,.btn-outline-warning:not(:disabled):not(.disabled):active,.show>.btn-outline-warning.dropdown-toggle{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-outline-warning:not(:disabled):not(.disabled).active:focus,.btn-outline-warning:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-warning.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-outline-danger{color:#dc3545;border-color:#dc3545}.btn-outline-danger:hover{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-outline-danger.focus,.btn-outline-danger:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-outline-danger.disabled,.btn-outline-danger:disabled{color:#dc3545;background-color:transparent}.btn-outline-danger:not(:disabled):not(.disabled).active,.btn-outline-danger:not(:disabled):not(.disabled):active,.show>.btn-outline-danger.dropdown-toggle{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-outline-danger:not(:disabled):not(.disabled).active:focus,.btn-outline-danger:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-danger.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-outline-light{color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light:hover{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light.focus,.btn-outline-light:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-outline-light.disabled,.btn-outline-light:disabled{color:#f8f9fa;background-color:transparent}.btn-outline-light:not(:disabled):not(.disabled).active,.btn-outline-light:not(:disabled):not(.disabled):active,.show>.btn-outline-light.dropdown-toggle{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light:not(:disabled):not(.disabled).active:focus,.btn-outline-light:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-light.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-outline-dark{color:#343a40;border-color:#343a40}.btn-outline-dark:hover{color:#fff;background-color:#343a40;border-color:#343a40}.btn-outline-dark.focus,.btn-outline-dark:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-outline-dark.disabled,.btn-outline-dark:disabled{color:#343a40;background-color:transparent}.btn-outline-dark:not(:disabled):not(.disabled).active,.btn-outline-dark:not(:disabled):not(.disabled):active,.show>.btn-outline-dark.dropdown-toggle{color:#fff;background-color:#343a40;border-color:#343a40}.btn-outline-dark:not(:disabled):not(.disabled).active:focus,.btn-outline-dark:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-dark.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-link{font-weight:400;color:#007bff;text-decoration:none}.btn-link:hover{color:#0056b3;text-decoration:underline}.btn-link.focus,.btn-link:focus{text-decoration:underline;box-shadow:none}.btn-link.disabled,.btn-link:disabled{color:#6c757d;pointer-events:none}.btn-group-lg>.btn,.btn-lg{padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}.btn-group-sm>.btn,.btn-sm{padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:.5rem}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{transition:opacity .15s linear}@media (prefers-reduced-motion:reduce){.fade{transition:none}}.fade:not(.show){opacity:0}.collapse:not(.show){display:none}.collapsing{position:relative;height:0;overflow:hidden;transition:height .35s ease}@media (prefers-reduced-motion:reduce){.collapsing{transition:none}}.dropdown,.dropleft,.dropright,.dropup{position:relative}.dropdown-toggle{white-space:nowrap}.dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:"";border-top:.3em solid;border-right:.3em solid transparent;border-bottom:0;border-left:.3em solid transparent}.dropdown-toggle:empty::after{margin-left:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:10rem;padding:.5rem 0;margin:.125rem 0 0;font-size:1rem;color:#212529;text-align:left;list-style:none;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.15);border-radius:.25rem}.dropdown-menu-left{right:auto;left:0}.dropdown-menu-right{right:0;left:auto}@media (min-width:576px){.dropdown-menu-sm-left{right:auto;left:0}.dropdown-menu-sm-right{right:0;left:auto}}@media (min-width:768px){.dropdown-menu-md-left{right:auto;left:0}.dropdown-menu-md-right{right:0;left:auto}}@media (min-width:992px){.dropdown-menu-lg-left{right:auto;left:0}.dropdown-menu-lg-right{right:0;left:auto}}@media (min-width:1200px){.dropdown-menu-xl-left{right:auto;left:0}.dropdown-menu-xl-right{right:0;left:auto}}.dropup .dropdown-menu{top:auto;bottom:100%;margin-top:0;margin-bottom:.125rem}.dropup .dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:"";border-top:0;border-right:.3em solid transparent;border-bottom:.3em solid;border-left:.3em solid transparent}.dropup .dropdown-toggle:empty::after{margin-left:0}.dropright .dropdown-menu{top:0;right:auto;left:100%;margin-top:0;margin-left:.125rem}.dropright .dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:"";border-top:.3em solid transparent;border-right:0;border-bottom:.3em solid transparent;border-left:.3em solid}.dropright .dropdown-toggle:empty::after{margin-left:0}.dropright .dropdown-toggle::after{vertical-align:0}.dropleft .dropdown-menu{top:0;right:100%;left:auto;margin-top:0;margin-right:.125rem}.dropleft .dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:""}.dropleft .dropdown-toggle::after{display:none}.dropleft .dropdown-toggle::before{display:inline-block;margin-right:.255em;vertical-align:.255em;content:"";border-top:.3em solid transparent;border-right:.3em solid;border-bottom:.3em solid transparent}.dropleft .dropdown-toggle:empty::after{margin-left:0}.dropleft .dropdown-toggle::before{vertical-align:0}.dropdown-menu[x-placement^=bottom],.dropdown-menu[x-placement^=left],.dropdown-menu[x-placement^=right],.dropdown-menu[x-placement^=top]{right:auto;bottom:auto}.dropdown-divider{height:0;margin:.5rem 0;overflow:hidden;border-top:1px solid #e9ecef}.dropdown-item{display:block;width:100%;padding:.25rem 1.5rem;clear:both;font-weight:400;color:#212529;text-align:inherit;white-space:nowrap;background-color:transparent;border:0}.dropdown-item:focus,.dropdown-item:hover{color:#16181b;text-decoration:none;background-color:#f8f9fa}.dropdown-item.active,.dropdown-item:active{color:#fff;text-decoration:none;background-color:#007bff}.dropdown-item.disabled,.dropdown-item:disabled{color:#6c757d;pointer-events:none;background-color:transparent}.dropdown-menu.show{display:block}.dropdown-header{display:block;padding:.5rem 1.5rem;margin-bottom:0;font-size:.875rem;color:#6c757d;white-space:nowrap}.dropdown-item-text{display:block;padding:.25rem 1.5rem;color:#212529}.btn-group,.btn-group-vertical{position:relative;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;-ms-flex:1 1 auto;flex:1 1 auto}.btn-group-vertical>.btn:hover,.btn-group>.btn:hover{z-index:1}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus{z-index:1}.btn-toolbar{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-pack:start;justify-content:flex-start}.btn-toolbar .input-group{width:auto}.btn-group>.btn-group:not(:first-child),.btn-group>.btn:not(:first-child){margin-left:-1px}.btn-group>.btn-group:not(:last-child)>.btn,.btn-group>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:not(:first-child)>.btn,.btn-group>.btn:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.dropdown-toggle-split{padding-right:.5625rem;padding-left:.5625rem}.dropdown-toggle-split::after,.dropright .dropdown-toggle-split::after,.dropup .dropdown-toggle-split::after{margin-left:0}.dropleft .dropdown-toggle-split::before{margin-right:0}.btn-group-sm>.btn+.dropdown-toggle-split,.btn-sm+.dropdown-toggle-split{padding-right:.375rem;padding-left:.375rem}.btn-group-lg>.btn+.dropdown-toggle-split,.btn-lg+.dropdown-toggle-split{padding-right:.75rem;padding-left:.75rem}.btn-group-vertical{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:flex-start;-ms-flex-pack:center;justify-content:center}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group{width:100%}.btn-group-vertical>.btn-group:not(:first-child),.btn-group-vertical>.btn:not(:first-child){margin-top:-1px}.btn-group-vertical>.btn-group:not(:last-child)>.btn,.btn-group-vertical>.btn:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:not(:first-child)>.btn,.btn-group-vertical>.btn:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.btn-group-toggle>.btn,.btn-group-toggle>.btn-group>.btn{margin-bottom:0}.btn-group-toggle>.btn input[type=checkbox],.btn-group-toggle>.btn input[type=radio],.btn-group-toggle>.btn-group>.btn input[type=checkbox],.btn-group-toggle>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:stretch;align-items:stretch;width:100%}.input-group>.custom-file,.input-group>.custom-select,.input-group>.form-control,.input-group>.form-control-plaintext{position:relative;-ms-flex:1 1 0%;flex:1 1 0%;min-width:0;margin-bottom:0}.input-group>.custom-file+.custom-file,.input-group>.custom-file+.custom-select,.input-group>.custom-file+.form-control,.input-group>.custom-select+.custom-file,.input-group>.custom-select+.custom-select,.input-group>.custom-select+.form-control,.input-group>.form-control+.custom-file,.input-group>.form-control+.custom-select,.input-group>.form-control+.form-control,.input-group>.form-control-plaintext+.custom-file,.input-group>.form-control-plaintext+.custom-select,.input-group>.form-control-plaintext+.form-control{margin-left:-1px}.input-group>.custom-file .custom-file-input:focus~.custom-file-label,.input-group>.custom-select:focus,.input-group>.form-control:focus{z-index:3}.input-group>.custom-file .custom-file-input:focus{z-index:4}.input-group>.custom-select:not(:last-child),.input-group>.form-control:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-select:not(:first-child),.input-group>.form-control:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.input-group>.custom-file{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.input-group>.custom-file:not(:last-child) .custom-file-label,.input-group>.custom-file:not(:last-child) .custom-file-label::after{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-file:not(:first-child) .custom-file-label{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-append,.input-group-prepend{display:-ms-flexbox;display:flex}.input-group-append .btn,.input-group-prepend .btn{position:relative;z-index:2}.input-group-append .btn:focus,.input-group-prepend .btn:focus{z-index:3}.input-group-append .btn+.btn,.input-group-append .btn+.input-group-text,.input-group-append .input-group-text+.btn,.input-group-append .input-group-text+.input-group-text,.input-group-prepend .btn+.btn,.input-group-prepend .btn+.input-group-text,.input-group-prepend .input-group-text+.btn,.input-group-prepend .input-group-text+.input-group-text{margin-left:-1px}.input-group-prepend{margin-right:-1px}.input-group-append{margin-left:-1px}.input-group-text{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;padding:.375rem .75rem;margin-bottom:0;font-size:1rem;font-weight:400;line-height:1.5;color:#495057;text-align:center;white-space:nowrap;background-color:#e9ecef;border:1px solid #ced4da;border-radius:.25rem}.input-group-text input[type=checkbox],.input-group-text input[type=radio]{margin-top:0}.input-group-lg>.custom-select,.input-group-lg>.form-control:not(textarea){height:calc(1.5em + 1rem + 2px)}.input-group-lg>.custom-select,.input-group-lg>.form-control,.input-group-lg>.input-group-append>.btn,.input-group-lg>.input-group-append>.input-group-text,.input-group-lg>.input-group-prepend>.btn,.input-group-lg>.input-group-prepend>.input-group-text{padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}.input-group-sm>.custom-select,.input-group-sm>.form-control:not(textarea){height:calc(1.5em + .5rem + 2px)}.input-group-sm>.custom-select,.input-group-sm>.form-control,.input-group-sm>.input-group-append>.btn,.input-group-sm>.input-group-append>.input-group-text,.input-group-sm>.input-group-prepend>.btn,.input-group-sm>.input-group-prepend>.input-group-text{padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.input-group-lg>.custom-select,.input-group-sm>.custom-select{padding-right:1.75rem}.input-group>.input-group-append:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group>.input-group-append:last-child>.input-group-text:not(:last-child),.input-group>.input-group-append:not(:last-child)>.btn,.input-group>.input-group-append:not(:last-child)>.input-group-text,.input-group>.input-group-prepend>.btn,.input-group>.input-group-prepend>.input-group-text{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.input-group-append>.btn,.input-group>.input-group-append>.input-group-text,.input-group>.input-group-prepend:first-child>.btn:not(:first-child),.input-group>.input-group-prepend:first-child>.input-group-text:not(:first-child),.input-group>.input-group-prepend:not(:first-child)>.btn,.input-group>.input-group-prepend:not(:first-child)>.input-group-text{border-top-left-radius:0;border-bottom-left-radius:0}.custom-control{position:relative;display:block;min-height:1.5rem;padding-left:1.5rem}.custom-control-inline{display:-ms-inline-flexbox;display:inline-flex;margin-right:1rem}.custom-control-input{position:absolute;left:0;z-index:-1;width:1rem;height:1.25rem;opacity:0}.custom-control-input:checked~.custom-control-label::before{color:#fff;border-color:#007bff;background-color:#007bff}.custom-control-input:focus~.custom-control-label::before{box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.custom-control-input:focus:not(:checked)~.custom-control-label::before{border-color:#80bdff}.custom-control-input:not(:disabled):active~.custom-control-label::before{color:#fff;background-color:#b3d7ff;border-color:#b3d7ff}.custom-control-input:disabled~.custom-control-label,.custom-control-input[disabled]~.custom-control-label{color:#6c757d}.custom-control-input:disabled~.custom-control-label::before,.custom-control-input[disabled]~.custom-control-label::before{background-color:#e9ecef}.custom-control-label{position:relative;margin-bottom:0;vertical-align:top}.custom-control-label::before{position:absolute;top:.25rem;left:-1.5rem;display:block;width:1rem;height:1rem;pointer-events:none;content:"";background-color:#fff;border:#adb5bd solid 1px}.custom-control-label::after{position:absolute;top:.25rem;left:-1.5rem;display:block;width:1rem;height:1rem;content:"";background:no-repeat 50%/50% 50%}.custom-checkbox .custom-control-label::before{border-radius:.25rem}.custom-checkbox .custom-control-input:checked~.custom-control-label::after{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26l2.974 2.99L8 2.193z'/%3e%3c/svg%3e")}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::before{border-color:#007bff;background-color:#007bff}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::after{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3e%3cpath stroke='%23fff' d='M0 2h4'/%3e%3c/svg%3e")}.custom-checkbox .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-checkbox .custom-control-input:disabled:indeterminate~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-radio .custom-control-label::before{border-radius:50%}.custom-radio .custom-control-input:checked~.custom-control-label::after{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e")}.custom-radio .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-switch{padding-left:2.25rem}.custom-switch .custom-control-label::before{left:-2.25rem;width:1.75rem;pointer-events:all;border-radius:.5rem}.custom-switch .custom-control-label::after{top:calc(.25rem + 2px);left:calc(-2.25rem + 2px);width:calc(1rem - 4px);height:calc(1rem - 4px);background-color:#adb5bd;border-radius:.5rem;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out,-webkit-transform .15s ease-in-out;transition:transform .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:transform .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out,-webkit-transform .15s ease-in-out}@media (prefers-reduced-motion:reduce){.custom-switch .custom-control-label::after{transition:none}}.custom-switch .custom-control-input:checked~.custom-control-label::after{background-color:#fff;-webkit-transform:translateX(.75rem);transform:translateX(.75rem)}.custom-switch .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-select{display:inline-block;width:100%;height:calc(1.5em + .75rem + 2px);padding:.375rem 1.75rem .375rem .75rem;font-size:1rem;font-weight:400;line-height:1.5;color:#495057;vertical-align:middle;background:#fff url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23343a40' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right .75rem center/8px 10px;border:1px solid #ced4da;border-radius:.25rem;-webkit-appearance:none;-moz-appearance:none;appearance:none}.custom-select:focus{border-color:#80bdff;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.custom-select:focus::-ms-value{color:#495057;background-color:#fff}.custom-select[multiple],.custom-select[size]:not([size="1"]){height:auto;padding-right:.75rem;background-image:none}.custom-select:disabled{color:#6c757d;background-color:#e9ecef}.custom-select::-ms-expand{display:none}.custom-select:-moz-focusring{color:transparent;text-shadow:0 0 0 #495057}.custom-select-sm{height:calc(1.5em + .5rem + 2px);padding-top:.25rem;padding-bottom:.25rem;padding-left:.5rem;font-size:.875rem}.custom-select-lg{height:calc(1.5em + 1rem + 2px);padding-top:.5rem;padding-bottom:.5rem;padding-left:1rem;font-size:1.25rem}.custom-file{position:relative;display:inline-block;width:100%;height:calc(1.5em + .75rem + 2px);margin-bottom:0}.custom-file-input{position:relative;z-index:2;width:100%;height:calc(1.5em + .75rem + 2px);margin:0;opacity:0}.custom-file-input:focus~.custom-file-label{border-color:#80bdff;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.custom-file-input:disabled~.custom-file-label,.custom-file-input[disabled]~.custom-file-label{background-color:#e9ecef}.custom-file-input:lang(en)~.custom-file-label::after{content:"Browse"}.custom-file-input~.custom-file-label[data-browse]::after{content:attr(data-browse)}.custom-file-label{position:absolute;top:0;right:0;left:0;z-index:1;height:calc(1.5em + .75rem + 2px);padding:.375rem .75rem;font-weight:400;line-height:1.5;color:#495057;background-color:#fff;border:1px solid #ced4da;border-radius:.25rem}.custom-file-label::after{position:absolute;top:0;right:0;bottom:0;z-index:3;display:block;height:calc(1.5em + .75rem);padding:.375rem .75rem;line-height:1.5;color:#495057;content:"Browse";background-color:#e9ecef;border-left:inherit;border-radius:0 .25rem .25rem 0}.custom-range{width:100%;height:1.4rem;padding:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none}.custom-range:focus{outline:0}.custom-range:focus::-webkit-slider-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range:focus::-moz-range-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range:focus::-ms-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range::-moz-focus-outer{border:0}.custom-range::-webkit-slider-thumb{width:1rem;height:1rem;margin-top:-.25rem;background-color:#007bff;border:0;border-radius:1rem;-webkit-transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;-webkit-appearance:none;appearance:none}@media (prefers-reduced-motion:reduce){.custom-range::-webkit-slider-thumb{-webkit-transition:none;transition:none}}.custom-range::-webkit-slider-thumb:active{background-color:#b3d7ff}.custom-range::-webkit-slider-runnable-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:#dee2e6;border-color:transparent;border-radius:1rem}.custom-range::-moz-range-thumb{width:1rem;height:1rem;background-color:#007bff;border:0;border-radius:1rem;-moz-transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;-moz-appearance:none;appearance:none}@media (prefers-reduced-motion:reduce){.custom-range::-moz-range-thumb{-moz-transition:none;transition:none}}.custom-range::-moz-range-thumb:active{background-color:#b3d7ff}.custom-range::-moz-range-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:#dee2e6;border-color:transparent;border-radius:1rem}.custom-range::-ms-thumb{width:1rem;height:1rem;margin-top:0;margin-right:.2rem;margin-left:.2rem;background-color:#007bff;border:0;border-radius:1rem;-ms-transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;appearance:none}@media (prefers-reduced-motion:reduce){.custom-range::-ms-thumb{-ms-transition:none;transition:none}}.custom-range::-ms-thumb:active{background-color:#b3d7ff}.custom-range::-ms-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:transparent;border-color:transparent;border-width:.5rem}.custom-range::-ms-fill-lower{background-color:#dee2e6;border-radius:1rem}.custom-range::-ms-fill-upper{margin-right:15px;background-color:#dee2e6;border-radius:1rem}.custom-range:disabled::-webkit-slider-thumb{background-color:#adb5bd}.custom-range:disabled::-webkit-slider-runnable-track{cursor:default}.custom-range:disabled::-moz-range-thumb{background-color:#adb5bd}.custom-range:disabled::-moz-range-track{cursor:default}.custom-range:disabled::-ms-thumb{background-color:#adb5bd}.custom-control-label::before,.custom-file-label,.custom-select{transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.custom-control-label::before,.custom-file-label,.custom-select{transition:none}}.nav{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;padding-left:0;margin-bottom:0;list-style:none}.nav-link{display:block;padding:.5rem 1rem}.nav-link:focus,.nav-link:hover{text-decoration:none}.nav-link.disabled{color:#6c757d;pointer-events:none;cursor:default}.nav-tabs{border-bottom:1px solid #dee2e6}.nav-tabs .nav-item{margin-bottom:-1px}.nav-tabs .nav-link{border:1px solid transparent;border-top-left-radius:.25rem;border-top-right-radius:.25rem}.nav-tabs .nav-link:focus,.nav-tabs .nav-link:hover{border-color:#e9ecef #e9ecef #dee2e6}.nav-tabs .nav-link.disabled{color:#6c757d;background-color:transparent;border-color:transparent}.nav-tabs .nav-item.show .nav-link,.nav-tabs .nav-link.active{color:#495057;background-color:#fff;border-color:#dee2e6 #dee2e6 #fff}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.nav-pills .nav-link{border-radius:.25rem}.nav-pills .nav-link.active,.nav-pills .show>.nav-link{color:#fff;background-color:#007bff}.nav-fill .nav-item{-ms-flex:1 1 auto;flex:1 1 auto;text-align:center}.nav-justified .nav-item{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;text-align:center}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.navbar{position:relative;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;padding:.5rem 1rem}.navbar .container,.navbar .container-fluid,.navbar .container-lg,.navbar .container-md,.navbar .container-sm,.navbar .container-xl{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between}.navbar-brand{display:inline-block;padding-top:.3125rem;padding-bottom:.3125rem;margin-right:1rem;font-size:1.25rem;line-height:inherit;white-space:nowrap}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-nav{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;padding-left:0;margin-bottom:0;list-style:none}.navbar-nav .nav-link{padding-right:0;padding-left:0}.navbar-nav .dropdown-menu{position:static;float:none}.navbar-text{display:inline-block;padding-top:.5rem;padding-bottom:.5rem}.navbar-collapse{-ms-flex-preferred-size:100%;flex-basis:100%;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center}.navbar-toggler{padding:.25rem .75rem;font-size:1.25rem;line-height:1;background-color:transparent;border:1px solid transparent;border-radius:.25rem}.navbar-toggler:focus,.navbar-toggler:hover{text-decoration:none}.navbar-toggler-icon{display:inline-block;width:1.5em;height:1.5em;vertical-align:middle;content:"";background:no-repeat center center;background-size:100% 100%}@media (max-width:575.98px){.navbar-expand-sm>.container,.navbar-expand-sm>.container-fluid,.navbar-expand-sm>.container-lg,.navbar-expand-sm>.container-md,.navbar-expand-sm>.container-sm,.navbar-expand-sm>.container-xl{padding-right:0;padding-left:0}}@media (min-width:576px){.navbar-expand-sm{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-sm .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-sm .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-sm .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-sm>.container,.navbar-expand-sm>.container-fluid,.navbar-expand-sm>.container-lg,.navbar-expand-sm>.container-md,.navbar-expand-sm>.container-sm,.navbar-expand-sm>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-sm .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-sm .navbar-toggler{display:none}}@media (max-width:767.98px){.navbar-expand-md>.container,.navbar-expand-md>.container-fluid,.navbar-expand-md>.container-lg,.navbar-expand-md>.container-md,.navbar-expand-md>.container-sm,.navbar-expand-md>.container-xl{padding-right:0;padding-left:0}}@media (min-width:768px){.navbar-expand-md{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-md .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-md .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-md .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-md>.container,.navbar-expand-md>.container-fluid,.navbar-expand-md>.container-lg,.navbar-expand-md>.container-md,.navbar-expand-md>.container-sm,.navbar-expand-md>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-md .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-md .navbar-toggler{display:none}}@media (max-width:991.98px){.navbar-expand-lg>.container,.navbar-expand-lg>.container-fluid,.navbar-expand-lg>.container-lg,.navbar-expand-lg>.container-md,.navbar-expand-lg>.container-sm,.navbar-expand-lg>.container-xl{padding-right:0;padding-left:0}}@media (min-width:992px){.navbar-expand-lg{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-lg .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-lg .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-lg .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-lg>.container,.navbar-expand-lg>.container-fluid,.navbar-expand-lg>.container-lg,.navbar-expand-lg>.container-md,.navbar-expand-lg>.container-sm,.navbar-expand-lg>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-lg .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-lg .navbar-toggler{display:none}}@media (max-width:1199.98px){.navbar-expand-xl>.container,.navbar-expand-xl>.container-fluid,.navbar-expand-xl>.container-lg,.navbar-expand-xl>.container-md,.navbar-expand-xl>.container-sm,.navbar-expand-xl>.container-xl{padding-right:0;padding-left:0}}@media (min-width:1200px){.navbar-expand-xl{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-xl .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-xl .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-xl .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-xl>.container,.navbar-expand-xl>.container-fluid,.navbar-expand-xl>.container-lg,.navbar-expand-xl>.container-md,.navbar-expand-xl>.container-sm,.navbar-expand-xl>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-xl .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-xl .navbar-toggler{display:none}}.navbar-expand{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand>.container,.navbar-expand>.container-fluid,.navbar-expand>.container-lg,.navbar-expand>.container-md,.navbar-expand>.container-sm,.navbar-expand>.container-xl{padding-right:0;padding-left:0}.navbar-expand .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand .navbar-nav .dropdown-menu{position:absolute}.navbar-expand .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand>.container,.navbar-expand>.container-fluid,.navbar-expand>.container-lg,.navbar-expand>.container-md,.navbar-expand>.container-sm,.navbar-expand>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand .navbar-toggler{display:none}.navbar-light .navbar-brand{color:rgba(0,0,0,.9)}.navbar-light .navbar-brand:focus,.navbar-light .navbar-brand:hover{color:rgba(0,0,0,.9)}.navbar-light .navbar-nav .nav-link{color:rgba(0,0,0,.5)}.navbar-light .navbar-nav .nav-link:focus,.navbar-light .navbar-nav .nav-link:hover{color:rgba(0,0,0,.7)}.navbar-light .navbar-nav .nav-link.disabled{color:rgba(0,0,0,.3)}.navbar-light .navbar-nav .active>.nav-link,.navbar-light .navbar-nav .nav-link.active,.navbar-light .navbar-nav .nav-link.show,.navbar-light .navbar-nav .show>.nav-link{color:rgba(0,0,0,.9)}.navbar-light .navbar-toggler{color:rgba(0,0,0,.5);border-color:rgba(0,0,0,.1)}.navbar-light .navbar-toggler-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3e%3cpath stroke='rgba(0, 0, 0, 0.5)' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e")}.navbar-light .navbar-text{color:rgba(0,0,0,.5)}.navbar-light .navbar-text a{color:rgba(0,0,0,.9)}.navbar-light .navbar-text a:focus,.navbar-light .navbar-text a:hover{color:rgba(0,0,0,.9)}.navbar-dark .navbar-brand{color:#fff}.navbar-dark .navbar-brand:focus,.navbar-dark .navbar-brand:hover{color:#fff}.navbar-dark .navbar-nav .nav-link{color:rgba(255,255,255,.5)}.navbar-dark .navbar-nav .nav-link:focus,.navbar-dark .navbar-nav .nav-link:hover{color:rgba(255,255,255,.75)}.navbar-dark .navbar-nav .nav-link.disabled{color:rgba(255,255,255,.25)}.navbar-dark .navbar-nav .active>.nav-link,.navbar-dark .navbar-nav .nav-link.active,.navbar-dark .navbar-nav .nav-link.show,.navbar-dark .navbar-nav .show>.nav-link{color:#fff}.navbar-dark .navbar-toggler{color:rgba(255,255,255,.5);border-color:rgba(255,255,255,.1)}.navbar-dark .navbar-toggler-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3e%3cpath stroke='rgba(255, 255, 255, 0.5)' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e")}.navbar-dark .navbar-text{color:rgba(255,255,255,.5)}.navbar-dark .navbar-text a{color:#fff}.navbar-dark .navbar-text a:focus,.navbar-dark .navbar-text a:hover{color:#fff}.card{position:relative;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-width:0;word-wrap:break-word;background-color:#fff;background-clip:border-box;border:1px solid rgba(0,0,0,.125);border-radius:.25rem}.card>hr{margin-right:0;margin-left:0}.card>.list-group:first-child .list-group-item:first-child{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.card>.list-group:last-child .list-group-item:last-child{border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.card-body{-ms-flex:1 1 auto;flex:1 1 auto;min-height:1px;padding:1.25rem}.card-title{margin-bottom:.75rem}.card-subtitle{margin-top:-.375rem;margin-bottom:0}.card-text:last-child{margin-bottom:0}.card-link:hover{text-decoration:none}.card-link+.card-link{margin-left:1.25rem}.card-header{padding:.75rem 1.25rem;margin-bottom:0;background-color:rgba(0,0,0,.03);border-bottom:1px solid rgba(0,0,0,.125)}.card-header:first-child{border-radius:calc(.25rem - 1px) calc(.25rem - 1px) 0 0}.card-header+.list-group .list-group-item:first-child{border-top:0}.card-footer{padding:.75rem 1.25rem;background-color:rgba(0,0,0,.03);border-top:1px solid rgba(0,0,0,.125)}.card-footer:last-child{border-radius:0 0 calc(.25rem - 1px) calc(.25rem - 1px)}.card-header-tabs{margin-right:-.625rem;margin-bottom:-.75rem;margin-left:-.625rem;border-bottom:0}.card-header-pills{margin-right:-.625rem;margin-left:-.625rem}.card-img-overlay{position:absolute;top:0;right:0;bottom:0;left:0;padding:1.25rem}.card-img,.card-img-bottom,.card-img-top{-ms-flex-negative:0;flex-shrink:0;width:100%}.card-img,.card-img-top{border-top-left-radius:calc(.25rem - 1px);border-top-right-radius:calc(.25rem - 1px)}.card-img,.card-img-bottom{border-bottom-right-radius:calc(.25rem - 1px);border-bottom-left-radius:calc(.25rem - 1px)}.card-deck .card{margin-bottom:15px}@media (min-width:576px){.card-deck{display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;margin-right:-15px;margin-left:-15px}.card-deck .card{-ms-flex:1 0 0%;flex:1 0 0%;margin-right:15px;margin-bottom:0;margin-left:15px}}.card-group>.card{margin-bottom:15px}@media (min-width:576px){.card-group{display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap}.card-group>.card{-ms-flex:1 0 0%;flex:1 0 0%;margin-bottom:0}.card-group>.card+.card{margin-left:0;border-left:0}.card-group>.card:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.card-group>.card:not(:last-child) .card-header,.card-group>.card:not(:last-child) .card-img-top{border-top-right-radius:0}.card-group>.card:not(:last-child) .card-footer,.card-group>.card:not(:last-child) .card-img-bottom{border-bottom-right-radius:0}.card-group>.card:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.card-group>.card:not(:first-child) .card-header,.card-group>.card:not(:first-child) .card-img-top{border-top-left-radius:0}.card-group>.card:not(:first-child) .card-footer,.card-group>.card:not(:first-child) .card-img-bottom{border-bottom-left-radius:0}}.card-columns .card{margin-bottom:.75rem}@media (min-width:576px){.card-columns{-webkit-column-count:3;-moz-column-count:3;column-count:3;-webkit-column-gap:1.25rem;-moz-column-gap:1.25rem;column-gap:1.25rem;orphans:1;widows:1}.card-columns .card{display:inline-block;width:100%}}.accordion>.card{overflow:hidden}.accordion>.card:not(:last-of-type){border-bottom:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.accordion>.card:not(:first-of-type){border-top-left-radius:0;border-top-right-radius:0}.accordion>.card>.card-header{border-radius:0;margin-bottom:-1px}.breadcrumb{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;padding:.75rem 1rem;margin-bottom:1rem;list-style:none;background-color:#e9ecef;border-radius:.25rem}.breadcrumb-item+.breadcrumb-item{padding-left:.5rem}.breadcrumb-item+.breadcrumb-item::before{display:inline-block;padding-right:.5rem;color:#6c757d;content:"/"}.breadcrumb-item+.breadcrumb-item:hover::before{text-decoration:underline}.breadcrumb-item+.breadcrumb-item:hover::before{text-decoration:none}.breadcrumb-item.active{color:#6c757d}.pagination{display:-ms-flexbox;display:flex;padding-left:0;list-style:none;border-radius:.25rem}.page-link{position:relative;display:block;padding:.5rem .75rem;margin-left:-1px;line-height:1.25;color:#007bff;background-color:#fff;border:1px solid #dee2e6}.page-link:hover{z-index:2;color:#0056b3;text-decoration:none;background-color:#e9ecef;border-color:#dee2e6}.page-link:focus{z-index:3;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.page-item:first-child .page-link{margin-left:0;border-top-left-radius:.25rem;border-bottom-left-radius:.25rem}.page-item:last-child .page-link{border-top-right-radius:.25rem;border-bottom-right-radius:.25rem}.page-item.active .page-link{z-index:3;color:#fff;background-color:#007bff;border-color:#007bff}.page-item.disabled .page-link{color:#6c757d;pointer-events:none;cursor:auto;background-color:#fff;border-color:#dee2e6}.pagination-lg .page-link{padding:.75rem 1.5rem;font-size:1.25rem;line-height:1.5}.pagination-lg .page-item:first-child .page-link{border-top-left-radius:.3rem;border-bottom-left-radius:.3rem}.pagination-lg .page-item:last-child .page-link{border-top-right-radius:.3rem;border-bottom-right-radius:.3rem}.pagination-sm .page-link{padding:.25rem .5rem;font-size:.875rem;line-height:1.5}.pagination-sm .page-item:first-child .page-link{border-top-left-radius:.2rem;border-bottom-left-radius:.2rem}.pagination-sm .page-item:last-child .page-link{border-top-right-radius:.2rem;border-bottom-right-radius:.2rem}.badge{display:inline-block;padding:.25em .4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25rem;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:focus,a.badge:hover{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:.6em;padding-left:.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:focus,a.badge-primary:hover{color:#fff;background-color:#0062cc}a.badge-primary.focus,a.badge-primary:focus{outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:focus,a.badge-secondary:hover{color:#fff;background-color:#545b62}a.badge-secondary.focus,a.badge-secondary:focus{outline:0;box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:focus,a.badge-success:hover{color:#fff;background-color:#1e7e34}a.badge-success.focus,a.badge-success:focus{outline:0;box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:focus,a.badge-info:hover{color:#fff;background-color:#117a8b}a.badge-info.focus,a.badge-info:focus{outline:0;box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:focus,a.badge-warning:hover{color:#212529;background-color:#d39e00}a.badge-warning.focus,a.badge-warning:focus{outline:0;box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:focus,a.badge-danger:hover{color:#fff;background-color:#bd2130}a.badge-danger.focus,a.badge-danger:focus{outline:0;box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:focus,a.badge-light:hover{color:#212529;background-color:#dae0e5}a.badge-light.focus,a.badge-light:focus{outline:0;box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:focus,a.badge-dark:hover{color:#fff;background-color:#1d2124}a.badge-dark.focus,a.badge-dark:focus{outline:0;box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.jumbotron{padding:2rem 1rem;margin-bottom:2rem;background-color:#e9ecef;border-radius:.3rem}@media (min-width:576px){.jumbotron{padding:4rem 2rem}}.jumbotron-fluid{padding-right:0;padding-left:0;border-radius:0}.alert{position:relative;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid transparent;border-radius:.25rem}.alert-heading{color:inherit}.alert-link{font-weight:700}.alert-dismissible{padding-right:4rem}.alert-dismissible .close{position:absolute;top:0;right:0;padding:.75rem 1.25rem;color:inherit}.alert-primary{color:#004085;background-color:#cce5ff;border-color:#b8daff}.alert-primary hr{border-top-color:#9fcdff}.alert-primary .alert-link{color:#002752}.alert-secondary{color:#383d41;background-color:#e2e3e5;border-color:#d6d8db}.alert-secondary hr{border-top-color:#c8cbcf}.alert-secondary .alert-link{color:#202326}.alert-success{color:#155724;background-color:#d4edda;border-color:#c3e6cb}.alert-success hr{border-top-color:#b1dfbb}.alert-success .alert-link{color:#0b2e13}.alert-info{color:#0c5460;background-color:#d1ecf1;border-color:#bee5eb}.alert-info hr{border-top-color:#abdde5}.alert-info .alert-link{color:#062c33}.alert-warning{color:#856404;background-color:#fff3cd;border-color:#ffeeba}.alert-warning hr{border-top-color:#ffe8a1}.alert-warning .alert-link{color:#533f03}.alert-danger{color:#721c24;background-color:#f8d7da;border-color:#f5c6cb}.alert-danger hr{border-top-color:#f1b0b7}.alert-danger .alert-link{color:#491217}.alert-light{color:#818182;background-color:#fefefe;border-color:#fdfdfe}.alert-light hr{border-top-color:#ececf6}.alert-light .alert-link{color:#686868}.alert-dark{color:#1b1e21;background-color:#d6d8d9;border-color:#c6c8ca}.alert-dark hr{border-top-color:#b9bbbe}.alert-dark .alert-link{color:#040505}@-webkit-keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}.progress{display:-ms-flexbox;display:flex;height:1rem;overflow:hidden;font-size:.75rem;background-color:#e9ecef;border-radius:.25rem}.progress-bar{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;overflow:hidden;color:#fff;text-align:center;white-space:nowrap;background-color:#007bff;transition:width .6s ease}@media (prefers-reduced-motion:reduce){.progress-bar{transition:none}}.progress-bar-striped{background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-size:1rem 1rem}.progress-bar-animated{-webkit-animation:progress-bar-stripes 1s linear infinite;animation:progress-bar-stripes 1s linear infinite}@media (prefers-reduced-motion:reduce){.progress-bar-animated{-webkit-animation:none;animation:none}}.media{display:-ms-flexbox;display:flex;-ms-flex-align:start;align-items:flex-start}.media-body{-ms-flex:1;flex:1}.list-group{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;padding-left:0;margin-bottom:0}.list-group-item-action{width:100%;color:#495057;text-align:inherit}.list-group-item-action:focus,.list-group-item-action:hover{z-index:1;color:#495057;text-decoration:none;background-color:#f8f9fa}.list-group-item-action:active{color:#212529;background-color:#e9ecef}.list-group-item{position:relative;display:block;padding:.75rem 1.25rem;background-color:#fff;border:1px solid rgba(0,0,0,.125)}.list-group-item:first-child{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.list-group-item:last-child{border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.list-group-item.disabled,.list-group-item:disabled{color:#6c757d;pointer-events:none;background-color:#fff}.list-group-item.active{z-index:2;color:#fff;background-color:#007bff;border-color:#007bff}.list-group-item+.list-group-item{border-top-width:0}.list-group-item+.list-group-item.active{margin-top:-1px;border-top-width:1px}.list-group-horizontal{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal .list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal .list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal .list-group-item.active{margin-top:0}.list-group-horizontal .list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal .list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}@media (min-width:576px){.list-group-horizontal-sm{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-sm .list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-sm .list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-sm .list-group-item.active{margin-top:0}.list-group-horizontal-sm .list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-sm .list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}@media (min-width:768px){.list-group-horizontal-md{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-md .list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-md .list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-md .list-group-item.active{margin-top:0}.list-group-horizontal-md .list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-md .list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}@media (min-width:992px){.list-group-horizontal-lg{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-lg .list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-lg .list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-lg .list-group-item.active{margin-top:0}.list-group-horizontal-lg .list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-lg .list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}@media (min-width:1200px){.list-group-horizontal-xl{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-xl .list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-xl .list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-xl .list-group-item.active{margin-top:0}.list-group-horizontal-xl .list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-xl .list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}.list-group-flush .list-group-item{border-right-width:0;border-left-width:0;border-radius:0}.list-group-flush .list-group-item:first-child{border-top-width:0}.list-group-flush:last-child .list-group-item:last-child{border-bottom-width:0}.list-group-item-primary{color:#004085;background-color:#b8daff}.list-group-item-primary.list-group-item-action:focus,.list-group-item-primary.list-group-item-action:hover{color:#004085;background-color:#9fcdff}.list-group-item-primary.list-group-item-action.active{color:#fff;background-color:#004085;border-color:#004085}.list-group-item-secondary{color:#383d41;background-color:#d6d8db}.list-group-item-secondary.list-group-item-action:focus,.list-group-item-secondary.list-group-item-action:hover{color:#383d41;background-color:#c8cbcf}.list-group-item-secondary.list-group-item-action.active{color:#fff;background-color:#383d41;border-color:#383d41}.list-group-item-success{color:#155724;background-color:#c3e6cb}.list-group-item-success.list-group-item-action:focus,.list-group-item-success.list-group-item-action:hover{color:#155724;background-color:#b1dfbb}.list-group-item-success.list-group-item-action.active{color:#fff;background-color:#155724;border-color:#155724}.list-group-item-info{color:#0c5460;background-color:#bee5eb}.list-group-item-info.list-group-item-action:focus,.list-group-item-info.list-group-item-action:hover{color:#0c5460;background-color:#abdde5}.list-group-item-info.list-group-item-action.active{color:#fff;background-color:#0c5460;border-color:#0c5460}.list-group-item-warning{color:#856404;background-color:#ffeeba}.list-group-item-warning.list-group-item-action:focus,.list-group-item-warning.list-group-item-action:hover{color:#856404;background-color:#ffe8a1}.list-group-item-warning.list-group-item-action.active{color:#fff;background-color:#856404;border-color:#856404}.list-group-item-danger{color:#721c24;background-color:#f5c6cb}.list-group-item-danger.list-group-item-action:focus,.list-group-item-danger.list-group-item-action:hover{color:#721c24;background-color:#f1b0b7}.list-group-item-danger.list-group-item-action.active{color:#fff;background-color:#721c24;border-color:#721c24}.list-group-item-light{color:#818182;background-color:#fdfdfe}.list-group-item-light.list-group-item-action:focus,.list-group-item-light.list-group-item-action:hover{color:#818182;background-color:#ececf6}.list-group-item-light.list-group-item-action.active{color:#fff;background-color:#818182;border-color:#818182}.list-group-item-dark{color:#1b1e21;background-color:#c6c8ca}.list-group-item-dark.list-group-item-action:focus,.list-group-item-dark.list-group-item-action:hover{color:#1b1e21;background-color:#b9bbbe}.list-group-item-dark.list-group-item-action.active{color:#fff;background-color:#1b1e21;border-color:#1b1e21}.close{float:right;font-size:1.5rem;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.5}.close:hover{color:#000;text-decoration:none}.close:not(:disabled):not(.disabled):focus,.close:not(:disabled):not(.disabled):hover{opacity:.75}button.close{padding:0;background-color:transparent;border:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}a.close.disabled{pointer-events:none}.toast{max-width:350px;overflow:hidden;font-size:.875rem;background-color:rgba(255,255,255,.85);background-clip:padding-box;border:1px solid rgba(0,0,0,.1);box-shadow:0 .25rem .75rem rgba(0,0,0,.1);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);opacity:0;border-radius:.25rem}.toast:not(:last-child){margin-bottom:.75rem}.toast.showing{opacity:1}.toast.show{display:block;opacity:1}.toast.hide{display:none}.toast-header{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;padding:.25rem .75rem;color:#6c757d;background-color:rgba(255,255,255,.85);background-clip:padding-box;border-bottom:1px solid rgba(0,0,0,.05)}.toast-body{padding:.75rem}.modal-open{overflow:hidden}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal{position:fixed;top:0;left:0;z-index:1050;display:none;width:100%;height:100%;overflow:hidden;outline:0}.modal-dialog{position:relative;width:auto;margin:.5rem;pointer-events:none}.modal.fade .modal-dialog{transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out;-webkit-transform:translate(0,-50px);transform:translate(0,-50px)}@media (prefers-reduced-motion:reduce){.modal.fade .modal-dialog{transition:none}}.modal.show .modal-dialog{-webkit-transform:none;transform:none}.modal.modal-static .modal-dialog{-webkit-transform:scale(1.02);transform:scale(1.02)}.modal-dialog-scrollable{display:-ms-flexbox;display:flex;max-height:calc(100% - 1rem)}.modal-dialog-scrollable .modal-content{max-height:calc(100vh - 1rem);overflow:hidden}.modal-dialog-scrollable .modal-footer,.modal-dialog-scrollable .modal-header{-ms-flex-negative:0;flex-shrink:0}.modal-dialog-scrollable .modal-body{overflow-y:auto}.modal-dialog-centered{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;min-height:calc(100% - 1rem)}.modal-dialog-centered::before{display:block;height:calc(100vh - 1rem);content:""}.modal-dialog-centered.modal-dialog-scrollable{-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;height:100%}.modal-dialog-centered.modal-dialog-scrollable .modal-content{max-height:none}.modal-dialog-centered.modal-dialog-scrollable::before{content:none}.modal-content{position:relative;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:100%;pointer-events:auto;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem;outline:0}.modal-backdrop{position:fixed;top:0;left:0;z-index:1040;width:100vw;height:100vh;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop.show{opacity:.5}.modal-header{display:-ms-flexbox;display:flex;-ms-flex-align:start;align-items:flex-start;-ms-flex-pack:justify;justify-content:space-between;padding:1rem 1rem;border-bottom:1px solid #dee2e6;border-top-left-radius:calc(.3rem - 1px);border-top-right-radius:calc(.3rem - 1px)}.modal-header .close{padding:1rem 1rem;margin:-1rem -1rem -1rem auto}.modal-title{margin-bottom:0;line-height:1.5}.modal-body{position:relative;-ms-flex:1 1 auto;flex:1 1 auto;padding:1rem}.modal-footer{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:end;justify-content:flex-end;padding:.75rem;border-top:1px solid #dee2e6;border-bottom-right-radius:calc(.3rem - 1px);border-bottom-left-radius:calc(.3rem - 1px)}.modal-footer>*{margin:.25rem}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:576px){.modal-dialog{max-width:500px;margin:1.75rem auto}.modal-dialog-scrollable{max-height:calc(100% - 3.5rem)}.modal-dialog-scrollable .modal-content{max-height:calc(100vh - 3.5rem)}.modal-dialog-centered{min-height:calc(100% - 3.5rem)}.modal-dialog-centered::before{height:calc(100vh - 3.5rem)}.modal-sm{max-width:300px}}@media (min-width:992px){.modal-lg,.modal-xl{max-width:800px}}@media (min-width:1200px){.modal-xl{max-width:1140px}}.tooltip{position:absolute;z-index:1070;display:block;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.875rem;word-wrap:break-word;opacity:0}.tooltip.show{opacity:.9}.tooltip .arrow{position:absolute;display:block;width:.8rem;height:.4rem}.tooltip .arrow::before{position:absolute;content:"";border-color:transparent;border-style:solid}.bs-tooltip-auto[x-placement^=top],.bs-tooltip-top{padding:.4rem 0}.bs-tooltip-auto[x-placement^=top] .arrow,.bs-tooltip-top .arrow{bottom:0}.bs-tooltip-auto[x-placement^=top] .arrow::before,.bs-tooltip-top .arrow::before{top:0;border-width:.4rem .4rem 0;border-top-color:#000}.bs-tooltip-auto[x-placement^=right],.bs-tooltip-right{padding:0 .4rem}.bs-tooltip-auto[x-placement^=right] .arrow,.bs-tooltip-right .arrow{left:0;width:.4rem;height:.8rem}.bs-tooltip-auto[x-placement^=right] .arrow::before,.bs-tooltip-right .arrow::before{right:0;border-width:.4rem .4rem .4rem 0;border-right-color:#000}.bs-tooltip-auto[x-placement^=bottom],.bs-tooltip-bottom{padding:.4rem 0}.bs-tooltip-auto[x-placement^=bottom] .arrow,.bs-tooltip-bottom .arrow{top:0}.bs-tooltip-auto[x-placement^=bottom] .arrow::before,.bs-tooltip-bottom .arrow::before{bottom:0;border-width:0 .4rem .4rem;border-bottom-color:#000}.bs-tooltip-auto[x-placement^=left],.bs-tooltip-left{padding:0 .4rem}.bs-tooltip-auto[x-placement^=left] .arrow,.bs-tooltip-left .arrow{right:0;width:.4rem;height:.8rem}.bs-tooltip-auto[x-placement^=left] .arrow::before,.bs-tooltip-left .arrow::before{left:0;border-width:.4rem 0 .4rem .4rem;border-left-color:#000}.tooltip-inner{max-width:200px;padding:.25rem .5rem;color:#fff;text-align:center;background-color:#000;border-radius:.25rem}.popover{position:absolute;top:0;left:0;z-index:1060;display:block;max-width:276px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.875rem;word-wrap:break-word;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem}.popover .arrow{position:absolute;display:block;width:1rem;height:.5rem;margin:0 .3rem}.popover .arrow::after,.popover .arrow::before{position:absolute;display:block;content:"";border-color:transparent;border-style:solid}.bs-popover-auto[x-placement^=top],.bs-popover-top{margin-bottom:.5rem}.bs-popover-auto[x-placement^=top]>.arrow,.bs-popover-top>.arrow{bottom:calc(-.5rem - 1px)}.bs-popover-auto[x-placement^=top]>.arrow::before,.bs-popover-top>.arrow::before{bottom:0;border-width:.5rem .5rem 0;border-top-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=top]>.arrow::after,.bs-popover-top>.arrow::after{bottom:1px;border-width:.5rem .5rem 0;border-top-color:#fff}.bs-popover-auto[x-placement^=right],.bs-popover-right{margin-left:.5rem}.bs-popover-auto[x-placement^=right]>.arrow,.bs-popover-right>.arrow{left:calc(-.5rem - 1px);width:.5rem;height:1rem;margin:.3rem 0}.bs-popover-auto[x-placement^=right]>.arrow::before,.bs-popover-right>.arrow::before{left:0;border-width:.5rem .5rem .5rem 0;border-right-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=right]>.arrow::after,.bs-popover-right>.arrow::after{left:1px;border-width:.5rem .5rem .5rem 0;border-right-color:#fff}.bs-popover-auto[x-placement^=bottom],.bs-popover-bottom{margin-top:.5rem}.bs-popover-auto[x-placement^=bottom]>.arrow,.bs-popover-bottom>.arrow{top:calc(-.5rem - 1px)}.bs-popover-auto[x-placement^=bottom]>.arrow::before,.bs-popover-bottom>.arrow::before{top:0;border-width:0 .5rem .5rem .5rem;border-bottom-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=bottom]>.arrow::after,.bs-popover-bottom>.arrow::after{top:1px;border-width:0 .5rem .5rem .5rem;border-bottom-color:#fff}.bs-popover-auto[x-placement^=bottom] .popover-header::before,.bs-popover-bottom .popover-header::before{position:absolute;top:0;left:50%;display:block;width:1rem;margin-left:-.5rem;content:"";border-bottom:1px solid #f7f7f7}.bs-popover-auto[x-placement^=left],.bs-popover-left{margin-right:.5rem}.bs-popover-auto[x-placement^=left]>.arrow,.bs-popover-left>.arrow{right:calc(-.5rem - 1px);width:.5rem;height:1rem;margin:.3rem 0}.bs-popover-auto[x-placement^=left]>.arrow::before,.bs-popover-left>.arrow::before{right:0;border-width:.5rem 0 .5rem .5rem;border-left-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=left]>.arrow::after,.bs-popover-left>.arrow::after{right:1px;border-width:.5rem 0 .5rem .5rem;border-left-color:#fff}.popover-header{padding:.5rem .75rem;margin-bottom:0;font-size:1rem;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-top-left-radius:calc(.3rem - 1px);border-top-right-radius:calc(.3rem - 1px)}.popover-header:empty{display:none}.popover-body{padding:.5rem .75rem;color:#212529}.carousel{position:relative}.carousel.pointer-event{-ms-touch-action:pan-y;touch-action:pan-y}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner::after{display:block;clear:both;content:""}.carousel-item{position:relative;display:none;float:left;width:100%;margin-right:-100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;transition:-webkit-transform .6s ease-in-out;transition:transform .6s ease-in-out;transition:transform .6s ease-in-out,-webkit-transform .6s ease-in-out}@media (prefers-reduced-motion:reduce){.carousel-item{transition:none}}.carousel-item-next,.carousel-item-prev,.carousel-item.active{display:block}.active.carousel-item-right,.carousel-item-next:not(.carousel-item-left){-webkit-transform:translateX(100%);transform:translateX(100%)}.active.carousel-item-left,.carousel-item-prev:not(.carousel-item-right){-webkit-transform:translateX(-100%);transform:translateX(-100%)}.carousel-fade .carousel-item{opacity:0;transition-property:opacity;-webkit-transform:none;transform:none}.carousel-fade .carousel-item-next.carousel-item-left,.carousel-fade .carousel-item-prev.carousel-item-right,.carousel-fade .carousel-item.active{z-index:1;opacity:1}.carousel-fade .active.carousel-item-left,.carousel-fade .active.carousel-item-right{z-index:0;opacity:0;transition:opacity 0s .6s}@media (prefers-reduced-motion:reduce){.carousel-fade .active.carousel-item-left,.carousel-fade .active.carousel-item-right{transition:none}}.carousel-control-next,.carousel-control-prev{position:absolute;top:0;bottom:0;z-index:1;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:15%;color:#fff;text-align:center;opacity:.5;transition:opacity .15s ease}@media (prefers-reduced-motion:reduce){.carousel-control-next,.carousel-control-prev{transition:none}}.carousel-control-next:focus,.carousel-control-next:hover,.carousel-control-prev:focus,.carousel-control-prev:hover{color:#fff;text-decoration:none;outline:0;opacity:.9}.carousel-control-prev{left:0}.carousel-control-next{right:0}.carousel-control-next-icon,.carousel-control-prev-icon{display:inline-block;width:20px;height:20px;background:no-repeat 50%/100% 100%}.carousel-control-prev-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath d='M5.25 0l-4 4 4 4 1.5-1.5L4.25 4l2.5-2.5L5.25 0z'/%3e%3c/svg%3e")}.carousel-control-next-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath d='M2.75 0l-1.5 1.5L3.75 4l-2.5 2.5L2.75 8l4-4-4-4z'/%3e%3c/svg%3e")}.carousel-indicators{position:absolute;right:0;bottom:0;left:0;z-index:15;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;padding-left:0;margin-right:15%;margin-left:15%;list-style:none}.carousel-indicators li{box-sizing:content-box;-ms-flex:0 1 auto;flex:0 1 auto;width:30px;height:3px;margin-right:3px;margin-left:3px;text-indent:-999px;cursor:pointer;background-color:#fff;background-clip:padding-box;border-top:10px solid transparent;border-bottom:10px solid transparent;opacity:.5;transition:opacity .6s ease}@media (prefers-reduced-motion:reduce){.carousel-indicators li{transition:none}}.carousel-indicators .active{opacity:1}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center}@-webkit-keyframes spinner-border{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-border{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.spinner-border{display:inline-block;width:2rem;height:2rem;vertical-align:text-bottom;border:.25em solid currentColor;border-right-color:transparent;border-radius:50%;-webkit-animation:spinner-border .75s linear infinite;animation:spinner-border .75s linear infinite}.spinner-border-sm{width:1rem;height:1rem;border-width:.2em}@-webkit-keyframes spinner-grow{0%{-webkit-transform:scale(0);transform:scale(0)}50%{opacity:1}}@keyframes spinner-grow{0%{-webkit-transform:scale(0);transform:scale(0)}50%{opacity:1}}.spinner-grow{display:inline-block;width:2rem;height:2rem;vertical-align:text-bottom;background-color:currentColor;border-radius:50%;opacity:0;-webkit-animation:spinner-grow .75s linear infinite;animation:spinner-grow .75s linear infinite}.spinner-grow-sm{width:1rem;height:1rem}.align-baseline{vertical-align:baseline!important}.align-top{vertical-align:top!important}.align-middle{vertical-align:middle!important}.align-bottom{vertical-align:bottom!important}.align-text-bottom{vertical-align:text-bottom!important}.align-text-top{vertical-align:text-top!important}.bg-primary{background-color:#007bff!important}a.bg-primary:focus,a.bg-primary:hover,button.bg-primary:focus,button.bg-primary:hover{background-color:#0062cc!important}.bg-secondary{background-color:#6c757d!important}a.bg-secondary:focus,a.bg-secondary:hover,button.bg-secondary:focus,button.bg-secondary:hover{background-color:#545b62!important}.bg-success{background-color:#28a745!important}a.bg-success:focus,a.bg-success:hover,button.bg-success:focus,button.bg-success:hover{background-color:#1e7e34!important}.bg-info{background-color:#17a2b8!important}a.bg-info:focus,a.bg-info:hover,button.bg-info:focus,button.bg-info:hover{background-color:#117a8b!important}.bg-warning{background-color:#ffc107!important}a.bg-warning:focus,a.bg-warning:hover,button.bg-warning:focus,button.bg-warning:hover{background-color:#d39e00!important}.bg-danger{background-color:#dc3545!important}a.bg-danger:focus,a.bg-danger:hover,button.bg-danger:focus,button.bg-danger:hover{background-color:#bd2130!important}.bg-light{background-color:#f8f9fa!important}a.bg-light:focus,a.bg-light:hover,button.bg-light:focus,button.bg-light:hover{background-color:#dae0e5!important}.bg-dark{background-color:#343a40!important}a.bg-dark:focus,a.bg-dark:hover,button.bg-dark:focus,button.bg-dark:hover{background-color:#1d2124!important}.bg-white{background-color:#fff!important}.bg-transparent{background-color:transparent!important}.border{border:1px solid #dee2e6!important}.border-top{border-top:1px solid #dee2e6!important}.border-right{border-right:1px solid #dee2e6!important}.border-bottom{border-bottom:1px solid #dee2e6!important}.border-left{border-left:1px solid #dee2e6!important}.border-0{border:0!important}.border-top-0{border-top:0!important}.border-right-0{border-right:0!important}.border-bottom-0{border-bottom:0!important}.border-left-0{border-left:0!important}.border-primary{border-color:#007bff!important}.border-secondary{border-color:#6c757d!important}.border-success{border-color:#28a745!important}.border-info{border-color:#17a2b8!important}.border-warning{border-color:#ffc107!important}.border-danger{border-color:#dc3545!important}.border-light{border-color:#f8f9fa!important}.border-dark{border-color:#343a40!important}.border-white{border-color:#fff!important}.rounded-sm{border-radius:.2rem!important}.rounded{border-radius:.25rem!important}.rounded-top{border-top-left-radius:.25rem!important;border-top-right-radius:.25rem!important}.rounded-right{border-top-right-radius:.25rem!important;border-bottom-right-radius:.25rem!important}.rounded-bottom{border-bottom-right-radius:.25rem!important;border-bottom-left-radius:.25rem!important}.rounded-left{border-top-left-radius:.25rem!important;border-bottom-left-radius:.25rem!important}.rounded-lg{border-radius:.3rem!important}.rounded-circle{border-radius:50%!important}.rounded-pill{border-radius:50rem!important}.rounded-0{border-radius:0!important}.clearfix::after{display:block;clear:both;content:""}.d-none{display:none!important}.d-inline{display:inline!important}.d-inline-block{display:inline-block!important}.d-block{display:block!important}.d-table{display:table!important}.d-table-row{display:table-row!important}.d-table-cell{display:table-cell!important}.d-flex{display:-ms-flexbox!important;display:flex!important}.d-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}@media (min-width:576px){.d-sm-none{display:none!important}.d-sm-inline{display:inline!important}.d-sm-inline-block{display:inline-block!important}.d-sm-block{display:block!important}.d-sm-table{display:table!important}.d-sm-table-row{display:table-row!important}.d-sm-table-cell{display:table-cell!important}.d-sm-flex{display:-ms-flexbox!important;display:flex!important}.d-sm-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:768px){.d-md-none{display:none!important}.d-md-inline{display:inline!important}.d-md-inline-block{display:inline-block!important}.d-md-block{display:block!important}.d-md-table{display:table!important}.d-md-table-row{display:table-row!important}.d-md-table-cell{display:table-cell!important}.d-md-flex{display:-ms-flexbox!important;display:flex!important}.d-md-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:992px){.d-lg-none{display:none!important}.d-lg-inline{display:inline!important}.d-lg-inline-block{display:inline-block!important}.d-lg-block{display:block!important}.d-lg-table{display:table!important}.d-lg-table-row{display:table-row!important}.d-lg-table-cell{display:table-cell!important}.d-lg-flex{display:-ms-flexbox!important;display:flex!important}.d-lg-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:1200px){.d-xl-none{display:none!important}.d-xl-inline{display:inline!important}.d-xl-inline-block{display:inline-block!important}.d-xl-block{display:block!important}.d-xl-table{display:table!important}.d-xl-table-row{display:table-row!important}.d-xl-table-cell{display:table-cell!important}.d-xl-flex{display:-ms-flexbox!important;display:flex!important}.d-xl-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media print{.d-print-none{display:none!important}.d-print-inline{display:inline!important}.d-print-inline-block{display:inline-block!important}.d-print-block{display:block!important}.d-print-table{display:table!important}.d-print-table-row{display:table-row!important}.d-print-table-cell{display:table-cell!important}.d-print-flex{display:-ms-flexbox!important;display:flex!important}.d-print-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}.embed-responsive{position:relative;display:block;width:100%;padding:0;overflow:hidden}.embed-responsive::before{display:block;content:""}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-21by9::before{padding-top:42.857143%}.embed-responsive-16by9::before{padding-top:56.25%}.embed-responsive-4by3::before{padding-top:75%}.embed-responsive-1by1::before{padding-top:100%}.flex-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-center{-ms-flex-align:center!important;align-items:center!important}.align-items-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}@media (min-width:576px){.flex-sm-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-sm-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-sm-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-sm-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-sm-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-sm-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-sm-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-sm-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-sm-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-sm-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-sm-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-sm-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-sm-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-sm-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-sm-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-sm-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-sm-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-sm-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-sm-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-sm-center{-ms-flex-align:center!important;align-items:center!important}.align-items-sm-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-sm-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-sm-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-sm-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-sm-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-sm-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-sm-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-sm-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-sm-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-sm-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-sm-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-sm-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-sm-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-sm-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:768px){.flex-md-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-md-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-md-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-md-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-md-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-md-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-md-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-md-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-md-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-md-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-md-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-md-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-md-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-md-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-md-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-md-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-md-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-md-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-md-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-md-center{-ms-flex-align:center!important;align-items:center!important}.align-items-md-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-md-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-md-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-md-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-md-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-md-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-md-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-md-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-md-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-md-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-md-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-md-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-md-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-md-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:992px){.flex-lg-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-lg-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-lg-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-lg-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-lg-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-lg-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-lg-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-lg-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-lg-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-lg-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-lg-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-lg-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-lg-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-lg-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-lg-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-lg-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-lg-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-lg-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-lg-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-lg-center{-ms-flex-align:center!important;align-items:center!important}.align-items-lg-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-lg-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-lg-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-lg-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-lg-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-lg-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-lg-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-lg-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-lg-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-lg-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-lg-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-lg-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-lg-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-lg-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:1200px){.flex-xl-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-xl-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-xl-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-xl-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-xl-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-xl-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-xl-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-xl-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-xl-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-xl-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-xl-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-xl-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-xl-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-xl-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-xl-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-xl-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-xl-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-xl-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-xl-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-xl-center{-ms-flex-align:center!important;align-items:center!important}.align-items-xl-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-xl-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-xl-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-xl-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-xl-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-xl-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-xl-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-xl-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-xl-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-xl-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-xl-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-xl-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-xl-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-xl-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}.float-left{float:left!important}.float-right{float:right!important}.float-none{float:none!important}@media (min-width:576px){.float-sm-left{float:left!important}.float-sm-right{float:right!important}.float-sm-none{float:none!important}}@media (min-width:768px){.float-md-left{float:left!important}.float-md-right{float:right!important}.float-md-none{float:none!important}}@media (min-width:992px){.float-lg-left{float:left!important}.float-lg-right{float:right!important}.float-lg-none{float:none!important}}@media (min-width:1200px){.float-xl-left{float:left!important}.float-xl-right{float:right!important}.float-xl-none{float:none!important}}.overflow-auto{overflow:auto!important}.overflow-hidden{overflow:hidden!important}.position-static{position:static!important}.position-relative{position:relative!important}.position-absolute{position:absolute!important}.position-fixed{position:fixed!important}.position-sticky{position:-webkit-sticky!important;position:sticky!important}.fixed-top{position:fixed;top:0;right:0;left:0;z-index:1030}.fixed-bottom{position:fixed;right:0;bottom:0;left:0;z-index:1030}@supports ((position:-webkit-sticky) or (position:sticky)){.sticky-top{position:-webkit-sticky;position:sticky;top:0;z-index:1020}}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto;white-space:normal}.shadow-sm{box-shadow:0 .125rem .25rem rgba(0,0,0,.075)!important}.shadow{box-shadow:0 .5rem 1rem rgba(0,0,0,.15)!important}.shadow-lg{box-shadow:0 1rem 3rem rgba(0,0,0,.175)!important}.shadow-none{box-shadow:none!important}.w-25{width:25%!important}.w-50{width:50%!important}.w-75{width:75%!important}.w-100{width:100%!important}.w-auto{width:auto!important}.h-25{height:25%!important}.h-50{height:50%!important}.h-75{height:75%!important}.h-100{height:100%!important}.h-auto{height:auto!important}.mw-100{max-width:100%!important}.mh-100{max-height:100%!important}.min-vw-100{min-width:100vw!important}.min-vh-100{min-height:100vh!important}.vw-100{width:100vw!important}.vh-100{height:100vh!important}.stretched-link::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:1;pointer-events:auto;content:"";background-color:rgba(0,0,0,0)}.m-0{margin:0!important}.mt-0,.my-0{margin-top:0!important}.mr-0,.mx-0{margin-right:0!important}.mb-0,.my-0{margin-bottom:0!important}.ml-0,.mx-0{margin-left:0!important}.m-1{margin:.25rem!important}.mt-1,.my-1{margin-top:.25rem!important}.mr-1,.mx-1{margin-right:.25rem!important}.mb-1,.my-1{margin-bottom:.25rem!important}.ml-1,.mx-1{margin-left:.25rem!important}.m-2{margin:.5rem!important}.mt-2,.my-2{margin-top:.5rem!important}.mr-2,.mx-2{margin-right:.5rem!important}.mb-2,.my-2{margin-bottom:.5rem!important}.ml-2,.mx-2{margin-left:.5rem!important}.m-3{margin:1rem!important}.mt-3,.my-3{margin-top:1rem!important}.mr-3,.mx-3{margin-right:1rem!important}.mb-3,.my-3{margin-bottom:1rem!important}.ml-3,.mx-3{margin-left:1rem!important}.m-4{margin:1.5rem!important}.mt-4,.my-4{margin-top:1.5rem!important}.mr-4,.mx-4{margin-right:1.5rem!important}.mb-4,.my-4{margin-bottom:1.5rem!important}.ml-4,.mx-4{margin-left:1.5rem!important}.m-5{margin:3rem!important}.mt-5,.my-5{margin-top:3rem!important}.mr-5,.mx-5{margin-right:3rem!important}.mb-5,.my-5{margin-bottom:3rem!important}.ml-5,.mx-5{margin-left:3rem!important}.p-0{padding:0!important}.pt-0,.py-0{padding-top:0!important}.pr-0,.px-0{padding-right:0!important}.pb-0,.py-0{padding-bottom:0!important}.pl-0,.px-0{padding-left:0!important}.p-1{padding:.25rem!important}.pt-1,.py-1{padding-top:.25rem!important}.pr-1,.px-1{padding-right:.25rem!important}.pb-1,.py-1{padding-bottom:.25rem!important}.pl-1,.px-1{padding-left:.25rem!important}.p-2{padding:.5rem!important}.pt-2,.py-2{padding-top:.5rem!important}.pr-2,.px-2{padding-right:.5rem!important}.pb-2,.py-2{padding-bottom:.5rem!important}.pl-2,.px-2{padding-left:.5rem!important}.p-3{padding:1rem!important}.pt-3,.py-3{padding-top:1rem!important}.pr-3,.px-3{padding-right:1rem!important}.pb-3,.py-3{padding-bottom:1rem!important}.pl-3,.px-3{padding-left:1rem!important}.p-4{padding:1.5rem!important}.pt-4,.py-4{padding-top:1.5rem!important}.pr-4,.px-4{padding-right:1.5rem!important}.pb-4,.py-4{padding-bottom:1.5rem!important}.pl-4,.px-4{padding-left:1.5rem!important}.p-5{padding:3rem!important}.pt-5,.py-5{padding-top:3rem!important}.pr-5,.px-5{padding-right:3rem!important}.pb-5,.py-5{padding-bottom:3rem!important}.pl-5,.px-5{padding-left:3rem!important}.m-n1{margin:-.25rem!important}.mt-n1,.my-n1{margin-top:-.25rem!important}.mr-n1,.mx-n1{margin-right:-.25rem!important}.mb-n1,.my-n1{margin-bottom:-.25rem!important}.ml-n1,.mx-n1{margin-left:-.25rem!important}.m-n2{margin:-.5rem!important}.mt-n2,.my-n2{margin-top:-.5rem!important}.mr-n2,.mx-n2{margin-right:-.5rem!important}.mb-n2,.my-n2{margin-bottom:-.5rem!important}.ml-n2,.mx-n2{margin-left:-.5rem!important}.m-n3{margin:-1rem!important}.mt-n3,.my-n3{margin-top:-1rem!important}.mr-n3,.mx-n3{margin-right:-1rem!important}.mb-n3,.my-n3{margin-bottom:-1rem!important}.ml-n3,.mx-n3{margin-left:-1rem!important}.m-n4{margin:-1.5rem!important}.mt-n4,.my-n4{margin-top:-1.5rem!important}.mr-n4,.mx-n4{margin-right:-1.5rem!important}.mb-n4,.my-n4{margin-bottom:-1.5rem!important}.ml-n4,.mx-n4{margin-left:-1.5rem!important}.m-n5{margin:-3rem!important}.mt-n5,.my-n5{margin-top:-3rem!important}.mr-n5,.mx-n5{margin-right:-3rem!important}.mb-n5,.my-n5{margin-bottom:-3rem!important}.ml-n5,.mx-n5{margin-left:-3rem!important}.m-auto{margin:auto!important}.mt-auto,.my-auto{margin-top:auto!important}.mr-auto,.mx-auto{margin-right:auto!important}.mb-auto,.my-auto{margin-bottom:auto!important}.ml-auto,.mx-auto{margin-left:auto!important}@media (min-width:576px){.m-sm-0{margin:0!important}.mt-sm-0,.my-sm-0{margin-top:0!important}.mr-sm-0,.mx-sm-0{margin-right:0!important}.mb-sm-0,.my-sm-0{margin-bottom:0!important}.ml-sm-0,.mx-sm-0{margin-left:0!important}.m-sm-1{margin:.25rem!important}.mt-sm-1,.my-sm-1{margin-top:.25rem!important}.mr-sm-1,.mx-sm-1{margin-right:.25rem!important}.mb-sm-1,.my-sm-1{margin-bottom:.25rem!important}.ml-sm-1,.mx-sm-1{margin-left:.25rem!important}.m-sm-2{margin:.5rem!important}.mt-sm-2,.my-sm-2{margin-top:.5rem!important}.mr-sm-2,.mx-sm-2{margin-right:.5rem!important}.mb-sm-2,.my-sm-2{margin-bottom:.5rem!important}.ml-sm-2,.mx-sm-2{margin-left:.5rem!important}.m-sm-3{margin:1rem!important}.mt-sm-3,.my-sm-3{margin-top:1rem!important}.mr-sm-3,.mx-sm-3{margin-right:1rem!important}.mb-sm-3,.my-sm-3{margin-bottom:1rem!important}.ml-sm-3,.mx-sm-3{margin-left:1rem!important}.m-sm-4{margin:1.5rem!important}.mt-sm-4,.my-sm-4{margin-top:1.5rem!important}.mr-sm-4,.mx-sm-4{margin-right:1.5rem!important}.mb-sm-4,.my-sm-4{margin-bottom:1.5rem!important}.ml-sm-4,.mx-sm-4{margin-left:1.5rem!important}.m-sm-5{margin:3rem!important}.mt-sm-5,.my-sm-5{margin-top:3rem!important}.mr-sm-5,.mx-sm-5{margin-right:3rem!important}.mb-sm-5,.my-sm-5{margin-bottom:3rem!important}.ml-sm-5,.mx-sm-5{margin-left:3rem!important}.p-sm-0{padding:0!important}.pt-sm-0,.py-sm-0{padding-top:0!important}.pr-sm-0,.px-sm-0{padding-right:0!important}.pb-sm-0,.py-sm-0{padding-bottom:0!important}.pl-sm-0,.px-sm-0{padding-left:0!important}.p-sm-1{padding:.25rem!important}.pt-sm-1,.py-sm-1{padding-top:.25rem!important}.pr-sm-1,.px-sm-1{padding-right:.25rem!important}.pb-sm-1,.py-sm-1{padding-bottom:.25rem!important}.pl-sm-1,.px-sm-1{padding-left:.25rem!important}.p-sm-2{padding:.5rem!important}.pt-sm-2,.py-sm-2{padding-top:.5rem!important}.pr-sm-2,.px-sm-2{padding-right:.5rem!important}.pb-sm-2,.py-sm-2{padding-bottom:.5rem!important}.pl-sm-2,.px-sm-2{padding-left:.5rem!important}.p-sm-3{padding:1rem!important}.pt-sm-3,.py-sm-3{padding-top:1rem!important}.pr-sm-3,.px-sm-3{padding-right:1rem!important}.pb-sm-3,.py-sm-3{padding-bottom:1rem!important}.pl-sm-3,.px-sm-3{padding-left:1rem!important}.p-sm-4{padding:1.5rem!important}.pt-sm-4,.py-sm-4{padding-top:1.5rem!important}.pr-sm-4,.px-sm-4{padding-right:1.5rem!important}.pb-sm-4,.py-sm-4{padding-bottom:1.5rem!important}.pl-sm-4,.px-sm-4{padding-left:1.5rem!important}.p-sm-5{padding:3rem!important}.pt-sm-5,.py-sm-5{padding-top:3rem!important}.pr-sm-5,.px-sm-5{padding-right:3rem!important}.pb-sm-5,.py-sm-5{padding-bottom:3rem!important}.pl-sm-5,.px-sm-5{padding-left:3rem!important}.m-sm-n1{margin:-.25rem!important}.mt-sm-n1,.my-sm-n1{margin-top:-.25rem!important}.mr-sm-n1,.mx-sm-n1{margin-right:-.25rem!important}.mb-sm-n1,.my-sm-n1{margin-bottom:-.25rem!important}.ml-sm-n1,.mx-sm-n1{margin-left:-.25rem!important}.m-sm-n2{margin:-.5rem!important}.mt-sm-n2,.my-sm-n2{margin-top:-.5rem!important}.mr-sm-n2,.mx-sm-n2{margin-right:-.5rem!important}.mb-sm-n2,.my-sm-n2{margin-bottom:-.5rem!important}.ml-sm-n2,.mx-sm-n2{margin-left:-.5rem!important}.m-sm-n3{margin:-1rem!important}.mt-sm-n3,.my-sm-n3{margin-top:-1rem!important}.mr-sm-n3,.mx-sm-n3{margin-right:-1rem!important}.mb-sm-n3,.my-sm-n3{margin-bottom:-1rem!important}.ml-sm-n3,.mx-sm-n3{margin-left:-1rem!important}.m-sm-n4{margin:-1.5rem!important}.mt-sm-n4,.my-sm-n4{margin-top:-1.5rem!important}.mr-sm-n4,.mx-sm-n4{margin-right:-1.5rem!important}.mb-sm-n4,.my-sm-n4{margin-bottom:-1.5rem!important}.ml-sm-n4,.mx-sm-n4{margin-left:-1.5rem!important}.m-sm-n5{margin:-3rem!important}.mt-sm-n5,.my-sm-n5{margin-top:-3rem!important}.mr-sm-n5,.mx-sm-n5{margin-right:-3rem!important}.mb-sm-n5,.my-sm-n5{margin-bottom:-3rem!important}.ml-sm-n5,.mx-sm-n5{margin-left:-3rem!important}.m-sm-auto{margin:auto!important}.mt-sm-auto,.my-sm-auto{margin-top:auto!important}.mr-sm-auto,.mx-sm-auto{margin-right:auto!important}.mb-sm-auto,.my-sm-auto{margin-bottom:auto!important}.ml-sm-auto,.mx-sm-auto{margin-left:auto!important}}@media (min-width:768px){.m-md-0{margin:0!important}.mt-md-0,.my-md-0{margin-top:0!important}.mr-md-0,.mx-md-0{margin-right:0!important}.mb-md-0,.my-md-0{margin-bottom:0!important}.ml-md-0,.mx-md-0{margin-left:0!important}.m-md-1{margin:.25rem!important}.mt-md-1,.my-md-1{margin-top:.25rem!important}.mr-md-1,.mx-md-1{margin-right:.25rem!important}.mb-md-1,.my-md-1{margin-bottom:.25rem!important}.ml-md-1,.mx-md-1{margin-left:.25rem!important}.m-md-2{margin:.5rem!important}.mt-md-2,.my-md-2{margin-top:.5rem!important}.mr-md-2,.mx-md-2{margin-right:.5rem!important}.mb-md-2,.my-md-2{margin-bottom:.5rem!important}.ml-md-2,.mx-md-2{margin-left:.5rem!important}.m-md-3{margin:1rem!important}.mt-md-3,.my-md-3{margin-top:1rem!important}.mr-md-3,.mx-md-3{margin-right:1rem!important}.mb-md-3,.my-md-3{margin-bottom:1rem!important}.ml-md-3,.mx-md-3{margin-left:1rem!important}.m-md-4{margin:1.5rem!important}.mt-md-4,.my-md-4{margin-top:1.5rem!important}.mr-md-4,.mx-md-4{margin-right:1.5rem!important}.mb-md-4,.my-md-4{margin-bottom:1.5rem!important}.ml-md-4,.mx-md-4{margin-left:1.5rem!important}.m-md-5{margin:3rem!important}.mt-md-5,.my-md-5{margin-top:3rem!important}.mr-md-5,.mx-md-5{margin-right:3rem!important}.mb-md-5,.my-md-5{margin-bottom:3rem!important}.ml-md-5,.mx-md-5{margin-left:3rem!important}.p-md-0{padding:0!important}.pt-md-0,.py-md-0{padding-top:0!important}.pr-md-0,.px-md-0{padding-right:0!important}.pb-md-0,.py-md-0{padding-bottom:0!important}.pl-md-0,.px-md-0{padding-left:0!important}.p-md-1{padding:.25rem!important}.pt-md-1,.py-md-1{padding-top:.25rem!important}.pr-md-1,.px-md-1{padding-right:.25rem!important}.pb-md-1,.py-md-1{padding-bottom:.25rem!important}.pl-md-1,.px-md-1{padding-left:.25rem!important}.p-md-2{padding:.5rem!important}.pt-md-2,.py-md-2{padding-top:.5rem!important}.pr-md-2,.px-md-2{padding-right:.5rem!important}.pb-md-2,.py-md-2{padding-bottom:.5rem!important}.pl-md-2,.px-md-2{padding-left:.5rem!important}.p-md-3{padding:1rem!important}.pt-md-3,.py-md-3{padding-top:1rem!important}.pr-md-3,.px-md-3{padding-right:1rem!important}.pb-md-3,.py-md-3{padding-bottom:1rem!important}.pl-md-3,.px-md-3{padding-left:1rem!important}.p-md-4{padding:1.5rem!important}.pt-md-4,.py-md-4{padding-top:1.5rem!important}.pr-md-4,.px-md-4{padding-right:1.5rem!important}.pb-md-4,.py-md-4{padding-bottom:1.5rem!important}.pl-md-4,.px-md-4{padding-left:1.5rem!important}.p-md-5{padding:3rem!important}.pt-md-5,.py-md-5{padding-top:3rem!important}.pr-md-5,.px-md-5{padding-right:3rem!important}.pb-md-5,.py-md-5{padding-bottom:3rem!important}.pl-md-5,.px-md-5{padding-left:3rem!important}.m-md-n1{margin:-.25rem!important}.mt-md-n1,.my-md-n1{margin-top:-.25rem!important}.mr-md-n1,.mx-md-n1{margin-right:-.25rem!important}.mb-md-n1,.my-md-n1{margin-bottom:-.25rem!important}.ml-md-n1,.mx-md-n1{margin-left:-.25rem!important}.m-md-n2{margin:-.5rem!important}.mt-md-n2,.my-md-n2{margin-top:-.5rem!important}.mr-md-n2,.mx-md-n2{margin-right:-.5rem!important}.mb-md-n2,.my-md-n2{margin-bottom:-.5rem!important}.ml-md-n2,.mx-md-n2{margin-left:-.5rem!important}.m-md-n3{margin:-1rem!important}.mt-md-n3,.my-md-n3{margin-top:-1rem!important}.mr-md-n3,.mx-md-n3{margin-right:-1rem!important}.mb-md-n3,.my-md-n3{margin-bottom:-1rem!important}.ml-md-n3,.mx-md-n3{margin-left:-1rem!important}.m-md-n4{margin:-1.5rem!important}.mt-md-n4,.my-md-n4{margin-top:-1.5rem!important}.mr-md-n4,.mx-md-n4{margin-right:-1.5rem!important}.mb-md-n4,.my-md-n4{margin-bottom:-1.5rem!important}.ml-md-n4,.mx-md-n4{margin-left:-1.5rem!important}.m-md-n5{margin:-3rem!important}.mt-md-n5,.my-md-n5{margin-top:-3rem!important}.mr-md-n5,.mx-md-n5{margin-right:-3rem!important}.mb-md-n5,.my-md-n5{margin-bottom:-3rem!important}.ml-md-n5,.mx-md-n5{margin-left:-3rem!important}.m-md-auto{margin:auto!important}.mt-md-auto,.my-md-auto{margin-top:auto!important}.mr-md-auto,.mx-md-auto{margin-right:auto!important}.mb-md-auto,.my-md-auto{margin-bottom:auto!important}.ml-md-auto,.mx-md-auto{margin-left:auto!important}}@media (min-width:992px){.m-lg-0{margin:0!important}.mt-lg-0,.my-lg-0{margin-top:0!important}.mr-lg-0,.mx-lg-0{margin-right:0!important}.mb-lg-0,.my-lg-0{margin-bottom:0!important}.ml-lg-0,.mx-lg-0{margin-left:0!important}.m-lg-1{margin:.25rem!important}.mt-lg-1,.my-lg-1{margin-top:.25rem!important}.mr-lg-1,.mx-lg-1{margin-right:.25rem!important}.mb-lg-1,.my-lg-1{margin-bottom:.25rem!important}.ml-lg-1,.mx-lg-1{margin-left:.25rem!important}.m-lg-2{margin:.5rem!important}.mt-lg-2,.my-lg-2{margin-top:.5rem!important}.mr-lg-2,.mx-lg-2{margin-right:.5rem!important}.mb-lg-2,.my-lg-2{margin-bottom:.5rem!important}.ml-lg-2,.mx-lg-2{margin-left:.5rem!important}.m-lg-3{margin:1rem!important}.mt-lg-3,.my-lg-3{margin-top:1rem!important}.mr-lg-3,.mx-lg-3{margin-right:1rem!important}.mb-lg-3,.my-lg-3{margin-bottom:1rem!important}.ml-lg-3,.mx-lg-3{margin-left:1rem!important}.m-lg-4{margin:1.5rem!important}.mt-lg-4,.my-lg-4{margin-top:1.5rem!important}.mr-lg-4,.mx-lg-4{margin-right:1.5rem!important}.mb-lg-4,.my-lg-4{margin-bottom:1.5rem!important}.ml-lg-4,.mx-lg-4{margin-left:1.5rem!important}.m-lg-5{margin:3rem!important}.mt-lg-5,.my-lg-5{margin-top:3rem!important}.mr-lg-5,.mx-lg-5{margin-right:3rem!important}.mb-lg-5,.my-lg-5{margin-bottom:3rem!important}.ml-lg-5,.mx-lg-5{margin-left:3rem!important}.p-lg-0{padding:0!important}.pt-lg-0,.py-lg-0{padding-top:0!important}.pr-lg-0,.px-lg-0{padding-right:0!important}.pb-lg-0,.py-lg-0{padding-bottom:0!important}.pl-lg-0,.px-lg-0{padding-left:0!important}.p-lg-1{padding:.25rem!important}.pt-lg-1,.py-lg-1{padding-top:.25rem!important}.pr-lg-1,.px-lg-1{padding-right:.25rem!important}.pb-lg-1,.py-lg-1{padding-bottom:.25rem!important}.pl-lg-1,.px-lg-1{padding-left:.25rem!important}.p-lg-2{padding:.5rem!important}.pt-lg-2,.py-lg-2{padding-top:.5rem!important}.pr-lg-2,.px-lg-2{padding-right:.5rem!important}.pb-lg-2,.py-lg-2{padding-bottom:.5rem!important}.pl-lg-2,.px-lg-2{padding-left:.5rem!important}.p-lg-3{padding:1rem!important}.pt-lg-3,.py-lg-3{padding-top:1rem!important}.pr-lg-3,.px-lg-3{padding-right:1rem!important}.pb-lg-3,.py-lg-3{padding-bottom:1rem!important}.pl-lg-3,.px-lg-3{padding-left:1rem!important}.p-lg-4{padding:1.5rem!important}.pt-lg-4,.py-lg-4{padding-top:1.5rem!important}.pr-lg-4,.px-lg-4{padding-right:1.5rem!important}.pb-lg-4,.py-lg-4{padding-bottom:1.5rem!important}.pl-lg-4,.px-lg-4{padding-left:1.5rem!important}.p-lg-5{padding:3rem!important}.pt-lg-5,.py-lg-5{padding-top:3rem!important}.pr-lg-5,.px-lg-5{padding-right:3rem!important}.pb-lg-5,.py-lg-5{padding-bottom:3rem!important}.pl-lg-5,.px-lg-5{padding-left:3rem!important}.m-lg-n1{margin:-.25rem!important}.mt-lg-n1,.my-lg-n1{margin-top:-.25rem!important}.mr-lg-n1,.mx-lg-n1{margin-right:-.25rem!important}.mb-lg-n1,.my-lg-n1{margin-bottom:-.25rem!important}.ml-lg-n1,.mx-lg-n1{margin-left:-.25rem!important}.m-lg-n2{margin:-.5rem!important}.mt-lg-n2,.my-lg-n2{margin-top:-.5rem!important}.mr-lg-n2,.mx-lg-n2{margin-right:-.5rem!important}.mb-lg-n2,.my-lg-n2{margin-bottom:-.5rem!important}.ml-lg-n2,.mx-lg-n2{margin-left:-.5rem!important}.m-lg-n3{margin:-1rem!important}.mt-lg-n3,.my-lg-n3{margin-top:-1rem!important}.mr-lg-n3,.mx-lg-n3{margin-right:-1rem!important}.mb-lg-n3,.my-lg-n3{margin-bottom:-1rem!important}.ml-lg-n3,.mx-lg-n3{margin-left:-1rem!important}.m-lg-n4{margin:-1.5rem!important}.mt-lg-n4,.my-lg-n4{margin-top:-1.5rem!important}.mr-lg-n4,.mx-lg-n4{margin-right:-1.5rem!important}.mb-lg-n4,.my-lg-n4{margin-bottom:-1.5rem!important}.ml-lg-n4,.mx-lg-n4{margin-left:-1.5rem!important}.m-lg-n5{margin:-3rem!important}.mt-lg-n5,.my-lg-n5{margin-top:-3rem!important}.mr-lg-n5,.mx-lg-n5{margin-right:-3rem!important}.mb-lg-n5,.my-lg-n5{margin-bottom:-3rem!important}.ml-lg-n5,.mx-lg-n5{margin-left:-3rem!important}.m-lg-auto{margin:auto!important}.mt-lg-auto,.my-lg-auto{margin-top:auto!important}.mr-lg-auto,.mx-lg-auto{margin-right:auto!important}.mb-lg-auto,.my-lg-auto{margin-bottom:auto!important}.ml-lg-auto,.mx-lg-auto{margin-left:auto!important}}@media (min-width:1200px){.m-xl-0{margin:0!important}.mt-xl-0,.my-xl-0{margin-top:0!important}.mr-xl-0,.mx-xl-0{margin-right:0!important}.mb-xl-0,.my-xl-0{margin-bottom:0!important}.ml-xl-0,.mx-xl-0{margin-left:0!important}.m-xl-1{margin:.25rem!important}.mt-xl-1,.my-xl-1{margin-top:.25rem!important}.mr-xl-1,.mx-xl-1{margin-right:.25rem!important}.mb-xl-1,.my-xl-1{margin-bottom:.25rem!important}.ml-xl-1,.mx-xl-1{margin-left:.25rem!important}.m-xl-2{margin:.5rem!important}.mt-xl-2,.my-xl-2{margin-top:.5rem!important}.mr-xl-2,.mx-xl-2{margin-right:.5rem!important}.mb-xl-2,.my-xl-2{margin-bottom:.5rem!important}.ml-xl-2,.mx-xl-2{margin-left:.5rem!important}.m-xl-3{margin:1rem!important}.mt-xl-3,.my-xl-3{margin-top:1rem!important}.mr-xl-3,.mx-xl-3{margin-right:1rem!important}.mb-xl-3,.my-xl-3{margin-bottom:1rem!important}.ml-xl-3,.mx-xl-3{margin-left:1rem!important}.m-xl-4{margin:1.5rem!important}.mt-xl-4,.my-xl-4{margin-top:1.5rem!important}.mr-xl-4,.mx-xl-4{margin-right:1.5rem!important}.mb-xl-4,.my-xl-4{margin-bottom:1.5rem!important}.ml-xl-4,.mx-xl-4{margin-left:1.5rem!important}.m-xl-5{margin:3rem!important}.mt-xl-5,.my-xl-5{margin-top:3rem!important}.mr-xl-5,.mx-xl-5{margin-right:3rem!important}.mb-xl-5,.my-xl-5{margin-bottom:3rem!important}.ml-xl-5,.mx-xl-5{margin-left:3rem!important}.p-xl-0{padding:0!important}.pt-xl-0,.py-xl-0{padding-top:0!important}.pr-xl-0,.px-xl-0{padding-right:0!important}.pb-xl-0,.py-xl-0{padding-bottom:0!important}.pl-xl-0,.px-xl-0{padding-left:0!important}.p-xl-1{padding:.25rem!important}.pt-xl-1,.py-xl-1{padding-top:.25rem!important}.pr-xl-1,.px-xl-1{padding-right:.25rem!important}.pb-xl-1,.py-xl-1{padding-bottom:.25rem!important}.pl-xl-1,.px-xl-1{padding-left:.25rem!important}.p-xl-2{padding:.5rem!important}.pt-xl-2,.py-xl-2{padding-top:.5rem!important}.pr-xl-2,.px-xl-2{padding-right:.5rem!important}.pb-xl-2,.py-xl-2{padding-bottom:.5rem!important}.pl-xl-2,.px-xl-2{padding-left:.5rem!important}.p-xl-3{padding:1rem!important}.pt-xl-3,.py-xl-3{padding-top:1rem!important}.pr-xl-3,.px-xl-3{padding-right:1rem!important}.pb-xl-3,.py-xl-3{padding-bottom:1rem!important}.pl-xl-3,.px-xl-3{padding-left:1rem!important}.p-xl-4{padding:1.5rem!important}.pt-xl-4,.py-xl-4{padding-top:1.5rem!important}.pr-xl-4,.px-xl-4{padding-right:1.5rem!important}.pb-xl-4,.py-xl-4{padding-bottom:1.5rem!important}.pl-xl-4,.px-xl-4{padding-left:1.5rem!important}.p-xl-5{padding:3rem!important}.pt-xl-5,.py-xl-5{padding-top:3rem!important}.pr-xl-5,.px-xl-5{padding-right:3rem!important}.pb-xl-5,.py-xl-5{padding-bottom:3rem!important}.pl-xl-5,.px-xl-5{padding-left:3rem!important}.m-xl-n1{margin:-.25rem!important}.mt-xl-n1,.my-xl-n1{margin-top:-.25rem!important}.mr-xl-n1,.mx-xl-n1{margin-right:-.25rem!important}.mb-xl-n1,.my-xl-n1{margin-bottom:-.25rem!important}.ml-xl-n1,.mx-xl-n1{margin-left:-.25rem!important}.m-xl-n2{margin:-.5rem!important}.mt-xl-n2,.my-xl-n2{margin-top:-.5rem!important}.mr-xl-n2,.mx-xl-n2{margin-right:-.5rem!important}.mb-xl-n2,.my-xl-n2{margin-bottom:-.5rem!important}.ml-xl-n2,.mx-xl-n2{margin-left:-.5rem!important}.m-xl-n3{margin:-1rem!important}.mt-xl-n3,.my-xl-n3{margin-top:-1rem!important}.mr-xl-n3,.mx-xl-n3{margin-right:-1rem!important}.mb-xl-n3,.my-xl-n3{margin-bottom:-1rem!important}.ml-xl-n3,.mx-xl-n3{margin-left:-1rem!important}.m-xl-n4{margin:-1.5rem!important}.mt-xl-n4,.my-xl-n4{margin-top:-1.5rem!important}.mr-xl-n4,.mx-xl-n4{margin-right:-1.5rem!important}.mb-xl-n4,.my-xl-n4{margin-bottom:-1.5rem!important}.ml-xl-n4,.mx-xl-n4{margin-left:-1.5rem!important}.m-xl-n5{margin:-3rem!important}.mt-xl-n5,.my-xl-n5{margin-top:-3rem!important}.mr-xl-n5,.mx-xl-n5{margin-right:-3rem!important}.mb-xl-n5,.my-xl-n5{margin-bottom:-3rem!important}.ml-xl-n5,.mx-xl-n5{margin-left:-3rem!important}.m-xl-auto{margin:auto!important}.mt-xl-auto,.my-xl-auto{margin-top:auto!important}.mr-xl-auto,.mx-xl-auto{margin-right:auto!important}.mb-xl-auto,.my-xl-auto{margin-bottom:auto!important}.ml-xl-auto,.mx-xl-auto{margin-left:auto!important}}.text-monospace{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace!important}.text-justify{text-align:justify!important}.text-wrap{white-space:normal!important}.text-nowrap{white-space:nowrap!important}.text-truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.text-left{text-align:left!important}.text-right{text-align:right!important}.text-center{text-align:center!important}@media (min-width:576px){.text-sm-left{text-align:left!important}.text-sm-right{text-align:right!important}.text-sm-center{text-align:center!important}}@media (min-width:768px){.text-md-left{text-align:left!important}.text-md-right{text-align:right!important}.text-md-center{text-align:center!important}}@media (min-width:992px){.text-lg-left{text-align:left!important}.text-lg-right{text-align:right!important}.text-lg-center{text-align:center!important}}@media (min-width:1200px){.text-xl-left{text-align:left!important}.text-xl-right{text-align:right!important}.text-xl-center{text-align:center!important}}.text-lowercase{text-transform:lowercase!important}.text-uppercase{text-transform:uppercase!important}.text-capitalize{text-transform:capitalize!important}.font-weight-light{font-weight:300!important}.font-weight-lighter{font-weight:lighter!important}.font-weight-normal{font-weight:400!important}.font-weight-bold{font-weight:700!important}.font-weight-bolder{font-weight:bolder!important}.font-italic{font-style:italic!important}.text-white{color:#fff!important}.text-primary{color:#007bff!important}a.text-primary:focus,a.text-primary:hover{color:#0056b3!important}.text-secondary{color:#6c757d!important}a.text-secondary:focus,a.text-secondary:hover{color:#494f54!important}.text-success{color:#28a745!important}a.text-success:focus,a.text-success:hover{color:#19692c!important}.text-info{color:#17a2b8!important}a.text-info:focus,a.text-info:hover{color:#0f6674!important}.text-warning{color:#ffc107!important}a.text-warning:focus,a.text-warning:hover{color:#ba8b00!important}.text-danger{color:#dc3545!important}a.text-danger:focus,a.text-danger:hover{color:#a71d2a!important}.text-light{color:#f8f9fa!important}a.text-light:focus,a.text-light:hover{color:#cbd3da!important}.text-dark{color:#343a40!important}a.text-dark:focus,a.text-dark:hover{color:#121416!important}.text-body{color:#212529!important}.text-muted{color:#6c757d!important}.text-black-50{color:rgba(0,0,0,.5)!important}.text-white-50{color:rgba(255,255,255,.5)!important}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.text-decoration-none{text-decoration:none!important}.text-break{word-break:break-word!important;overflow-wrap:break-word!important}.text-reset{color:inherit!important}.visible{visibility:visible!important}.invisible{visibility:hidden!important}@media print{*,::after,::before{text-shadow:none!important;box-shadow:none!important}a:not(.btn){text-decoration:underline}abbr[title]::after{content:" (" attr(title) ")"}pre{white-space:pre-wrap!important}blockquote,pre{border:1px solid #adb5bd;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}@page{size:a3}body{min-width:992px!important}.container{min-width:992px!important}.navbar{display:none}.badge{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #dee2e6!important}.table-dark{color:inherit}.table-dark tbody+tbody,.table-dark td,.table-dark th,.table-dark thead th{border-color:#dee2e6}.table .thead-dark th{color:inherit;border-color:#dee2e6}}.menu{list-style:none;border-bottom:.1em solid #000;margin-bottom:2em;padding:0 0 .5em}.menu:before{content:"["}.menu:after{content:"]"}.menu>li{display:inline}.menu>li+li:before{content:"|";padding-right:.3em}.form-check-input{position:absolute;margin-top:.3rem;margin-left:-1rem}@font-face{font-family:edit;src:url('data:application/x-font-woff;base64, d09GRgABAAAAAAzIAA8AAAAAFigAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY+IEkwY21hcAAAAdgAAABQAAABfohD7KljdnQgAAACKAAAABMAAAAgBtX/BGZwZ20AAAI8AAAFkAAAC3CKkZBZZ2FzcAAAB8wAAAAIAAAACAAAABBnbHlmAAAH1AAAAlQAAAN0D5SRdGhlYWQAAAooAAAAMAAAADYXjR5XaGhlYQAAClgAAAAdAAAAJAc9A1VobXR4AAAKeAAAAAwAAAAMCuEAAGxvY2EAAAqEAAAACAAAAAgA9gG6bWF4cAAACowAAAAgAAAAIAESDApuYW1lAAAKrAAAAXMAAAKdiHrpI3Bvc3QAAAwgAAAAKwAAADx+ylO2cHJlcAAADEwAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZF7AOIGBlYGBqYppDwMDQw+EZnzAYMjIBBRlYGVmwAoC0lxTGBxeMLxgZA76n8UQxRzEMA0ozAiSAwDzGQvOAHic7ZCxDYAwDATPiaFAjEFBwTBU7F+yRfK2GYOX7qR/uTKwAF1cwsEejMit1XLvbLk7R9547K+NIRNW93STVv7s6fNrLf5U1OcK2gTMuAtdeJxjYEADEhDIHPQ/C4QBEmwD3QB4nK1WaXfTRhQdeUmchCwlCy1qYcTEabBGJmzBgAlBsmMgXZytlaCLFDvpvvGJ3+Bf82Tac+g3flrvGy8kkLTncJqTo3fnzdXM22USWpLYC+uRlJsvxdTWJo3sPAnphk3LUXwoO3shZYrJ3wVREK2W2rcdh0REIlC1rrBEEPseWZpkfOhRRsu2pFdNyi096S5b40G9Vd9+GjrKsTuhpGYzdGg9siVVGFWiSKY9UtKmZaj6K0krvL/CzFfNUMKITiJpvBnG0EjeG2e0ymg1tuMoimyy3ChSJJrhQRR5lNUS5+SKCQzKB82Q8sqnEeXD/Iis2KOcVrBLttP8vi95p3c5P7Ffb1G25EAfyI7s4Ox0JV+EW1th3LST7ShUEXbXd0Js2exU/2aP8ppGA7crMr3QjGCpfIUQKz+hzP4hWS2cT/mSR6NaspETQetlTuxLPoHW44gpcc0YWdDd0QkR1P2SMwz2mD4e/PHeKZYLEwJ4HMt6RyWcCBMpYXM0SdowcmAlZYsqqfWumDjldVrEW8J+7drRl85o41B3YjxbDx1bOVHJ8WhSp5lMndpJzaMpDaKUdCZ4zK8DKD+iSV5tYzWJlUfTOGbGhEQiAi3cS1NBLDuxpCkEzaMZvbkbprl2LVqkyQP13KP39OZWuLnTU9oO9LNGf1anYjrYC9PpaeQv8Wna5SJF6frpGX5M4kHWAjKRLTbDlIMHb/0O0svXlhyF1wbY7u3zK6h91kTwpAH7G9AeT9UpCUyFmFWIVkBirWtZlsnVrBapyNR3Q5pWvqzTBIpyHBfHvoxx/V8zM5aYEr7fidOzIy49c+1LCNMcfJt1PZrXqcVyAXFmeU6nWZbv6zTH8gOd5lme1+kIS1unoyw/1GmB5Uc6HWN5QQuadN/BkIsw5AIOkDCEpQNDWF6CISwVDGG5CENYFmEIyyUYwvJjGMJyGYawvKxl1dRTSePamVgGbEJgYo4eucxF5WoquVRCu2hUakOeEm6VVBTPqn9loF488oY5sBZIl8iaXzHOlY9G5fjWFS1vGjtXwLHqbx+O9jnxUtaLhT8F/9XWVCW9Ys3Dk6vwG4aebCeqNql4dE2Xz1U9uv5fVFRYC/QbSIVYKMqybHBnIoSPOp2GaqCVQ8xszDy063XLmp/D/TcxQhZQ/fg3FBoL3INOWUlZ7eCs1dfbstw7g3I4EyxJMTfz+lb4IiOz0n6RWcqej3wecAWMSmXYagOtFbzZJzEPmd4kzwRxW1E2SNrYzgSJDRzzgHnznQQmYeqqDeRO4YYN+AVhbsF5J1yieqMsh+5F7PMopPxbp+JE9qhojMCz2Rthr+9Cym9xDCQ0+aV+DFQVoakYNRXQNFJuqAZfxtm6bULGDvQjKnbDsqziw8cW95WSbRmEfKSI1aOjn9Zeok6q3H5mFJfvnb4FwSA1MX9733RxkMq7WskyR20DU7calVPXmkPjVYfq5lH1vePsEzlrmm66Jx56X9Oq28HFXCyw9m0O0lImF9T1YYUNosvFpVDqZTRJ77gHGBYY0O9Qio3/q/rYfJ4rVYXRcSTfTtS30edgDPwP2H9H9QPQ92Pocg0uz/eaE59u9OFsma6iF+un6Dcwa625WboG3NB0A+IhR62OuMoNfKcGcXqkuRzpIeBj3RXiAcAmgMXgE921jOZTAKP5jDk+wOfMYdBkDoMt5jDYZs4awA5zGOwyh8Eecxh8wZx1gC+ZwyBkDoOIOQyeMCcAeMocBl8xh8HXzGHwDXPuA3zLHAYxcxgkzGGwr+nWMMwtXtBdoLZBVaADU09Y3MPiUFNlyP6OF4b9vUHM/sEgpv6o6faQ+hMvDPVng5j6i0FM/VXTnSH1N14Y6u8GMfUPg5j6TL8Yy2UGv4x8lwoHlF1sPufvifcP28VAuQABAAH//wAPeJydUc1OE1EUPufO3J+ZKbRDZ6aaYpvSdibYpkI7ncYgZUr5M5BohEYaQ4UEYqIhPgcbSXwCutcE3LhSNz4AD+HOBW41YfCWYnRjMN7knpyf7zvn3u8ABbj4rnxRDGAQh7vQhBXkoR02ZxIKQQ6qjwhkuYUqLq0e6w83wyngiqpwdR9AlbU9UEAFRd0WMmAU2VOghNANoJRsAqFkLb16bEje5BWe4z8QUv81KJz+k6IC7l/L6Xa7oQOw0J69N12ZdDNpJymVYJZG7VKx4XG7ZqMbR+bMYZC0LZbPTbh10w8auWoqg7LguTLFuGk5qVw1mEVfAh0lhfk6cq8RVLPoWPgt7IR1tDXtszYmb6HXjqbavV4bT/MZTeFpoY/Eoqmij0EBT4s+LYgbjX500Ccva/1aopzoJD60Oq1sgK9/tYg+Ph82mO/hqJpk40JV/OJVjyUuOwg8PIoOjrDi9/14vJMoy3/BxYkyJncdhyzcgRlowzPYDXceLxImJnM3TQ0ZIFmmcvVSBIR9lRDgDPgLGAVNjGrb8REiYjphKFgPuGHwDeDc2ASDG2t7uzu9J931Rw/W7i+35qyC5Q5OPkFvldC0WAmH0s1g1UldEyfNnGllsJarNhFrnuvlGaf2AGMOd+CZ+QlXqi3RjSY2alUni9JgRhcFoV+aw9/uK50PXa6vRDEhCJ4SIaKDH2mVnjAVv+oiuFKvPsC98bSy8y51W/PeCh3fR58GSWwN7F/8aJeY52cxS9ctsteiiHRdTjw/qyzMV0jy8hFb9jhmrC39J9PqgkV4nGNgZGBgAOIaq8Wt8fw2Xxm4mV8ARRhuOb2NRtD/NzK/YOYGcjkYmECiAFMBC/F4nGNgZGBgDvqfBSRfMDD8/w8kgSIogBkAh8wFmAAAAAPoAAAD6AAAAxEAAAAAAAAA9gG6AAEAAAADAGgABgAAAAAAAgAgADAAcwAAAHULcAAAAAB4nHWPQUvDQBCF37a1VgseFL0Jc1EUIU0DHqyXQsV6rlDPsaZJSpotm22hV/+DB/+cf0Vf0m0RwSyT/ebNzMsEwDG+oLB5bhkbVmgw23AN+7hzXKfed9zgeXC8hzaeHDepPzs+xA1eHLdxgnc6qMYBsxk+HCu08O24hiO177iOljp13CCfO97Dmbpw3KR+7/gQYzVw3Mal+hzoxdqkcWLlanAtgR/48roWTSnNw0zCpU20KaQvU53bKMu0N9Hz6C21oyheZqEpsYxxZIpU59L1/DIdRnlkQlZKt2IVB9ZOZWr0XB6djyyMnkUT6yXWLnqdzm9/DKCxwBoGKWIksBBcUb3mHcCvQvDKDmHnpitFjhAZlRBLTiRVpWDeZ0yZ5VQjdmRkDxO+58zfOGkxIsWcyzhtdur2HpNKr7RyEXQ57++qQ1JedYRuZrtbgRVdA6qWG5RbmOqrgsc/+wj/t6zNqEyoe9VfW6o9dHj+2f8HXsx1xAB4nGNgYoAALgbsgJmRiZGZkYWBJTUls4S7pCixOEM3NbegpJKBAQBDxQZPAHicY/DewXAiKGIjI2Nf5AbGnRwMHAzJBRsZWJ02MTAyaIEYm7mYGDkgLD4GMIvNaRfTAaA0J5DN7rSLwQHCZmZw2ajC2BEYscGhI2Ijc4rLRjUQbxdHAwMji0NHckgESEkkEGzmYWLk0drB+L91A0vvRiYGFwAMdiP0AAA=') format('woff'),url('data:application/x-font-svg;base64, PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxtZXRhZGF0YT5Db3B5cmlnaHQgKEMpIDIwMjAgYnkgb3JpZ2luYWwgYXV0aG9ycyBAIGZvbnRlbGxvLmNvbTwvbWV0YWRhdGE+CjxkZWZzPgo8Zm9udCBpZD0iZWRpdCIgaG9yaXotYWR2LXg9IjEwMDAiID4KPGZvbnQtZmFjZSBmb250LWZhbWlseT0iZWRpdCIgZm9udC13ZWlnaHQ9IjQwMCIgZm9udC1zdHJldGNoPSJub3JtYWwiIHVuaXRzLXBlci1lbT0iMTAwMCIgYXNjZW50PSI4NTAiIGRlc2NlbnQ9Ii0xNTAiIC8+CjxtaXNzaW5nLWdseXBoIGhvcml6LWFkdi14PSIxMDAwIiAvPgo8Z2x5cGggZ2x5cGgtbmFtZT0iZWRpdCIgdW5pY29kZT0iJiN4ZTgwMDsiIGQ9Ik00OTYgMTg5bDY0IDY1LTg1IDg1LTY0LTY1di0zMWg1M3YtNTRoMzJ6IG0yNDUgNDAycS05IDktMTggMGwtMTk2LTE5NnEtOS05IDAtMTh0MTggMGwxOTYgMTk2cTkgOSAwIDE4eiBtNDUtMzMxdi0xMDZxMC02Ny00Ny0xMTR0LTExNC00N2gtNDY0cS02NyAwLTExNCA0N3QtNDcgMTE0djQ2NHEwIDY2IDQ3IDExM3QxMTQgNDhoNDY0cTM1IDAgNjUtMTQgOS00IDEwLTEzIDItMTAtNS0xNmwtMjctMjhxLTgtOC0xOC00LTEzIDMtMjUgM2gtNDY0cS0zNyAwLTYzLTI2dC0yNy02M3YtNDY0cTAtMzcgMjctNjN0NjMtMjdoNDY0cTM3IDAgNjMgMjd0MjYgNjN2NzBxMCA3IDUgMTJsMzYgMzZxOCA4IDIwIDR0MTEtMTZ6IG0tNTQgNDExbDE2MS0xNjAtMzc1LTM3NWgtMTYxdjE2MHogbTI0OC03M2wtNTEtNTItMTYxIDE2MSA1MSA1MnExNiAxNSAzOCAxNXQzOC0xNWw4NS04NXExNi0xNiAxNi0zOHQtMTYtMzh6IiBob3Jpei1hZHYteD0iMTAwMCIgLz4KCjxnbHlwaCBnbHlwaC1uYW1lPSJ0cmFzaC1lbXB0eSIgdW5pY29kZT0iJiN4ZTgwMTsiIGQ9Ik0yODYgNDM5di0zMjFxMC04LTUtMTN0LTEzLTVoLTM2cS04IDAtMTMgNXQtNSAxM3YzMjFxMCA4IDUgMTN0MTMgNWgzNnE4IDAgMTMtNXQ1LTEzeiBtMTQzIDB2LTMyMXEwLTgtNS0xM3QtMTMtNWgtMzZxLTggMC0xMyA1dC01IDEzdjMyMXEwIDggNSAxM3QxMyA1aDM2cTggMCAxMy01dDUtMTN6IG0xNDIgMHYtMzIxcTAtOC01LTEzdC0xMi01aC0zNnEtOCAwLTEzIDV0LTUgMTN2MzIxcTAgOCA1IDEzdDEzIDVoMzZxNyAwIDEyLTV0NS0xM3ogbTcyLTQwNHY1MjloLTUwMHYtNTI5cTAtMTIgNC0yMnQ4LTE1IDYtNWg0NjRxMiAwIDYgNXQ4IDE1IDQgMjJ6IG0tMzc1IDYwMWgyNTBsLTI3IDY1cS00IDUtOSA2aC0xNzdxLTYtMS0xMC02eiBtNTE4LTE4di0zNnEwLTgtNS0xM3QtMTMtNWgtNTR2LTUyOXEwLTQ2LTI2LTgwdC02My0zNGgtNDY0cS0zNyAwLTYzIDMzdC0yNyA3OXY1MzFoLTUzcS04IDAtMTMgNXQtNSAxM3YzNnEwIDggNSAxM3QxMyA1aDE3MmwzOSA5M3E5IDIxIDMxIDM1dDQ0IDE1aDE3OHEyMyAwIDQ0LTE1dDMwLTM1bDM5LTkzaDE3M3E4IDAgMTMtNXQ1LTEzeiIgaG9yaXotYWR2LXg9Ijc4NS43IiAvPgo8L2ZvbnQ+CjwvZGVmcz4KPC9zdmc+') format('svg');font-weight:400;font-style:normal}[class*=" icon-"]:before,[class^=icon-]:before{font-family:edit;font-style:normal;font-weight:400;speak:none;display:inline-block;text-decoration:inherit;width:1em;margin-right:.2em;text-align:center;font-variant:normal;text-transform:none;line-height:1em;margin-left:.2em;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon-edit:before{content:'\e800'}.icon-trash-empty:before{content:'\e801'}.scrollable{overflow:auto}</style>
</head>
<body>
  <p/>
  <div class="container">
  </div>

  <!--[if lt IE 7]>
      <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
  <![endif]-->

  <div ng-view></div>



  <!-- In production use:
  <script src="//ajax.googleapis.com/ajax/libs/angularjs/x.x.x/angular.min.js"></script>
  -->
  <script>(function(O, J) {
    "object" === typeof module && module.exports ? (J["default"] = J, module.exports = O.document ? J(O) : J) : "function" === typeof define && define.amd ? define("highcharts/highcharts", function() {
        return J(O);
    }) : (O.Highcharts && O.Highcharts.error(16, !0), O.Highcharts = J(O));
})("undefined" !== typeof window ? window : this, function(O) {
    function J(a, E, H, B) {
        a.hasOwnProperty(E) || (a[E] = B.apply(null, H));
    }
    var G = {};
    J(G, "parts/Globals.js", [], function() {
        var a = "undefined" === typeof O ? "undefined" !== typeof window ? window : {} : O, E = a.document, H = a.navigator && a.navigator.userAgent || "", B = E && E.createElementNS && !!E.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect, h = /(edge|msie|trident)/i.test(H) && !a.opera, e = -1 !== H.indexOf("Firefox"), q = -1 !== H.indexOf("Chrome"), t = e && 4 > parseInt(H.split("Firefox/")[1], 10);
        return {
            product: "Highcharts",
            version: "7.1.2",
            deg2rad: 2 * Math.PI / 360,
            doc: E,
            hasBidiBug: t,
            hasTouch: E && "undefined" !== typeof E.documentElement.ontouchstart,
            isMS: h,
            isWebKit: -1 !== H.indexOf("AppleWebKit"),
            isFirefox: e,
            isChrome: q,
            isSafari: !q && -1 !== H.indexOf("Safari"),
            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(H),
            SVG_NS: "http://www.w3.org/2000/svg",
            chartCount: 0,
            seriesTypes: {},
            symbolSizes: {},
            svg: B,
            win: a,
            marginNames: [ "plotTop", "marginRight", "marginBottom", "plotLeft" ],
            noop: function() {},
            charts: [],
            dateFormats: {}
        };
    });
    J(G, "parts/Utilities.js", [ G["parts/Globals.js"] ], function(a) {
        a.timers = [];
        var E = a.charts, H = a.doc, B = a.win;
        a.error = function(h, e, q) {
            var t = a.isNumber(h) ? "Highcharts error #" + h + ": www.highcharts.com/errors/" + h : h, u = function() {
                if (e) throw Error(t);
                B.console && console.log(t);
            };
            q ? a.fireEvent(q, "displayError", {
                code: h,
                message: t
            }, u) : u();
        };
        a.Fx = function(a, e, q) {
            this.options = e;
            this.elem = a;
            this.prop = q;
        };
        a.Fx.prototype = {
            dSetter: function() {
                var a = this.paths[0], e = this.paths[1], q = [], t = this.now, u = a.length, v;
                if (1 === t) q = this.toD; else if (u === e.length && 1 > t) for (;u--; ) v = parseFloat(a[u]), 
                q[u] = isNaN(v) ? e[u] : t * parseFloat(e[u] - v) + v; else q = e;
                this.elem.attr("d", q, null, !0);
            },
            update: function() {
                var a = this.elem, e = this.prop, q = this.now, t = this.options.step;
                if (this[e + "Setter"]) this[e + "Setter"](); else a.attr ? a.element && a.attr(e, q, null, !0) : a.style[e] = q + this.unit;
                t && t.call(a, q, this);
            },
            run: function(h, e, q) {
                var t = this, u = t.options, v = function(a) {
                    return v.stopped ? !1 : t.step(a);
                }, n = B.requestAnimationFrame || function(a) {
                    setTimeout(a, 13);
                }, g = function() {
                    for (var d = 0; d < a.timers.length; d++) a.timers[d]() || a.timers.splice(d--, 1);
                    a.timers.length && n(g);
                };
                h !== e || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), 
                this.start = h, this.end = e, this.unit = q, this.now = this.start, this.pos = 0, 
                v.elem = this.elem, v.prop = this.prop, v() && 1 === a.timers.push(v) && n(g)) : (delete u.curAnim[this.prop], 
                u.complete && 0 === Object.keys(u.curAnim).length && u.complete.call(this.elem));
            },
            step: function(h) {
                var e = +new Date(), q, t = this.options, u = this.elem, v = t.complete, n = t.duration, g = t.curAnim;
                u.attr && !u.element ? h = !1 : h || e >= n + this.startTime ? (this.now = this.end, 
                this.pos = 1, this.update(), q = g[this.prop] = !0, a.objectEach(g, function(a) {
                    !0 !== a && (q = !1);
                }), q && v && v.call(u), h = !1) : (this.pos = t.easing((e - this.startTime) / n), 
                this.now = this.start + (this.end - this.start) * this.pos, this.update(), h = !0);
                return h;
            },
            initPath: function(h, e, q) {
                function t(a) {
                    var b, l;
                    for (c = a.length; c--; ) b = "M" === a[c] || "L" === a[c], l = /[a-zA-Z]/.test(a[c + 3]), 
                    b && l && a.splice(c + 1, 0, a[c + 1], a[c + 2], a[c + 1], a[c + 2]);
                }
                function u(a, d) {
                    for (;a.length < k; ) {
                        a[0] = d[k - a.length];
                        var l = a.slice(0, b);
                        [].splice.apply(a, [ 0, 0 ].concat(l));
                        x && (l = a.slice(a.length - b), [].splice.apply(a, [ a.length, 0 ].concat(l)), 
                        c--);
                    }
                    a[0] = "M";
                }
                function v(a, c) {
                    for (var l = (k - a.length) / b; 0 < l && l--; ) p = a.slice().splice(a.length / K - b, b * K), 
                    p[0] = c[k - b - l * b], m && (p[b - 6] = p[b - 2], p[b - 5] = p[b - 1]), [].splice.apply(a, [ a.length / K, 0 ].concat(p)), 
                    x && l--;
                }
                e = e || "";
                var n, g = h.startX, d = h.endX, m = -1 < e.indexOf("C"), b = m ? 7 : 3, k, p, c;
                e = e.split(" ");
                q = q.slice();
                var x = h.isArea, K = x ? 2 : 1, w;
                m && (t(e), t(q));
                if (g && d) {
                    for (c = 0; c < g.length; c++) if (g[c] === d[0]) {
                        n = c;
                        break;
                    } else if (g[0] === d[d.length - g.length + c]) {
                        n = c;
                        w = !0;
                        break;
                    } else if (g[g.length - 1] === d[d.length - g.length + c]) {
                        n = g.length - c;
                        break;
                    }
                    "undefined" === typeof n && (e = []);
                }
                e.length && a.isNumber(n) && (k = q.length + n * K * b, w ? (u(e, q), v(q, e)) : (u(q, e), 
                v(e, q)));
                return [ e, q ];
            },
            fillSetter: function() {
                a.Fx.prototype.strokeSetter.apply(this, arguments);
            },
            strokeSetter: function() {
                this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);
            }
        };
        a.merge = function() {
            var h, e = arguments, q, t = {}, u = function(e, n) {
                "object" !== typeof e && (e = {});
                a.objectEach(n, function(g, d) {
                    !a.isObject(g, !0) || a.isClass(g) || a.isDOMElement(g) ? e[d] = n[d] : e[d] = u(e[d] || {}, g);
                });
                return e;
            };
            !0 === e[0] && (t = e[1], e = Array.prototype.slice.call(e, 2));
            q = e.length;
            for (h = 0; h < q; h++) t = u(t, e[h]);
            return t;
        };
        a.pInt = function(a, e) {
            return parseInt(a, e || 10);
        };
        a.isString = function(a) {
            return "string" === typeof a;
        };
        a.isArray = function(a) {
            a = Object.prototype.toString.call(a);
            return "[object Array]" === a || "[object Array Iterator]" === a;
        };
        a.isObject = function(h, e) {
            return !!h && "object" === typeof h && (!e || !a.isArray(h));
        };
        a.isDOMElement = function(h) {
            return a.isObject(h) && "number" === typeof h.nodeType;
        };
        a.isClass = function(h) {
            var e = h && h.constructor;
            return !(!a.isObject(h, !0) || a.isDOMElement(h) || !e || !e.name || "Object" === e.name);
        };
        a.isNumber = function(a) {
            return "number" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;
        };
        a.erase = function(a, e) {
            for (var h = a.length; h--; ) if (a[h] === e) {
                a.splice(h, 1);
                break;
            }
        };
        a.defined = function(a) {
            return "undefined" !== typeof a && null !== a;
        };
        a.attr = function(h, e, q) {
            var t;
            a.isString(e) ? a.defined(q) ? h.setAttribute(e, q) : h && h.getAttribute && ((t = h.getAttribute(e)) || "class" !== e || (t = h.getAttribute(e + "Name"))) : a.defined(e) && a.isObject(e) && a.objectEach(e, function(a, e) {
                h.setAttribute(e, a);
            });
            return t;
        };
        a.splat = function(h) {
            return a.isArray(h) ? h : [ h ];
        };
        a.syncTimeout = function(a, e, q) {
            if (e) return setTimeout(a, e, q);
            a.call(0, q);
        };
        a.clearTimeout = function(h) {
            a.defined(h) && clearTimeout(h);
        };
        a.extend = function(a, e) {
            var h;
            a || (a = {});
            for (h in e) a[h] = e[h];
            return a;
        };
        a.pick = function() {
            var a = arguments, e, q, t = a.length;
            for (e = 0; e < t; e++) if (q = a[e], "undefined" !== typeof q && null !== q) return q;
        };
        a.css = function(h, e) {
            a.isMS && !a.svg && e && "undefined" !== typeof e.opacity && (e.filter = "alpha(opacity=" + 100 * e.opacity + ")");
            a.extend(h.style, e);
        };
        a.createElement = function(h, e, q, t, u) {
            h = H.createElement(h);
            var v = a.css;
            e && a.extend(h, e);
            u && v(h, {
                padding: "0",
                border: "none",
                margin: "0"
            });
            q && v(h, q);
            t && t.appendChild(h);
            return h;
        };
        a.extendClass = function(h, e) {
            var q = function() {};
            q.prototype = new h();
            a.extend(q.prototype, e);
            return q;
        };
        a.pad = function(a, e, q) {
            return Array((e || 2) + 1 - String(a).replace("-", "").length).join(q || "0") + a;
        };
        a.relativeLength = function(a, e, q) {
            return /%$/.test(a) ? e * parseFloat(a) / 100 + (q || 0) : parseFloat(a);
        };
        a.wrap = function(a, e, q) {
            var h = a[e];
            a[e] = function() {
                var a = Array.prototype.slice.call(arguments), e = arguments, n = this;
                n.proceed = function() {
                    h.apply(n, arguments.length ? arguments : e);
                };
                a.unshift(h);
                a = q.apply(this, a);
                n.proceed = null;
                return a;
            };
        };
        a.datePropsToTimestamps = function(h) {
            a.objectEach(h, function(e, q) {
                a.isObject(e) && "function" === typeof e.getTime ? h[q] = e.getTime() : (a.isObject(e) || a.isArray(e)) && a.datePropsToTimestamps(e);
            });
        };
        a.formatSingle = function(h, e, q) {
            var t = /\.([0-9])/, u = a.defaultOptions.lang;
            /f$/.test(h) ? (q = (q = h.match(t)) ? q[1] : -1, null !== e && (e = a.numberFormat(e, q, u.decimalPoint, -1 < h.indexOf(",") ? u.thousandsSep : ""))) : e = (q || a.time).dateFormat(h, e);
            return e;
        };
        a.format = function(h, e, q) {
            for (var t = "{", u = !1, v, n, g, d, m = [], b; h; ) {
                t = h.indexOf(t);
                if (-1 === t) break;
                v = h.slice(0, t);
                if (u) {
                    v = v.split(":");
                    n = v.shift().split(".");
                    d = n.length;
                    b = e;
                    for (g = 0; g < d; g++) b && (b = b[n[g]]);
                    v.length && (b = a.formatSingle(v.join(":"), b, q));
                    m.push(b);
                } else m.push(v);
                h = h.slice(t + 1);
                t = (u = !u) ? "}" : "{";
            }
            m.push(h);
            return m.join("");
        };
        a.getMagnitude = function(a) {
            return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));
        };
        a.normalizeTickInterval = function(h, e, q, t, u) {
            var v, n = h;
            q = a.pick(q, 1);
            v = h / q;
            e || (e = u ? [ 1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10 ] : [ 1, 2, 2.5, 5, 10 ], 
            !1 === t && (1 === q ? e = e.filter(function(a) {
                return 0 === a % 1;
            }) : .1 >= q && (e = [ 1 / q ])));
            for (t = 0; t < e.length && !(n = e[t], u && n * q >= h || !u && v <= (e[t] + (e[t + 1] || e[t])) / 2); t++) ;
            return n = a.correctFloat(n * q, -Math.round(Math.log(.001) / Math.LN10));
        };
        a.stableSort = function(a, e) {
            var h = a.length, t, u;
            for (u = 0; u < h; u++) a[u].safeI = u;
            a.sort(function(a, n) {
                t = e(a, n);
                return 0 === t ? a.safeI - n.safeI : t;
            });
            for (u = 0; u < h; u++) delete a[u].safeI;
        };
        a.arrayMin = function(a) {
            for (var e = a.length, h = a[0]; e--; ) a[e] < h && (h = a[e]);
            return h;
        };
        a.arrayMax = function(a) {
            for (var e = a.length, h = a[0]; e--; ) a[e] > h && (h = a[e]);
            return h;
        };
        a.destroyObjectProperties = function(h, e) {
            a.objectEach(h, function(a, t) {
                a && a !== e && a.destroy && a.destroy();
                delete h[t];
            });
        };
        a.discardElement = function(h) {
            var e = a.garbageBin;
            e || (e = a.createElement("div"));
            h && e.appendChild(h);
            e.innerHTML = "";
        };
        a.correctFloat = function(a, e) {
            return parseFloat(a.toPrecision(e || 14));
        };
        a.setAnimation = function(h, e) {
            e.renderer.globalAnimation = a.pick(h, e.options.chart.animation, !0);
        };
        a.animObject = function(h) {
            return a.isObject(h) ? a.merge(h) : {
                duration: h ? 500 : 0
            };
        };
        a.timeUnits = {
            millisecond: 1,
            second: 1e3,
            minute: 6e4,
            hour: 36e5,
            day: 864e5,
            week: 6048e5,
            month: 24192e5,
            year: 314496e5
        };
        a.numberFormat = function(h, e, q, t) {
            h = +h || 0;
            e = +e;
            var u = a.defaultOptions.lang, v = (h.toString().split(".")[1] || "").split("e")[0].length, n, g, d = h.toString().split("e");
            -1 === e ? e = Math.min(v, 20) : a.isNumber(e) ? e && d[1] && 0 > d[1] && (n = e + +d[1], 
            0 <= n ? (d[0] = (+d[0]).toExponential(n).split("e")[0], e = n) : (d[0] = d[0].split(".")[0] || 0, 
            h = 20 > e ? (d[0] * Math.pow(10, d[1])).toFixed(e) : 0, d[1] = 0)) : e = 2;
            g = (Math.abs(d[1] ? d[0] : h) + Math.pow(10, -Math.max(e, v) - 1)).toFixed(e);
            v = String(a.pInt(g));
            n = 3 < v.length ? v.length % 3 : 0;
            q = a.pick(q, u.decimalPoint);
            t = a.pick(t, u.thousandsSep);
            h = (0 > h ? "-" : "") + (n ? v.substr(0, n) + t : "");
            h += v.substr(n).replace(/(\d{3})(?=\d)/g, "$1" + t);
            e && (h += q + g.slice(-e));
            d[1] && 0 !== +h && (h += "e" + d[1]);
            return h;
        };
        Math.easeInOutSine = function(a) {
            return -.5 * (Math.cos(Math.PI * a) - 1);
        };
        a.getStyle = function(h, e, q) {
            if ("width" === e) return Math.max(0, Math.min(h.offsetWidth, h.scrollWidth, h.getBoundingClientRect && "none" === a.getStyle(h, "transform", !1) ? Math.floor(h.getBoundingClientRect().width) : Infinity) - a.getStyle(h, "padding-left") - a.getStyle(h, "padding-right"));
            if ("height" === e) return Math.max(0, Math.min(h.offsetHeight, h.scrollHeight) - a.getStyle(h, "padding-top") - a.getStyle(h, "padding-bottom"));
            B.getComputedStyle || a.error(27, !0);
            if (h = B.getComputedStyle(h, void 0)) h = h.getPropertyValue(e), a.pick(q, "opacity" !== e) && (h = a.pInt(h));
            return h;
        };
        a.inArray = function(a, e, q) {
            return e.indexOf(a, q);
        };
        a.find = Array.prototype.find ? function(a, e) {
            return a.find(e);
        } : function(a, e) {
            var h, t = a.length;
            for (h = 0; h < t; h++) if (e(a[h], h)) return a[h];
        };
        a.keys = Object.keys;
        a.offset = function(a) {
            var e = H.documentElement;
            a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {
                top: 0,
                left: 0
            };
            return {
                top: a.top + (B.pageYOffset || e.scrollTop) - (e.clientTop || 0),
                left: a.left + (B.pageXOffset || e.scrollLeft) - (e.clientLeft || 0)
            };
        };
        a.stop = function(h, e) {
            for (var q = a.timers.length; q--; ) a.timers[q].elem !== h || e && e !== a.timers[q].prop || (a.timers[q].stopped = !0);
        };
        a.objectEach = function(a, e, q) {
            for (var h in a) a.hasOwnProperty(h) && e.call(q || a[h], a[h], h, a);
        };
        a.objectEach({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
        }, function(h, e) {
            a[e] = function(a) {
                return Array.prototype[h].apply(a, [].slice.call(arguments, 1));
            };
        });
        a.addEvent = function(h, e, q, t) {
            void 0 === t && (t = {});
            var u, v = h.addEventListener || a.addEventListenerPolyfill;
            u = "function" === typeof h && h.prototype ? h.prototype.protoEvents = h.prototype.protoEvents || {} : h.hcEvents = h.hcEvents || {};
            a.Point && h instanceof a.Point && h.series && h.series.chart && (h.series.chart.runTrackerClick = !0);
            v && v.call(h, e, q, !1);
            u[e] || (u[e] = []);
            u[e].push({
                fn: q,
                order: "number" === typeof t.order ? t.order : Infinity
            });
            u[e].sort(function(a, g) {
                return a.order - g.order;
            });
            return function() {
                a.removeEvent(h, e, q);
            };
        };
        a.removeEvent = function(h, e, q) {
            function t(n, g) {
                var d = h.removeEventListener || a.removeEventListenerPolyfill;
                d && d.call(h, n, g, !1);
            }
            function u(n) {
                var g, d;
                h.nodeName && (e ? (g = {}, g[e] = !0) : g = n, a.objectEach(g, function(a, b) {
                    if (n[b]) for (d = n[b].length; d--; ) t(b, n[b][d].fn);
                }));
            }
            var v;
            [ "protoEvents", "hcEvents" ].forEach(function(a) {
                var g = h[a];
                g && (e ? (v = g[e] || [], q ? (g[e] = v.filter(function(a) {
                    return q !== a.fn;
                }), t(e, q)) : (u(g), g[e] = [])) : (u(g), h[a] = {}));
            });
        };
        a.fireEvent = function(h, e, q, t) {
            var u, v;
            q = q || {};
            H.createEvent && (h.dispatchEvent || h.fireEvent) ? (u = H.createEvent("Events"), 
            u.initEvent(e, !0, !0), a.extend(u, q), h.dispatchEvent ? h.dispatchEvent(u) : h.fireEvent(e, u)) : (q.target || a.extend(q, {
                preventDefault: function() {
                    q.defaultPrevented = !0;
                },
                target: h,
                type: e
            }), function(a, g) {
                void 0 === a && (a = []);
                void 0 === g && (g = []);
                var d = 0, m = 0, b = a.length + g.length;
                for (v = 0; v < b; v++) !1 === (a[d] ? g[m] ? a[d].order <= g[m].order ? a[d++] : g[m++] : a[d++] : g[m++]).fn.call(h, q) && q.preventDefault();
            }(h.protoEvents && h.protoEvents[e], h.hcEvents && h.hcEvents[e]));
            t && !q.defaultPrevented && t.call(h, q);
        };
        a.animate = function(h, e, q) {
            var t, u = "", v, n, g;
            a.isObject(q) || (g = arguments, q = {
                duration: g[2],
                easing: g[3],
                complete: g[4]
            });
            a.isNumber(q.duration) || (q.duration = 400);
            q.easing = "function" === typeof q.easing ? q.easing : Math[q.easing] || Math.easeInOutSine;
            q.curAnim = a.merge(e);
            a.objectEach(e, function(d, g) {
                a.stop(h, g);
                n = new a.Fx(h, q, g);
                v = null;
                "d" === g ? (n.paths = n.initPath(h, h.d, e.d), n.toD = e.d, t = 0, v = 1) : h.attr ? t = h.attr(g) : (t = parseFloat(a.getStyle(h, g)) || 0, 
                "opacity" !== g && (u = "px"));
                v || (v = d);
                v && v.match && v.match("px") && (v = v.replace(/px/g, ""));
                n.run(t, v, u);
            });
        };
        a.seriesType = function(h, e, q, t, u) {
            var v = a.getOptions(), n = a.seriesTypes;
            v.plotOptions[h] = a.merge(v.plotOptions[e], q);
            n[h] = a.extendClass(n[e] || function() {}, t);
            n[h].prototype.type = h;
            u && (n[h].prototype.pointClass = a.extendClass(a.Point, u));
            return n[h];
        };
        a.uniqueKey = function() {
            var a = Math.random().toString(36).substring(2, 9), e = 0;
            return function() {
                return "highcharts-" + a + "-" + e++;
            };
        }();
        a.isFunction = function(a) {
            return "function" === typeof a;
        };
        B.jQuery && (B.jQuery.fn.highcharts = function() {
            var h = [].slice.call(arguments);
            if (this[0]) return h[0] ? (new (a[a.isString(h[0]) ? h.shift() : "Chart"])(this[0], h[0], h[1]), 
            this) : E[a.attr(this[0], "data-highcharts-chart")];
        });
    });
    J(G, "parts/Color.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.isNumber, H = a.merge, B = a.pInt;
        a.Color = function(h) {
            if (!(this instanceof a.Color)) return new a.Color(h);
            this.init(h);
        };
        a.Color.prototype = {
            parsers: [ {
                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function(a) {
                    return [ B(a[1]), B(a[2]), B(a[3]), parseFloat(a[4], 10) ];
                }
            }, {
                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function(a) {
                    return [ B(a[1]), B(a[2]), B(a[3]), 1 ];
                }
            } ],
            names: {
                white: "#ffffff",
                black: "#000000"
            },
            init: function(h) {
                var e, q, t, u;
                if ((this.input = h = this.names[h && h.toLowerCase ? h.toLowerCase() : ""] || h) && h.stops) this.stops = h.stops.map(function(e) {
                    return new a.Color(e[1]);
                }); else if (h && h.charAt && "#" === h.charAt() && (e = h.length, h = parseInt(h.substr(1), 16), 
                7 === e ? q = [ (h & 16711680) >> 16, (h & 65280) >> 8, h & 255, 1 ] : 4 === e && (q = [ (h & 3840) >> 4 | (h & 3840) >> 8, (h & 240) >> 4 | h & 240, (h & 15) << 4 | h & 15, 1 ])), 
                !q) for (t = this.parsers.length; t-- && !q; ) u = this.parsers[t], (e = u.regex.exec(h)) && (q = u.parse(e));
                this.rgba = q || [];
            },
            get: function(a) {
                var e = this.input, h = this.rgba, t;
                this.stops ? (t = H(e), t.stops = [].concat(t.stops), this.stops.forEach(function(e, h) {
                    t.stops[h] = [ t.stops[h][0], e.get(a) ];
                })) : t = h && E(h[0]) ? "rgb" === a || !a && 1 === h[3] ? "rgb(" + h[0] + "," + h[1] + "," + h[2] + ")" : "a" === a ? h[3] : "rgba(" + h.join(",") + ")" : e;
                return t;
            },
            brighten: function(a) {
                var e, h = this.rgba;
                if (this.stops) this.stops.forEach(function(e) {
                    e.brighten(a);
                }); else if (E(a) && 0 !== a) for (e = 0; 3 > e; e++) h[e] += B(255 * a), 0 > h[e] && (h[e] = 0), 
                255 < h[e] && (h[e] = 255);
                return this;
            },
            setOpacity: function(a) {
                this.rgba[3] = a;
                return this;
            },
            tweenTo: function(a, e) {
                var h = this.rgba, t = a.rgba;
                t.length && h && h.length ? (a = 1 !== t[3] || 1 !== h[3], e = (a ? "rgba(" : "rgb(") + Math.round(t[0] + (h[0] - t[0]) * (1 - e)) + "," + Math.round(t[1] + (h[1] - t[1]) * (1 - e)) + "," + Math.round(t[2] + (h[2] - t[2]) * (1 - e)) + (a ? "," + (t[3] + (h[3] - t[3]) * (1 - e)) : "") + ")") : e = a.input || "none";
                return e;
            }
        };
        a.color = function(h) {
            return new a.Color(h);
        };
    });
    J(G, "parts/SvgRenderer.js", [ G["parts/Globals.js"] ], function(a) {
        var E, H, B = a.addEvent, h = a.animate, e = a.attr, q = a.charts, t = a.color, u = a.css, v = a.createElement, n = a.defined, g = a.deg2rad, d = a.destroyObjectProperties, m = a.doc, b = a.extend, k = a.erase, p = a.hasTouch, c = a.isArray, x = a.isFirefox, K = a.isMS, w = a.isObject, F = a.isString, C = a.isWebKit, l = a.merge, D = a.noop, A = a.objectEach, z = a.pick, I = a.pInt, f = a.removeEvent, r = a.splat, Q = a.stop, N = a.svg, L = a.SVG_NS, M = a.symbolSizes, R = a.win;
        E = a.SVGElement = function() {
            return this;
        };
        b(E.prototype, {
            opacity: 1,
            SVG_NS: L,
            textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
            init: function(y, f) {
                this.element = "span" === f ? v(f) : m.createElementNS(this.SVG_NS, f);
                this.renderer = y;
                a.fireEvent(this, "afterInit");
            },
            animate: function(y, f, b) {
                var c = a.animObject(z(f, this.renderer.globalAnimation, !0));
                z(m.hidden, m.msHidden, m.webkitHidden, !1) && (c.duration = 0);
                0 !== c.duration ? (b && (c.complete = b), h(this, y, c)) : (this.attr(y, void 0, b), 
                a.objectEach(y, function(a, y) {
                    c.step && c.step.call(this, a, {
                        prop: y,
                        pos: 1
                    });
                }, this));
                return this;
            },
            complexColor: function(y, f, b) {
                var r = this.renderer, d, p, k, g, S, L, m, x, e, D, w, z = [], N;
                a.fireEvent(this.renderer, "complexColor", {
                    args: arguments
                }, function() {
                    y.radialGradient ? p = "radialGradient" : y.linearGradient && (p = "linearGradient");
                    p && (k = y[p], S = r.gradients, m = y.stops, D = b.radialReference, c(k) && (y[p] = k = {
                        x1: k[0],
                        y1: k[1],
                        x2: k[2],
                        y2: k[3],
                        gradientUnits: "userSpaceOnUse"
                    }), "radialGradient" === p && D && !n(k.gradientUnits) && (g = k, k = l(k, r.getRadialAttr(D, g), {
                        gradientUnits: "userSpaceOnUse"
                    })), A(k, function(a, y) {
                        "id" !== y && z.push(y, a);
                    }), A(m, function(a) {
                        z.push(a);
                    }), z = z.join(","), S[z] ? w = S[z].attr("id") : (k.id = w = a.uniqueKey(), S[z] = L = r.createElement(p).attr(k).add(r.defs), 
                    L.radAttr = g, L.stops = [], m.forEach(function(y) {
                        0 === y[1].indexOf("rgba") ? (d = a.color(y[1]), x = d.get("rgb"), e = d.get("a")) : (x = y[1], 
                        e = 1);
                        y = r.createElement("stop").attr({
                            offset: y[0],
                            "stop-color": x,
                            "stop-opacity": e
                        }).add(L);
                        L.stops.push(y);
                    })), N = "url(" + r.url + "#" + w + ")", b.setAttribute(f, N), b.gradient = z, y.toString = function() {
                        return N;
                    });
                });
            },
            applyTextOutline: function(y) {
                var f = this.element, b, c, r;
                -1 !== y.indexOf("contrast") && (y = y.replace(/contrast/g, this.renderer.getContrast(f.style.fill)));
                y = y.split(" ");
                b = y[y.length - 1];
                (c = y[0]) && "none" !== c && a.svg && (this.fakeTS = !0, y = [].slice.call(f.getElementsByTagName("tspan")), 
                this.ySetter = this.xSetter, c = c.replace(/(^[\d\.]+)(.*?)$/g, function(a, y, f) {
                    return 2 * y + f;
                }), this.removeTextOutline(y), r = f.firstChild, y.forEach(function(a, y) {
                    0 === y && (a.setAttribute("x", f.getAttribute("x")), y = f.getAttribute("y"), a.setAttribute("y", y || 0), 
                    null === y && f.setAttribute("y", 0));
                    a = a.cloneNode(1);
                    e(a, {
                        class: "highcharts-text-outline",
                        fill: b,
                        stroke: b,
                        "stroke-width": c,
                        "stroke-linejoin": "round"
                    });
                    f.insertBefore(a, r);
                }));
            },
            removeTextOutline: function(a) {
                for (var y = a.length, f; y--; ) f = a[y], "highcharts-text-outline" === f.getAttribute("class") && k(a, this.element.removeChild(f));
            },
            symbolCustomAttribs: "x y width height r start end innerR anchorX anchorY rounded".split(" "),
            attr: function(y, f, b, c) {
                var r, k = this.element, l, p = this, d, g, L = this.symbolCustomAttribs;
                "string" === typeof y && void 0 !== f && (r = y, y = {}, y[r] = f);
                "string" === typeof y ? p = (this[y + "Getter"] || this._defaultGetter).call(this, y, k) : (A(y, function(f, b) {
                    d = !1;
                    c || Q(this, b);
                    this.symbolName && -1 !== a.inArray(b, L) && (l || (this.symbolAttr(y), l = !0), 
                    d = !0);
                    !this.rotation || "x" !== b && "y" !== b || (this.doTransform = !0);
                    d || (g = this[b + "Setter"] || this._defaultSetter, g.call(this, f, b, k), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(b) && this.updateShadows(b, f, g));
                }, this), this.afterSetters());
                b && b.call(this);
                return p;
            },
            afterSetters: function() {
                this.doTransform && (this.updateTransform(), this.doTransform = !1);
            },
            updateShadows: function(a, f, b) {
                for (var y = this.shadows, c = y.length; c--; ) b.call(y[c], "height" === a ? Math.max(f - (y[c].cutHeight || 0), 0) : "d" === a ? this.d : f, a, y[c]);
            },
            addClass: function(a, f) {
                var y = this.attr("class") || "";
                f || (a = (a || "").split(/ /g).reduce(function(a, f) {
                    -1 === y.indexOf(f) && a.push(f);
                    return a;
                }, y ? [ y ] : []).join(" "));
                a !== y && this.attr("class", a);
                return this;
            },
            hasClass: function(a) {
                return -1 !== (this.attr("class") || "").split(" ").indexOf(a);
            },
            removeClass: function(a) {
                return this.attr("class", (this.attr("class") || "").replace(a, ""));
            },
            symbolAttr: function(a) {
                var y = this;
                "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function(f) {
                    y[f] = z(a[f], y[f]);
                });
                y.attr({
                    d: y.renderer.symbols[y.symbolName](y.x, y.y, y.width, y.height, y)
                });
            },
            clip: function(a) {
                return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
            },
            crisp: function(a, f) {
                var y;
                f = f || a.strokeWidth || 0;
                y = Math.round(f) % 2 / 2;
                a.x = Math.floor(a.x || this.x || 0) + y;
                a.y = Math.floor(a.y || this.y || 0) + y;
                a.width = Math.floor((a.width || this.width || 0) - 2 * y);
                a.height = Math.floor((a.height || this.height || 0) - 2 * y);
                n(a.strokeWidth) && (a.strokeWidth = f);
                return a;
            },
            css: function(a) {
                var y = this.styles, f = {}, c = this.element, r, k = "", l, p = !y, d = [ "textOutline", "textOverflow", "width" ];
                a && a.color && (a.fill = a.color);
                y && A(a, function(a, b) {
                    a !== y[b] && (f[b] = a, p = !0);
                });
                p && (y && (a = b(y, f)), a && (null === a.width || "auto" === a.width ? delete this.textWidth : "text" === c.nodeName.toLowerCase() && a.width && (r = this.textWidth = I(a.width))), 
                this.styles = a, r && !N && this.renderer.forExport && delete a.width, c.namespaceURI === this.SVG_NS ? (l = function(a, y) {
                    return "-" + y.toLowerCase();
                }, A(a, function(a, y) {
                    -1 === d.indexOf(y) && (k += y.replace(/([A-Z])/g, l) + ":" + a + ";");
                }), k && e(c, "style", k)) : u(c, a), this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), 
                a && a.textOutline && this.applyTextOutline(a.textOutline)));
                return this;
            },
            getStyle: function(a) {
                return R.getComputedStyle(this.element || this, "").getPropertyValue(a);
            },
            strokeWidth: function() {
                if (!this.renderer.styledMode) return this["stroke-width"] || 0;
                var a = this.getStyle("stroke-width"), f;
                a.indexOf("px") === a.length - 2 ? a = I(a) : (f = m.createElementNS(L, "rect"), 
                e(f, {
                    width: a,
                    "stroke-width": 0
                }), this.element.parentNode.appendChild(f), a = f.getBBox().width, f.parentNode.removeChild(f));
                return a;
            },
            on: function(a, f) {
                var y = this, b = y.element;
                p && "click" === a ? (b.ontouchstart = function(a) {
                    y.touchEventFired = Date.now();
                    a.preventDefault();
                    f.call(b, a);
                }, b.onclick = function(a) {
                    (-1 === R.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (y.touchEventFired || 0)) && f.call(b, a);
                }) : b["on" + a] = f;
                return this;
            },
            setRadialReference: function(a) {
                var y = this.renderer.gradients[this.element.gradient];
                this.element.radialReference = a;
                y && y.radAttr && y.animate(this.renderer.getRadialAttr(a, y.radAttr));
                return this;
            },
            translate: function(a, f) {
                return this.attr({
                    translateX: a,
                    translateY: f
                });
            },
            invert: function(a) {
                this.inverted = a;
                this.updateTransform();
                return this;
            },
            updateTransform: function() {
                var a = this.translateX || 0, f = this.translateY || 0, b = this.scaleX, c = this.scaleY, r = this.inverted, k = this.rotation, l = this.matrix, p = this.element;
                r && (a += this.width, f += this.height);
                a = [ "translate(" + a + "," + f + ")" ];
                n(l) && a.push("matrix(" + l.join(",") + ")");
                r ? a.push("rotate(90) scale(-1,1)") : k && a.push("rotate(" + k + " " + z(this.rotationOriginX, p.getAttribute("x"), 0) + " " + z(this.rotationOriginY, p.getAttribute("y") || 0) + ")");
                (n(b) || n(c)) && a.push("scale(" + z(b, 1) + " " + z(c, 1) + ")");
                a.length && p.setAttribute("transform", a.join(" "));
            },
            toFront: function() {
                var a = this.element;
                a.parentNode.appendChild(a);
                return this;
            },
            align: function(a, f, b) {
                var y, c, r, p, l = {};
                c = this.renderer;
                r = c.alignedObjects;
                var d, g;
                if (a) {
                    if (this.alignOptions = a, this.alignByTranslate = f, !b || F(b)) this.alignTo = y = b || "renderer", 
                    k(r, this), r.push(this), b = null;
                } else a = this.alignOptions, f = this.alignByTranslate, y = this.alignTo;
                b = z(b, c[y], c);
                y = a.align;
                c = a.verticalAlign;
                r = (b.x || 0) + (a.x || 0);
                p = (b.y || 0) + (a.y || 0);
                "right" === y ? d = 1 : "center" === y && (d = 2);
                d && (r += (b.width - (a.width || 0)) / d);
                l[f ? "translateX" : "x"] = Math.round(r);
                "bottom" === c ? g = 1 : "middle" === c && (g = 2);
                g && (p += (b.height - (a.height || 0)) / g);
                l[f ? "translateY" : "y"] = Math.round(p);
                this[this.placed ? "animate" : "attr"](l);
                this.placed = !0;
                this.alignAttr = l;
                return this;
            },
            getBBox: function(a, f) {
                var y, c = this.renderer, r, k = this.element, l = this.styles, p, d = this.textStr, A, L = c.cache, m = c.cacheKeys, x = k.namespaceURI === this.SVG_NS, e;
                f = z(f, this.rotation);
                r = f * g;
                p = c.styledMode ? k && E.prototype.getStyle.call(k, "font-size") : l && l.fontSize;
                n(d) && (e = d.toString(), -1 === e.indexOf("<") && (e = e.replace(/[0-9]/g, "0")), 
                e += [ "", f || 0, p, this.textWidth, l && l.textOverflow ].join());
                e && !a && (y = L[e]);
                if (!y) {
                    if (x || c.forExport) {
                        try {
                            (A = this.fakeTS && function(a) {
                                [].forEach.call(k.querySelectorAll(".highcharts-text-outline"), function(f) {
                                    f.style.display = a;
                                });
                            }) && A("none"), y = k.getBBox ? b({}, k.getBBox()) : {
                                width: k.offsetWidth,
                                height: k.offsetHeight
                            }, A && A("");
                        } catch (Y) {
                            "";
                        }
                        if (!y || 0 > y.width) y = {
                            width: 0,
                            height: 0
                        };
                    } else y = this.htmlGetBBox();
                    c.isSVG && (a = y.width, c = y.height, x && (y.height = c = {
                        "11px,17": 14,
                        "13px,20": 16
                    }[l && l.fontSize + "," + Math.round(c)] || c), f && (y.width = Math.abs(c * Math.sin(r)) + Math.abs(a * Math.cos(r)), 
                    y.height = Math.abs(c * Math.cos(r)) + Math.abs(a * Math.sin(r))));
                    if (e && 0 < y.height) {
                        for (;250 < m.length; ) delete L[m.shift()];
                        L[e] || m.push(e);
                        L[e] = y;
                    }
                }
                return y;
            },
            show: function(a) {
                return this.attr({
                    visibility: a ? "inherit" : "visible"
                });
            },
            hide: function() {
                return this.attr({
                    visibility: "hidden"
                });
            },
            fadeOut: function(a) {
                var f = this;
                f.animate({
                    opacity: 0
                }, {
                    duration: a || 150,
                    complete: function() {
                        f.attr({
                            y: -9999
                        });
                    }
                });
            },
            add: function(a) {
                var f = this.renderer, y = this.element, b;
                a && (this.parentGroup = a);
                this.parentInverted = a && a.inverted;
                void 0 !== this.textStr && f.buildText(this);
                this.added = !0;
                if (!a || a.handleZ || this.zIndex) b = this.zIndexSetter();
                b || (a ? a.element : f.box).appendChild(y);
                if (this.onAdd) this.onAdd();
                return this;
            },
            safeRemoveChild: function(a) {
                var f = a.parentNode;
                f && f.removeChild(a);
            },
            destroy: function() {
                var a = this, f = a.element || {}, b = a.renderer, c = b.isSVG && "SPAN" === f.nodeName && a.parentGroup, r = f.ownerSVGElement, l = a.clipPath;
                f.onclick = f.onmouseout = f.onmouseover = f.onmousemove = f.point = null;
                Q(a);
                l && r && ([].forEach.call(r.querySelectorAll("[clip-path],[CLIP-PATH]"), function(a) {
                    -1 < a.getAttribute("clip-path").indexOf(l.element.id) && a.removeAttribute("clip-path");
                }), a.clipPath = l.destroy());
                if (a.stops) {
                    for (r = 0; r < a.stops.length; r++) a.stops[r] = a.stops[r].destroy();
                    a.stops = null;
                }
                a.safeRemoveChild(f);
                for (b.styledMode || a.destroyShadows(); c && c.div && 0 === c.div.childNodes.length; ) f = c.parentGroup, 
                a.safeRemoveChild(c.div), delete c.div, c = f;
                a.alignTo && k(b.alignedObjects, a);
                A(a, function(f, y) {
                    delete a[y];
                });
            },
            shadow: function(a, f, b) {
                var y = [], c, r, l = this.element, k, p, d, g;
                if (!a) this.destroyShadows(); else if (!this.shadows) {
                    p = z(a.width, 3);
                    d = (a.opacity || .15) / p;
                    g = this.parentInverted ? "(-1,-1)" : "(" + z(a.offsetX, 1) + ", " + z(a.offsetY, 1) + ")";
                    for (c = 1; c <= p; c++) r = l.cloneNode(0), k = 2 * p + 1 - 2 * c, e(r, {
                        stroke: a.color || "#000000",
                        "stroke-opacity": d * c,
                        "stroke-width": k,
                        transform: "translate" + g,
                        fill: "none"
                    }), r.setAttribute("class", (r.getAttribute("class") || "") + " highcharts-shadow"), 
                    b && (e(r, "height", Math.max(e(r, "height") - k, 0)), r.cutHeight = k), f ? f.element.appendChild(r) : l.parentNode && l.parentNode.insertBefore(r, l), 
                    y.push(r);
                    this.shadows = y;
                }
                return this;
            },
            destroyShadows: function() {
                (this.shadows || []).forEach(function(a) {
                    this.safeRemoveChild(a);
                }, this);
                this.shadows = void 0;
            },
            xGetter: function(a) {
                "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
                return this._defaultGetter(a);
            },
            _defaultGetter: function(a) {
                a = z(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0);
                /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
                return a;
            },
            dSetter: function(a, f, b) {
                a && a.join && (a = a.join(" "));
                /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
                this[f] !== a && (b.setAttribute(f, a), this[f] = a);
            },
            dashstyleSetter: function(a) {
                var f, y = this["stroke-width"];
                "inherit" === y && (y = 1);
                if (a = a && a.toLowerCase()) {
                    a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                    for (f = a.length; f--; ) a[f] = I(a[f]) * y;
                    a = a.join(",").replace(/NaN/g, "none");
                    this.element.setAttribute("stroke-dasharray", a);
                }
            },
            alignSetter: function(a) {
                var f = {
                    left: "start",
                    center: "middle",
                    right: "end"
                };
                f[a] && (this.alignValue = a, this.element.setAttribute("text-anchor", f[a]));
            },
            opacitySetter: function(a, f, b) {
                this[f] = a;
                b.setAttribute(f, a);
            },
            titleSetter: function(a) {
                var f = this.element.getElementsByTagName("title")[0];
                f || (f = m.createElementNS(this.SVG_NS, "title"), this.element.appendChild(f));
                f.firstChild && f.removeChild(f.firstChild);
                f.appendChild(m.createTextNode(String(z(a, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
            },
            textSetter: function(a) {
                a !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = a, 
                this.added && this.renderer.buildText(this));
            },
            setTextPath: function(f, b) {
                var y = this.element, c = {
                    textAnchor: "text-anchor"
                }, r, k = !1, p, d = this.textPathWrapper, g = !d;
                b = l(!0, {
                    enabled: !0,
                    attributes: {
                        dy: -5,
                        startOffset: "50%",
                        textAnchor: "middle"
                    }
                }, b);
                r = b.attributes;
                if (f && b && b.enabled) {
                    this.options && this.options.padding && (r.dx = -this.options.padding);
                    d || (this.textPathWrapper = d = this.renderer.createElement("textPath"), k = !0);
                    p = d.element;
                    (b = f.element.getAttribute("id")) || f.element.setAttribute("id", b = a.uniqueKey());
                    if (g) for (f = y.getElementsByTagName("tspan"); f.length; ) f[0].setAttribute("y", 0), 
                    p.appendChild(f[0]);
                    k && d.add({
                        element: this.text ? this.text.element : y
                    });
                    p.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + b);
                    n(r.dy) && (p.parentNode.setAttribute("dy", r.dy), delete r.dy);
                    n(r.dx) && (p.parentNode.setAttribute("dx", r.dx), delete r.dx);
                    a.objectEach(r, function(a, f) {
                        p.setAttribute(c[f] || f, a);
                    });
                    y.removeAttribute("transform");
                    this.removeTextOutline.call(d, [].slice.call(y.getElementsByTagName("tspan")));
                    this.text && !this.renderer.styledMode && this.attr({
                        fill: "none",
                        "stroke-width": 0
                    });
                    this.applyTextOutline = this.updateTransform = D;
                } else d && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(y, f));
                return this;
            },
            destroyTextPath: function(a, f) {
                var b;
                f.element.setAttribute("id", "");
                for (b = this.textPathWrapper.element.childNodes; b.length; ) a.firstChild.appendChild(b[0]);
                a.firstChild.removeChild(this.textPathWrapper.element);
                delete f.textPathWrapper;
            },
            fillSetter: function(a, f, b) {
                "string" === typeof a ? b.setAttribute(f, a) : a && this.complexColor(a, f, b);
            },
            visibilitySetter: function(a, f, b) {
                "inherit" === a ? b.removeAttribute(f) : this[f] !== a && b.setAttribute(f, a);
                this[f] = a;
            },
            zIndexSetter: function(a, f) {
                var b = this.renderer, y = this.parentGroup, c = (y || b).element || b.box, r, k = this.element, l = !1, p, b = c === b.box;
                r = this.added;
                var d;
                n(a) ? (k.setAttribute("data-z-index", a), a = +a, this[f] === a && (r = !1)) : n(this[f]) && k.removeAttribute("data-z-index");
                this[f] = a;
                if (r) {
                    (a = this.zIndex) && y && (y.handleZ = !0);
                    f = c.childNodes;
                    for (d = f.length - 1; 0 <= d && !l; d--) if (y = f[d], r = y.getAttribute("data-z-index"), 
                    p = !n(r), y !== k) if (0 > a && p && !b && !d) c.insertBefore(k, f[d]), l = !0; else if (I(r) <= a || p && (!n(a) || 0 <= a)) c.insertBefore(k, f[d + 1] || null), 
                    l = !0;
                    l || (c.insertBefore(k, f[b ? 3 : 0] || null), l = !0);
                }
                return l;
            },
            _defaultSetter: function(a, f, b) {
                b.setAttribute(f, a);
            }
        });
        E.prototype.yGetter = E.prototype.xGetter;
        E.prototype.translateXSetter = E.prototype.translateYSetter = E.prototype.rotationSetter = E.prototype.verticalAlignSetter = E.prototype.rotationOriginXSetter = E.prototype.rotationOriginYSetter = E.prototype.scaleXSetter = E.prototype.scaleYSetter = E.prototype.matrixSetter = function(a, f) {
            this[f] = a;
            this.doTransform = !0;
        };
        E.prototype["stroke-widthSetter"] = E.prototype.strokeSetter = function(a, f, b) {
            this[f] = a;
            this.stroke && this["stroke-width"] ? (E.prototype.fillSetter.call(this, this.stroke, "stroke", b), 
            b.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === f && 0 === a && this.hasStroke && (b.removeAttribute("stroke"), 
            this.hasStroke = !1);
        };
        H = a.SVGRenderer = function() {
            this.init.apply(this, arguments);
        };
        b(H.prototype, {
            Element: E,
            SVG_NS: L,
            init: function(a, f, b, c, r, k, l) {
                var y;
                y = this.createElement("svg").attr({
                    version: "1.1",
                    class: "highcharts-root"
                });
                l || y.css(this.getStyle(c));
                c = y.element;
                a.appendChild(c);
                e(a, "dir", "ltr");
                -1 === a.innerHTML.indexOf("xmlns") && e(c, "xmlns", this.SVG_NS);
                this.isSVG = !0;
                this.box = c;
                this.boxWrapper = y;
                this.alignedObjects = [];
                this.url = (x || C) && m.getElementsByTagName("base").length ? R.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
                this.createElement("desc").add().element.appendChild(m.createTextNode("Created with Highcharts 7.1.2"));
                this.defs = this.createElement("defs").add();
                this.allowHTML = k;
                this.forExport = r;
                this.styledMode = l;
                this.gradients = {};
                this.cache = {};
                this.cacheKeys = [];
                this.imgCount = 0;
                this.setSize(f, b, !1);
                var p;
                x && a.getBoundingClientRect && (f = function() {
                    u(a, {
                        left: 0,
                        top: 0
                    });
                    p = a.getBoundingClientRect();
                    u(a, {
                        left: Math.ceil(p.left) - p.left + "px",
                        top: Math.ceil(p.top) - p.top + "px"
                    });
                }, f(), this.unSubPixelFix = B(R, "resize", f));
            },
            definition: function(a) {
                function f(a, c) {
                    var y;
                    r(a).forEach(function(a) {
                        var r = b.createElement(a.tagName), k = {};
                        A(a, function(a, f) {
                            "tagName" !== f && "children" !== f && "textContent" !== f && (k[f] = a);
                        });
                        r.attr(k);
                        r.add(c || b.defs);
                        a.textContent && r.element.appendChild(m.createTextNode(a.textContent));
                        f(a.children || [], r);
                        y = r;
                    });
                    return y;
                }
                var b = this;
                return f(a);
            },
            getStyle: function(a) {
                return this.style = b({
                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                    fontSize: "12px"
                }, a);
            },
            setStyle: function(a) {
                this.boxWrapper.css(this.getStyle(a));
            },
            isHidden: function() {
                return !this.boxWrapper.getBBox().width;
            },
            destroy: function() {
                var a = this.defs;
                this.box = null;
                this.boxWrapper = this.boxWrapper.destroy();
                d(this.gradients || {});
                this.gradients = null;
                a && (this.defs = a.destroy());
                this.unSubPixelFix && this.unSubPixelFix();
                return this.alignedObjects = null;
            },
            createElement: function(a) {
                var f = new this.Element();
                f.init(this, a);
                return f;
            },
            draw: D,
            getRadialAttr: function(a, f) {
                return {
                    cx: a[0] - a[2] / 2 + f.cx * a[2],
                    cy: a[1] - a[2] / 2 + f.cy * a[2],
                    r: f.r * a[2]
                };
            },
            truncate: function(a, f, b, c, r, k, l) {
                var y = this, p = a.rotation, d, g = c ? 1 : 0, A = (b || c).length, L = A, x = [], e = function(a) {
                    f.firstChild && f.removeChild(f.firstChild);
                    a && f.appendChild(m.createTextNode(a));
                }, n = function(k, p) {
                    p = p || k;
                    if (void 0 === x[p]) if (f.getSubStringLength) try {
                        x[p] = r + f.getSubStringLength(0, c ? p + 1 : p);
                    } catch (Z) {
                        "";
                    } else y.getSpanWidth && (e(l(b || c, k)), x[p] = r + y.getSpanWidth(a, f));
                    return x[p];
                }, D, w;
                a.rotation = 0;
                D = n(f.textContent.length);
                if (w = r + D > k) {
                    for (;g <= A; ) L = Math.ceil((g + A) / 2), c && (d = l(c, L)), D = n(L, d && d.length - 1), 
                    g === A ? g = A + 1 : D > k ? A = L - 1 : g = L;
                    0 === A ? e("") : b && A === b.length - 1 || e(d || l(b || c, L));
                }
                c && c.splice(0, L);
                a.actualWidth = D;
                a.rotation = p;
                return w;
            },
            escapes: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;"
            },
            buildText: function(a) {
                var f = a.element, b = this, c = b.forExport, r = z(a.textStr, "").toString(), y = -1 !== r.indexOf("<"), k = f.childNodes, p, l = e(f, "x"), d = a.styles, g = a.textWidth, x = d && d.lineHeight, n = d && d.textOutline, D = d && "ellipsis" === d.textOverflow, w = d && "nowrap" === d.whiteSpace, Q = d && d.fontSize, M, C, h = k.length, d = g && !a.added && this.box, F = function(a) {
                    var c;
                    b.styledMode || (c = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : Q || b.style.fontSize || 12);
                    return x ? I(x) : b.fontMetrics(c, a.getAttribute("style") ? a : f).h;
                }, R = function(a, f) {
                    A(b.escapes, function(b, c) {
                        f && -1 !== f.indexOf(b) || (a = a.toString().replace(new RegExp(b, "g"), c));
                    });
                    return a;
                }, v = function(a, f) {
                    var b;
                    b = a.indexOf("<");
                    a = a.substring(b, a.indexOf(">") - b);
                    b = a.indexOf(f + "=");
                    if (-1 !== b && (b = b + f.length + 1, f = a.charAt(b), '"' === f || "'" === f)) return a = a.substring(b + 1), 
                    a.substring(0, a.indexOf(f));
                };
                M = [ r, D, w, x, n, Q, g ].join();
                if (M !== a.textCache) {
                    for (a.textCache = M; h--; ) f.removeChild(k[h]);
                    y || n || D || g || -1 !== r.indexOf(" ") ? (d && d.appendChild(f), y ? (r = b.styledMode ? r.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">') : r.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">'), 
                    r = r.replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g)) : r = [ r ], 
                    r = r.filter(function(a) {
                        return "" !== a;
                    }), r.forEach(function(r, y) {
                        var k, d = 0, A = 0;
                        r = r.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                        k = r.split("|||");
                        k.forEach(function(r) {
                            if ("" !== r || 1 === k.length) {
                                var x = {}, n = m.createElementNS(b.SVG_NS, "tspan"), z, M;
                                (z = v(r, "class")) && e(n, "class", z);
                                if (z = v(r, "style")) z = z.replace(/(;| |^)color([ :])/, "$1fill$2"), e(n, "style", z);
                                (M = v(r, "href")) && !c && (e(n, "onclick", 'location.href="' + M + '"'), e(n, "class", "highcharts-anchor"), 
                                b.styledMode || u(n, {
                                    cursor: "pointer"
                                }));
                                r = R(r.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");
                                if (" " !== r) {
                                    n.appendChild(m.createTextNode(r));
                                    d ? x.dx = 0 : y && null !== l && (x.x = l);
                                    e(n, x);
                                    f.appendChild(n);
                                    !d && C && (!N && c && u(n, {
                                        display: "block"
                                    }), e(n, "dy", F(n)));
                                    if (g) {
                                        var h = r.replace(/([^\^])-/g, "$1- ").split(" "), x = !w && (1 < k.length || y || 1 < h.length);
                                        M = 0;
                                        var I = F(n);
                                        if (D) p = b.truncate(a, n, r, void 0, 0, Math.max(0, g - parseInt(Q || 12, 10)), function(a, f) {
                                            return a.substring(0, f) + "";
                                        }); else if (x) for (;h.length; ) h.length && !w && 0 < M && (n = m.createElementNS(L, "tspan"), 
                                        e(n, {
                                            dy: I,
                                            x: l
                                        }), z && e(n, "style", z), n.appendChild(m.createTextNode(h.join(" ").replace(/- /g, "-"))), 
                                        f.appendChild(n)), b.truncate(a, n, null, h, 0 === M ? A : 0, g, function(a, f) {
                                            return h.slice(0, f).join(" ").replace(/- /g, "-");
                                        }), A = a.actualWidth, M++;
                                    }
                                    d++;
                                }
                            }
                        });
                        C = C || f.childNodes.length;
                    }), D && p && a.attr("title", R(a.textStr, [ "&lt;", "&gt;" ])), d && d.removeChild(f), 
                    n && a.applyTextOutline && a.applyTextOutline(n)) : f.appendChild(m.createTextNode(R(r)));
                }
            },
            getContrast: function(a) {
                a = t(a).rgba;
                a[0] *= 1;
                a[1] *= 1.2;
                a[2] *= .5;
                return 459 < a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF";
            },
            button: function(a, f, c, r, k, d, p, g, A, L) {
                var y = this.label(a, f, c, A, null, null, L, null, "button"), n = 0, x = this.styledMode;
                y.attr(l({
                    padding: 8,
                    r: 2
                }, k));
                if (!x) {
                    var m, e, D, w;
                    k = l({
                        fill: "#f7f7f7",
                        stroke: "#cccccc",
                        "stroke-width": 1,
                        style: {
                            color: "#333333",
                            cursor: "pointer",
                            fontWeight: "normal"
                        }
                    }, k);
                    m = k.style;
                    delete k.style;
                    d = l(k, {
                        fill: "#e6e6e6"
                    }, d);
                    e = d.style;
                    delete d.style;
                    p = l(k, {
                        fill: "#e6ebf5",
                        style: {
                            color: "#000000",
                            fontWeight: "bold"
                        }
                    }, p);
                    D = p.style;
                    delete p.style;
                    g = l(k, {
                        style: {
                            color: "#cccccc"
                        }
                    }, g);
                    w = g.style;
                    delete g.style;
                }
                B(y.element, K ? "mouseover" : "mouseenter", function() {
                    3 !== n && y.setState(1);
                });
                B(y.element, K ? "mouseout" : "mouseleave", function() {
                    3 !== n && y.setState(n);
                });
                y.setState = function(a) {
                    1 !== a && (y.state = n = a);
                    y.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + [ "normal", "hover", "pressed", "disabled" ][a || 0]);
                    x || y.attr([ k, d, p, g ][a || 0]).css([ m, e, D, w ][a || 0]);
                };
                x || y.attr(k).css(b({
                    cursor: "default"
                }, m));
                return y.on("click", function(a) {
                    3 !== n && r.call(y, a);
                });
            },
            crispLine: function(a, f) {
                a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - f % 2 / 2);
                a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + f % 2 / 2);
                return a;
            },
            path: function(a) {
                var f = this.styledMode ? {} : {
                    fill: "none"
                };
                c(a) ? f.d = a : w(a) && b(f, a);
                return this.createElement("path").attr(f);
            },
            circle: function(a, f, b) {
                a = w(a) ? a : void 0 === a ? {} : {
                    x: a,
                    y: f,
                    r: b
                };
                f = this.createElement("circle");
                f.xSetter = f.ySetter = function(a, f, b) {
                    b.setAttribute("c" + f, a);
                };
                return f.attr(a);
            },
            arc: function(a, f, b, c, r, k) {
                w(a) ? (c = a, f = c.y, b = c.r, a = c.x) : c = {
                    innerR: c,
                    start: r,
                    end: k
                };
                a = this.symbol("arc", a, f, b, b, c);
                a.r = b;
                return a;
            },
            rect: function(a, f, b, c, r, k) {
                r = w(a) ? a.r : r;
                var d = this.createElement("rect");
                a = w(a) ? a : void 0 === a ? {} : {
                    x: a,
                    y: f,
                    width: Math.max(b, 0),
                    height: Math.max(c, 0)
                };
                this.styledMode || (void 0 !== k && (a.strokeWidth = k, a = d.crisp(a)), a.fill = "none");
                r && (a.r = r);
                d.rSetter = function(a, f, b) {
                    d.r = a;
                    e(b, {
                        rx: a,
                        ry: a
                    });
                };
                d.rGetter = function() {
                    return d.r;
                };
                return d.attr(a);
            },
            setSize: function(a, f, b) {
                var c = this.alignedObjects, r = c.length;
                this.width = a;
                this.height = f;
                for (this.boxWrapper.animate({
                    width: a,
                    height: f
                }, {
                    step: function() {
                        this.attr({
                            viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                        });
                    },
                    duration: z(b, !0) ? void 0 : 0
                }); r--; ) c[r].align();
            },
            g: function(a) {
                var f = this.createElement("g");
                return a ? f.attr({
                    class: "highcharts-" + a
                }) : f;
            },
            image: function(a, f, c, r, k, d) {
                var p = {
                    preserveAspectRatio: "none"
                }, l, y = function(a, f) {
                    a.setAttributeNS ? a.setAttributeNS("http://www.w3.org/1999/xlink", "href", f) : a.setAttribute("hc-svg-href", f);
                }, g = function(f) {
                    y(l.element, a);
                    d.call(l, f);
                };
                1 < arguments.length && b(p, {
                    x: f,
                    y: c,
                    width: r,
                    height: k
                });
                l = this.createElement("image").attr(p);
                d ? (y(l.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), 
                p = new R.Image(), B(p, "load", g), p.src = a, p.complete && g({})) : y(l.element, a);
                return l;
            },
            symbol: function(a, f, c, r, k, d) {
                var p = this, l, y = /^url\((.*?)\)$/, g = y.test(a), A = !g && (this.symbols[a] ? a : "circle"), L = A && this.symbols[A], x = n(f) && L && L.call(this.symbols, Math.round(f), Math.round(c), r, k, d), e, D;
                L ? (l = this.path(x), p.styledMode || l.attr("fill", "none"), b(l, {
                    symbolName: A,
                    x: f,
                    y: c,
                    width: r,
                    height: k
                }), d && b(l, d)) : g && (e = a.match(y)[1], l = this.image(e), l.imgwidth = z(M[e] && M[e].width, d && d.width), 
                l.imgheight = z(M[e] && M[e].height, d && d.height), D = function() {
                    l.attr({
                        width: l.width,
                        height: l.height
                    });
                }, [ "width", "height" ].forEach(function(a) {
                    l[a + "Setter"] = function(a, f) {
                        var b = {}, c = this["img" + f], r = "width" === f ? "translateX" : "translateY";
                        this[f] = a;
                        n(c) && (d && "within" === d.backgroundSize && this.width && this.height && (c = Math.round(c * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), 
                        this.element && this.element.setAttribute(f, c), this.alignByTranslate || (b[r] = ((this[f] || 0) - c) / 2, 
                        this.attr(b)));
                    };
                }), n(f) && l.attr({
                    x: f,
                    y: c
                }), l.isImg = !0, n(l.imgwidth) && n(l.imgheight) ? D() : (l.attr({
                    width: 0,
                    height: 0
                }), v("img", {
                    onload: function() {
                        var a = q[p.chartIndex];
                        0 === this.width && (u(this, {
                            position: "absolute",
                            top: "-999em"
                        }), m.body.appendChild(this));
                        M[e] = {
                            width: this.width,
                            height: this.height
                        };
                        l.imgwidth = this.width;
                        l.imgheight = this.height;
                        l.element && D();
                        this.parentNode && this.parentNode.removeChild(this);
                        p.imgCount--;
                        if (!p.imgCount && a && a.onload) a.onload();
                    },
                    src: e
                }), this.imgCount++));
                return l;
            },
            symbols: {
                circle: function(a, f, b, c) {
                    return this.arc(a + b / 2, f + c / 2, b / 2, c / 2, {
                        start: .5 * Math.PI,
                        end: 2.5 * Math.PI,
                        open: !1
                    });
                },
                square: function(a, f, b, c) {
                    return [ "M", a, f, "L", a + b, f, a + b, f + c, a, f + c, "Z" ];
                },
                triangle: function(a, f, b, c) {
                    return [ "M", a + b / 2, f, "L", a + b, f + c, a, f + c, "Z" ];
                },
                "triangle-down": function(a, f, b, c) {
                    return [ "M", a, f, "L", a + b, f, a + b / 2, f + c, "Z" ];
                },
                diamond: function(a, f, b, c) {
                    return [ "M", a + b / 2, f, "L", a + b, f + c / 2, a + b / 2, f + c, a, f + c / 2, "Z" ];
                },
                arc: function(a, f, b, c, r) {
                    var d = r.start, k = r.r || b, l = r.r || c || b, p = r.end - .001;
                    b = r.innerR;
                    c = z(r.open, .001 > Math.abs(r.end - r.start - 2 * Math.PI));
                    var y = Math.cos(d), g = Math.sin(d), A = Math.cos(p), p = Math.sin(p), d = .001 > r.end - d - Math.PI ? 0 : 1;
                    r = [ "M", a + k * y, f + l * g, "A", k, l, 0, d, z(r.clockwise, 1), a + k * A, f + l * p ];
                    n(b) && r.push(c ? "M" : "L", a + b * A, f + b * p, "A", b, b, 0, d, 0, a + b * y, f + b * g);
                    r.push(c ? "" : "Z");
                    return r;
                },
                callout: function(a, f, b, c, r) {
                    var d = Math.min(r && r.r || 0, b, c), k = d + 6, l = r && r.anchorX;
                    r = r && r.anchorY;
                    var p;
                    p = [ "M", a + d, f, "L", a + b - d, f, "C", a + b, f, a + b, f, a + b, f + d, "L", a + b, f + c - d, "C", a + b, f + c, a + b, f + c, a + b - d, f + c, "L", a + d, f + c, "C", a, f + c, a, f + c, a, f + c - d, "L", a, f + d, "C", a, f, a, f, a + d, f ];
                    l && l > b ? r > f + k && r < f + c - k ? p.splice(13, 3, "L", a + b, r - 6, a + b + 6, r, a + b, r + 6, a + b, f + c - d) : p.splice(13, 3, "L", a + b, c / 2, l, r, a + b, c / 2, a + b, f + c - d) : l && 0 > l ? r > f + k && r < f + c - k ? p.splice(33, 3, "L", a, r + 6, a - 6, r, a, r - 6, a, f + d) : p.splice(33, 3, "L", a, c / 2, l, r, a, c / 2, a, f + d) : r && r > c && l > a + k && l < a + b - k ? p.splice(23, 3, "L", l + 6, f + c, l, f + c + 6, l - 6, f + c, a + d, f + c) : r && 0 > r && l > a + k && l < a + b - k && p.splice(3, 3, "L", l - 6, f, l, f - 6, l + 6, f, b - d, f);
                    return p;
                }
            },
            clipRect: function(f, b, c, r) {
                var d = a.uniqueKey() + "-", l = this.createElement("clipPath").attr({
                    id: d
                }).add(this.defs);
                f = this.rect(f, b, c, r, 0).add(l);
                f.id = d;
                f.clipPath = l;
                f.count = 0;
                return f;
            },
            text: function(a, f, b, c) {
                var r = {};
                if (c && (this.allowHTML || !this.forExport)) return this.html(a, f, b);
                r.x = Math.round(f || 0);
                b && (r.y = Math.round(b));
                n(a) && (r.text = a);
                a = this.createElement("text").attr(r);
                c || (a.xSetter = function(a, f, b) {
                    var c = b.getElementsByTagName("tspan"), r, d = b.getAttribute(f), l;
                    for (l = 0; l < c.length; l++) r = c[l], r.getAttribute(f) === d && r.setAttribute(f, a);
                    b.setAttribute(f, a);
                });
                return a;
            },
            fontMetrics: function(a, f) {
                a = !this.styledMode && /px/.test(a) || !R.getComputedStyle ? a || f && f.style && f.style.fontSize || this.style && this.style.fontSize : f && E.prototype.getStyle.call(f, "font-size");
                a = /px/.test(a) ? I(a) : 12;
                f = 24 > a ? a + 3 : Math.round(1.2 * a);
                return {
                    h: f,
                    b: Math.round(.8 * f),
                    f: a
                };
            },
            rotCorr: function(a, f, b) {
                var c = a;
                f && b && (c = Math.max(c * Math.cos(f * g), 4));
                return {
                    x: -a / 3 * Math.sin(f * g),
                    y: c
                };
            },
            label: function(c, r, d, k, p, g, A, L, x) {
                var y = this, e = y.styledMode, m = y.g("button" !== x && "label"), D = m.text = y.text("", 0, 0, A).attr({
                    zIndex: 1
                }), w, z, N = 0, M = 3, Q = 0, C, h, I, F, R, v = {}, K, t, q = /^url\((.*?)\)$/.test(k), u = e || q, S = function() {
                    return e ? w.strokeWidth() % 2 / 2 : (K ? parseInt(K, 10) : 0) % 2 / 2;
                }, U, P, T;
                x && m.addClass("highcharts-" + x);
                U = function() {
                    var a = D.element.style, f = {};
                    z = (void 0 === C || void 0 === h || R) && n(D.textStr) && D.getBBox();
                    m.width = (C || z.width || 0) + 2 * M + Q;
                    m.height = (h || z.height || 0) + 2 * M;
                    t = M + Math.min(y.fontMetrics(a && a.fontSize, D).b, z ? z.height : Infinity);
                    u && (w || (m.box = w = y.symbols[k] || q ? y.symbol(k) : y.rect(), w.addClass(("button" === x ? "" : "highcharts-label-box") + (x ? " highcharts-" + x + "-box" : "")), 
                    w.add(m), a = S(), f.x = a, f.y = (L ? -t : 0) + a), f.width = Math.round(m.width), 
                    f.height = Math.round(m.height), w.attr(b(f, v)), v = {});
                };
                P = function() {
                    var a = Q + M, f;
                    f = L ? 0 : t;
                    n(C) && z && ("center" === R || "right" === R) && (a += {
                        center: .5,
                        right: 1
                    }[R] * (C - z.width));
                    if (a !== D.x || f !== D.y) D.attr("x", a), D.hasBoxWidthChanged && (z = D.getBBox(!0), 
                    U()), void 0 !== f && D.attr("y", f);
                    D.x = a;
                    D.y = f;
                };
                T = function(a, f) {
                    w ? w.attr(a, f) : v[a] = f;
                };
                m.onAdd = function() {
                    D.add(m);
                    m.attr({
                        text: c || 0 === c ? c : "",
                        x: r,
                        y: d
                    });
                    w && n(p) && m.attr({
                        anchorX: p,
                        anchorY: g
                    });
                };
                m.widthSetter = function(f) {
                    C = a.isNumber(f) ? f : null;
                };
                m.heightSetter = function(a) {
                    h = a;
                };
                m["text-alignSetter"] = function(a) {
                    R = a;
                };
                m.paddingSetter = function(a) {
                    n(a) && a !== M && (M = m.padding = a, P());
                };
                m.paddingLeftSetter = function(a) {
                    n(a) && a !== Q && (Q = a, P());
                };
                m.alignSetter = function(a) {
                    a = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[a];
                    a !== N && (N = a, z && m.attr({
                        x: I
                    }));
                };
                m.textSetter = function(a) {
                    void 0 !== a && D.attr({
                        text: a
                    });
                    U();
                    P();
                };
                m["stroke-widthSetter"] = function(a, f) {
                    a && (u = !0);
                    K = this["stroke-width"] = a;
                    T(f, a);
                };
                e ? m.rSetter = function(a, f) {
                    T(f, a);
                } : m.strokeSetter = m.fillSetter = m.rSetter = function(a, f) {
                    "r" !== f && ("fill" === f && a && (u = !0), m[f] = a);
                    T(f, a);
                };
                m.anchorXSetter = function(a, f) {
                    p = m.anchorX = a;
                    T(f, Math.round(a) - S() - I);
                };
                m.anchorYSetter = function(a, f) {
                    g = m.anchorY = a;
                    T(f, a - F);
                };
                m.xSetter = function(a) {
                    m.x = a;
                    N && (a -= N * ((C || z.width) + 2 * M), m["forceAnimate:x"] = !0);
                    I = Math.round(a);
                    m.attr("translateX", I);
                };
                m.ySetter = function(a) {
                    F = m.y = Math.round(a);
                    m.attr("translateY", F);
                };
                var B = m.css;
                A = {
                    css: function(a) {
                        if (a) {
                            var f = {};
                            a = l(a);
                            m.textProps.forEach(function(b) {
                                void 0 !== a[b] && (f[b] = a[b], delete a[b]);
                            });
                            D.css(f);
                            "width" in f && U();
                            "fontSize" in f && (U(), P());
                        }
                        return B.call(m, a);
                    },
                    getBBox: function() {
                        return {
                            width: z.width + 2 * M,
                            height: z.height + 2 * M,
                            x: z.x - M,
                            y: z.y - M
                        };
                    },
                    destroy: function() {
                        f(m.element, "mouseenter");
                        f(m.element, "mouseleave");
                        D && (D = D.destroy());
                        w && (w = w.destroy());
                        E.prototype.destroy.call(m);
                        m = y = U = P = T = null;
                    }
                };
                e || (A.shadow = function(a) {
                    a && (U(), w && w.shadow(a));
                    return m;
                });
                return b(m, A);
            }
        });
        a.Renderer = H;
    });
    J(G, "parts/Html.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.attr, H = a.createElement, B = a.css, h = a.defined, e = a.extend, q = a.isFirefox, t = a.isMS, u = a.isWebKit, v = a.pick, n = a.pInt, g = a.SVGElement, d = a.SVGRenderer, m = a.win;
        e(g.prototype, {
            htmlCss: function(a) {
                var b = "SPAN" === this.element.tagName && a && "width" in a, d = v(b && a.width, void 0), c;
                b && (delete a.width, this.textWidth = d, c = !0);
                a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
                this.styles = e(this.styles, a);
                B(this.element, a);
                c && this.htmlUpdateTransform();
                return this;
            },
            htmlGetBBox: function() {
                var a = this.element;
                return {
                    x: a.offsetLeft,
                    y: a.offsetTop,
                    width: a.offsetWidth,
                    height: a.offsetHeight
                };
            },
            htmlUpdateTransform: function() {
                if (this.added) {
                    var a = this.renderer, d = this.element, p = this.translateX || 0, c = this.translateY || 0, g = this.x || 0, m = this.y || 0, e = this.textAlign || "left", F = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[e], C = this.styles, l = C && C.whiteSpace;
                    B(d, {
                        marginLeft: p,
                        marginTop: c
                    });
                    !a.styledMode && this.shadows && this.shadows.forEach(function(a) {
                        B(a, {
                            marginLeft: p + 1,
                            marginTop: c + 1
                        });
                    });
                    this.inverted && [].forEach.call(d.childNodes, function(b) {
                        a.invertChild(b, d);
                    });
                    if ("SPAN" === d.tagName) {
                        var C = this.rotation, D = this.textWidth && n(this.textWidth), A = [ C, e, d.innerHTML, this.textWidth, this.textAlign ].join(), z;
                        (z = D !== this.oldTextWidth) && !(z = D > this.oldTextWidth) && ((z = this.textPxLength) || (B(d, {
                            width: "",
                            whiteSpace: l || "nowrap"
                        }), z = d.offsetWidth), z = z > D);
                        z && (/[ \-]/.test(d.textContent || d.innerText) || "ellipsis" === d.style.textOverflow) ? (B(d, {
                            width: D + "px",
                            display: "block",
                            whiteSpace: l || "normal"
                        }), this.oldTextWidth = D, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
                        A !== this.cTT && (l = a.fontMetrics(d.style.fontSize, d).b, !h(C) || C === (this.oldRotation || 0) && e === this.oldAlign || this.setSpanRotation(C, F, l), 
                        this.getSpanCorrection(!h(C) && this.textPxLength || d.offsetWidth, l, F, C, e));
                        B(d, {
                            left: g + (this.xCorr || 0) + "px",
                            top: m + (this.yCorr || 0) + "px"
                        });
                        this.cTT = A;
                        this.oldRotation = C;
                        this.oldAlign = e;
                    }
                } else this.alignOnAdd = !0;
            },
            setSpanRotation: function(a, d, p) {
                var b = {}, k = this.renderer.getTransformKey();
                b[k] = b.transform = "rotate(" + a + "deg)";
                b[k + (q ? "Origin" : "-origin")] = b.transformOrigin = 100 * d + "% " + p + "px";
                B(this.element, b);
            },
            getSpanCorrection: function(a, d, p) {
                this.xCorr = -a * p;
                this.yCorr = -d;
            }
        });
        e(d.prototype, {
            getTransformKey: function() {
                return t && !/Edge/.test(m.navigator.userAgent) ? "-ms-transform" : u ? "-webkit-transform" : q ? "MozTransform" : m.opera ? "-o-transform" : "";
            },
            html: function(b, d, p) {
                var c = this.createElement("span"), k = c.element, m = c.renderer, n = m.isSVG, h = function(a, b) {
                    [ "opacity", "visibility" ].forEach(function(c) {
                        a[c + "Setter"] = function(d, l, f) {
                            var r = a.div ? a.div.style : b;
                            g.prototype[c + "Setter"].call(this, d, l, f);
                            r && (r[l] = d);
                        };
                    });
                    a.addedSetters = !0;
                }, C = a.charts[m.chartIndex], C = C && C.styledMode;
                c.textSetter = function(a) {
                    a !== k.innerHTML && (delete this.bBox, delete this.oldTextWidth);
                    this.textStr = a;
                    k.innerHTML = v(a, "");
                    c.doTransform = !0;
                };
                n && h(c, c.element.style);
                c.xSetter = c.ySetter = c.alignSetter = c.rotationSetter = function(a, b) {
                    "align" === b && (b = "textAlign");
                    c[b] = a;
                    c.doTransform = !0;
                };
                c.afterSetters = function() {
                    this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
                };
                c.attr({
                    text: b,
                    x: Math.round(d),
                    y: Math.round(p)
                }).css({
                    position: "absolute"
                });
                C || c.css({
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize
                });
                k.style.whiteSpace = "nowrap";
                c.css = c.htmlCss;
                n && (c.add = function(a) {
                    var b, d = m.box.parentNode, l = [];
                    if (this.parentGroup = a) {
                        if (b = a.div, !b) {
                            for (;a; ) l.push(a), a = a.parentGroup;
                            l.reverse().forEach(function(a) {
                                function f(f, b) {
                                    a[b] = f;
                                    "translateX" === b ? r.left = f + "px" : r.top = f + "px";
                                    a.doTransform = !0;
                                }
                                var r, p = E(a.element, "class");
                                p && (p = {
                                    className: p
                                });
                                b = a.div = a.div || H("div", p, {
                                    position: "absolute",
                                    left: (a.translateX || 0) + "px",
                                    top: (a.translateY || 0) + "px",
                                    display: a.display,
                                    opacity: a.opacity,
                                    pointerEvents: a.styles && a.styles.pointerEvents
                                }, b || d);
                                r = b.style;
                                e(a, {
                                    classSetter: function(a) {
                                        return function(f) {
                                            this.element.setAttribute("class", f);
                                            a.className = f;
                                        };
                                    }(b),
                                    on: function() {
                                        l[0].div && c.on.apply({
                                            element: l[0].div
                                        }, arguments);
                                        return a;
                                    },
                                    translateXSetter: f,
                                    translateYSetter: f
                                });
                                a.addedSetters || h(a);
                            });
                        }
                    } else b = d;
                    b.appendChild(k);
                    c.added = !0;
                    c.alignOnAdd && c.htmlUpdateTransform();
                    return c;
                });
                return c;
            }
        });
    });
    J(G, "parts/Time.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.defined, H = a.extend, B = a.merge, h = a.pick, e = a.timeUnits, q = a.win;
        a.Time = function(a) {
            this.update(a, !1);
        };
        a.Time.prototype = {
            defaultOptions: {},
            update: function(a) {
                var e = h(a && a.useUTC, !0), v = this;
                this.options = a = B(!0, this.options || {}, a);
                this.Date = a.Date || q.Date || Date;
                this.timezoneOffset = (this.useUTC = e) && a.timezoneOffset;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                (this.variableTimezone = !(e && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function(a, g) {
                    var d = g.getTime(), m = d - v.getTimezoneOffset(g);
                    g.setTime(m);
                    a = g["getUTC" + a]();
                    g.setTime(d);
                    return a;
                }, this.set = function(a, g, d) {
                    var m;
                    if ("Milliseconds" === a || "Seconds" === a || "Minutes" === a && 0 === g.getTimezoneOffset() % 60) g["set" + a](d); else m = v.getTimezoneOffset(g), 
                    m = g.getTime() - m, g.setTime(m), g["setUTC" + a](d), a = v.getTimezoneOffset(g), 
                    m = g.getTime() + a, g.setTime(m);
                }) : e ? (this.get = function(a, g) {
                    return g["getUTC" + a]();
                }, this.set = function(a, g, d) {
                    return g["setUTC" + a](d);
                }) : (this.get = function(a, g) {
                    return g["get" + a]();
                }, this.set = function(a, g, d) {
                    return g["set" + a](d);
                });
            },
            makeTime: function(e, q, v, n, g, d) {
                var m, b, k;
                this.useUTC ? (m = this.Date.UTC.apply(0, arguments), b = this.getTimezoneOffset(m), 
                m += b, k = this.getTimezoneOffset(m), b !== k ? m += k - b : b - 36e5 !== this.getTimezoneOffset(m - 36e5) || a.isSafari || (m -= 36e5)) : m = new this.Date(e, q, h(v, 1), h(n, 0), h(g, 0), h(d, 0)).getTime();
                return m;
            },
            timezoneOffsetFunction: function() {
                var e = this, h = this.options, v = q.moment;
                if (!this.useUTC) return function(a) {
                    return 6e4 * new Date(a).getTimezoneOffset();
                };
                if (h.timezone) {
                    if (v) return function(a) {
                        return 6e4 * -v.tz(a, h.timezone).utcOffset();
                    };
                    a.error(25);
                }
                return this.useUTC && h.getTimezoneOffset ? function(a) {
                    return 6e4 * h.getTimezoneOffset(a);
                } : function() {
                    return 6e4 * (e.timezoneOffset || 0);
                };
            },
            dateFormat: function(e, h, v) {
                if (!a.defined(h) || isNaN(h)) return a.defaultOptions.lang.invalidDate || "";
                e = a.pick(e, "%Y-%m-%d %H:%M:%S");
                var n = this, g = new this.Date(h), d = this.get("Hours", g), m = this.get("Day", g), b = this.get("Date", g), k = this.get("Month", g), p = this.get("FullYear", g), c = a.defaultOptions.lang, x = c.weekdays, q = c.shortWeekdays, w = a.pad, g = a.extend({
                    a: q ? q[m] : x[m].substr(0, 3),
                    A: x[m],
                    d: w(b),
                    e: w(b, 2, " "),
                    w: m,
                    b: c.shortMonths[k],
                    B: c.months[k],
                    m: w(k + 1),
                    o: k + 1,
                    y: p.toString().substr(2, 2),
                    Y: p,
                    H: w(d),
                    k: d,
                    I: w(d % 12 || 12),
                    l: d % 12 || 12,
                    M: w(n.get("Minutes", g)),
                    p: 12 > d ? "AM" : "PM",
                    P: 12 > d ? "am" : "pm",
                    S: w(g.getSeconds()),
                    L: w(Math.floor(h % 1e3), 3)
                }, a.dateFormats);
                a.objectEach(g, function(a, b) {
                    for (;-1 !== e.indexOf("%" + b); ) e = e.replace("%" + b, "function" === typeof a ? a.call(n, h) : a);
                });
                return v ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;
            },
            resolveDTLFormat: function(e) {
                return a.isObject(e, !0) ? e : (e = a.splat(e), {
                    main: e[0],
                    from: e[1],
                    to: e[2]
                });
            },
            getTimeTicks: function(a, q, v, n) {
                var g = this, d = [], m, b = {}, k;
                m = new g.Date(q);
                var p = a.unitRange, c = a.count || 1, x;
                n = h(n, 1);
                if (E(q)) {
                    g.set("Milliseconds", m, p >= e.second ? 0 : c * Math.floor(g.get("Milliseconds", m) / c));
                    p >= e.second && g.set("Seconds", m, p >= e.minute ? 0 : c * Math.floor(g.get("Seconds", m) / c));
                    p >= e.minute && g.set("Minutes", m, p >= e.hour ? 0 : c * Math.floor(g.get("Minutes", m) / c));
                    p >= e.hour && g.set("Hours", m, p >= e.day ? 0 : c * Math.floor(g.get("Hours", m) / c));
                    p >= e.day && g.set("Date", m, p >= e.month ? 1 : Math.max(1, c * Math.floor(g.get("Date", m) / c)));
                    p >= e.month && (g.set("Month", m, p >= e.year ? 0 : c * Math.floor(g.get("Month", m) / c)), 
                    k = g.get("FullYear", m));
                    p >= e.year && g.set("FullYear", m, k - k % c);
                    p === e.week && (k = g.get("Day", m), g.set("Date", m, g.get("Date", m) - k + n + (k < n ? -7 : 0)));
                    k = g.get("FullYear", m);
                    n = g.get("Month", m);
                    var K = g.get("Date", m), w = g.get("Hours", m);
                    q = m.getTime();
                    g.variableTimezone && (x = v - q > 4 * e.month || g.getTimezoneOffset(q) !== g.getTimezoneOffset(v));
                    q = m.getTime();
                    for (m = 1; q < v; ) d.push(q), q = p === e.year ? g.makeTime(k + m * c, 0) : p === e.month ? g.makeTime(k, n + m * c) : !x || p !== e.day && p !== e.week ? x && p === e.hour && 1 < c ? g.makeTime(k, n, K, w + m * c) : q + p * c : g.makeTime(k, n, K + m * c * (p === e.day ? 1 : 7)), 
                    m++;
                    d.push(q);
                    p <= e.hour && 1e4 > d.length && d.forEach(function(a) {
                        0 === a % 18e5 && "000000000" === g.dateFormat("%H%M%S%L", a) && (b[a] = "day");
                    });
                }
                d.info = H(a, {
                    higherRanks: b,
                    totalRange: p * c
                });
                return d;
            }
        };
    });
    J(G, "parts/Options.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.color, H = a.merge;
        a.defaultOptions = {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            symbols: [ "circle", "diamond", "square", "triangle", "triangle-down" ],
            lang: {
                loading: "Loading...",
                months: "January February March April May June July August September October November December".split(" "),
                shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                decimalPoint: ".",
                numericSymbols: "kMGTPE".split(""),
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1",
                thousandsSep: " "
            },
            global: {},
            time: a.Time.prototype.defaultOptions,
            chart: {
                styledMode: !1,
                borderRadius: 0,
                colorCount: 10,
                defaultSeriesType: "line",
                ignoreHiddenSeries: !0,
                spacing: [ 10, 10, 15, 10 ],
                resetZoomButton: {
                    theme: {
                        zIndex: 6
                    },
                    position: {
                        align: "right",
                        x: -10,
                        y: 10
                    }
                },
                width: null,
                height: null,
                borderColor: "#335cad",
                backgroundColor: "#ffffff",
                plotBorderColor: "#cccccc"
            },
            title: {
                text: "Chart title",
                align: "center",
                margin: 15,
                widthAdjust: -44
            },
            subtitle: {
                text: "",
                align: "center",
                widthAdjust: -44
            },
            plotOptions: {},
            labels: {
                style: {
                    position: "absolute",
                    color: "#333333"
                }
            },
            legend: {
                enabled: !0,
                align: "center",
                alignColumns: !0,
                layout: "horizontal",
                labelFormatter: function() {
                    return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                    activeColor: "#003399",
                    inactiveColor: "#cccccc"
                },
                itemStyle: {
                    color: "#333333",
                    cursor: "pointer",
                    fontSize: "12px",
                    fontWeight: "bold",
                    textOverflow: "ellipsis"
                },
                itemHoverStyle: {
                    color: "#000000"
                },
                itemHiddenStyle: {
                    color: "#cccccc"
                },
                shadow: !1,
                itemCheckboxStyle: {
                    position: "absolute",
                    width: "13px",
                    height: "13px"
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: {
                    style: {
                        fontWeight: "bold"
                    }
                }
            },
            loading: {
                labelStyle: {
                    fontWeight: "bold",
                    position: "relative",
                    top: "45%"
                },
                style: {
                    position: "absolute",
                    backgroundColor: "#ffffff",
                    opacity: .5,
                    textAlign: "center"
                }
            },
            tooltip: {
                enabled: !0,
                animation: a.svg,
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: "%A, %b %e, %H:%M:%S.%L",
                    second: "%A, %b %e, %H:%M:%S",
                    minute: "%A, %b %e, %H:%M",
                    hour: "%A, %b %e, %H:%M",
                    day: "%A, %b %e, %Y",
                    week: "Week from %A, %b %e, %Y",
                    month: "%B %Y",
                    year: "%Y"
                },
                footerFormat: "",
                padding: 8,
                snap: a.isTouchDevice ? 25 : 10,
                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}"></span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: E("#f7f7f7").setOpacity(.85).get(),
                borderWidth: 1,
                shadow: !0,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "12px",
                    pointerEvents: "none",
                    whiteSpace: "nowrap"
                }
            },
            credits: {
                enabled: !0,
                href: "https://www.highcharts.com?credits",
                position: {
                    align: "right",
                    x: -10,
                    verticalAlign: "bottom",
                    y: -5
                },
                style: {
                    cursor: "pointer",
                    color: "#999999",
                    fontSize: "9px"
                },
                text: "Highcharts.com"
            }
        };
        a.setOptions = function(B) {
            a.defaultOptions = H(!0, a.defaultOptions, B);
            a.time.update(H(a.defaultOptions.global, a.defaultOptions.time), !1);
            return a.defaultOptions;
        };
        a.getOptions = function() {
            return a.defaultOptions;
        };
        a.defaultPlotOptions = a.defaultOptions.plotOptions;
        a.time = new a.Time(H(a.defaultOptions.global, a.defaultOptions.time));
        a.dateFormat = function(B, h, e) {
            return a.time.dateFormat(B, h, e);
        };
        "";
    });
    J(G, "parts/Tick.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.correctFloat, H = a.defined, B = a.destroyObjectProperties, h = a.fireEvent, e = a.isNumber, q = a.merge, t = a.pick, u = a.deg2rad;
        a.Tick = function(a, e, g, d, m) {
            this.axis = a;
            this.pos = e;
            this.type = g || "";
            this.isNewLabel = this.isNew = !0;
            this.parameters = m || {};
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            g || d || this.addLabel();
        };
        a.Tick.prototype = {
            addLabel: function() {
                var e = this, n = e.axis, g = n.options, d = n.chart, m = n.categories, b = n.names, k = e.pos, p = t(e.options && e.options.labels, g.labels), c = n.tickPositions, x = k === c[0], h = k === c[c.length - 1], m = this.parameters.category || (m ? t(m[k], b[k], k) : k), w = e.label, c = c.info, F, C, l, D;
                n.isDatetimeAxis && c && (C = d.time.resolveDTLFormat(g.dateTimeLabelFormats[!g.grid && c.higherRanks[k] || c.unitName]), 
                F = C.main);
                e.isFirst = x;
                e.isLast = h;
                e.formatCtx = {
                    axis: n,
                    chart: d,
                    isFirst: x,
                    isLast: h,
                    dateTimeLabelFormat: F,
                    tickPositionInfo: c,
                    value: n.isLog ? E(n.lin2log(m)) : m,
                    pos: k
                };
                g = n.labelFormatter.call(e.formatCtx, this.formatCtx);
                if (D = C && C.list) e.shortenLabel = function() {
                    for (l = 0; l < D.length; l++) if (w.attr({
                        text: n.labelFormatter.call(a.extend(e.formatCtx, {
                            dateTimeLabelFormat: D[l]
                        }))
                    }), w.getBBox().width < n.getSlotWidth(e) - 2 * t(p.padding, 5)) return;
                    w.attr({
                        text: ""
                    });
                };
                if (H(w)) w && w.textStr !== g && (!w.textWidth || p.style && p.style.width || w.styles.width || w.css({
                    width: null
                }), w.attr({
                    text: g
                }), w.textPxLength = w.getBBox().width); else {
                    if (e.label = w = H(g) && p.enabled ? d.renderer.text(g, 0, 0, p.useHTML).add(n.labelGroup) : null) d.styledMode || w.css(q(p.style)), 
                    w.textPxLength = w.getBBox().width;
                    e.rotation = 0;
                }
            },
            getLabelSize: function() {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            },
            handleOverflow: function(a) {
                var e = this.axis, g = e.options.labels, d = a.x, m = e.chart.chartWidth, b = e.chart.spacing, k = t(e.labelLeft, Math.min(e.pos, b[3])), b = t(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, m - b[1])), p = this.label, c = this.rotation, x = {
                    left: 0,
                    center: .5,
                    right: 1
                }[e.labelAlign || p.attr("align")], h = p.getBBox().width, w = e.getSlotWidth(this), F = w, C = 1, l, D = {};
                if (c || "justify" !== t(g.overflow, "justify")) 0 > c && d - x * h < k ? l = Math.round(d / Math.cos(c * u) - k) : 0 < c && d + x * h > b && (l = Math.round((m - d) / Math.cos(c * u))); else if (m = d + (1 - x) * h, 
                d - x * h < k ? F = a.x + F * (1 - x) - k : m > b && (F = b - a.x + F * x, C = -1), 
                F = Math.min(w, F), F < w && "center" === e.labelAlign && (a.x += C * (w - F - x * (w - Math.min(h, F)))), 
                h > F || e.autoRotation && (p.styles || {}).width) l = F;
                l && (this.shortenLabel ? this.shortenLabel() : (D.width = Math.floor(l), (g.style || {}).textOverflow || (D.textOverflow = "ellipsis"), 
                p.css(D)));
            },
            getPosition: function(e, n, g, d) {
                var m = this.axis, b = m.chart, k = d && b.oldChartHeight || b.chartHeight;
                e = {
                    x: e ? a.correctFloat(m.translate(n + g, null, null, d) + m.transB) : m.left + m.offset + (m.opposite ? (d && b.oldChartWidth || b.chartWidth) - m.right - m.left : 0),
                    y: e ? k - m.bottom + m.offset - (m.opposite ? m.height : 0) : a.correctFloat(k - m.translate(n + g, null, null, d) - m.transB)
                };
                e.y = Math.max(Math.min(e.y, 1e5), -1e5);
                h(this, "afterGetPosition", {
                    pos: e
                });
                return e;
            },
            getLabelPosition: function(a, e, g, d, m, b, k, p) {
                var c = this.axis, x = c.transA, n = c.reversed, w = c.staggerLines, F = c.tickRotCorr || {
                    x: 0,
                    y: 0
                }, C = m.y, l = d || c.reserveSpaceDefault ? 0 : -c.labelOffset * ("center" === c.labelAlign ? .5 : 1), D = {};
                H(C) || (C = 0 === c.side ? g.rotation ? -8 : -g.getBBox().height : 2 === c.side ? F.y + 8 : Math.cos(g.rotation * u) * (F.y - g.getBBox(!1, 0).height / 2));
                a = a + m.x + l + F.x - (b && d ? b * x * (n ? -1 : 1) : 0);
                e = e + C - (b && !d ? b * x * (n ? 1 : -1) : 0);
                w && (g = k / (p || 1) % w, c.opposite && (g = w - g - 1), e += c.labelOffset / w * g);
                D.x = a;
                D.y = Math.round(e);
                h(this, "afterGetLabelPosition", {
                    pos: D,
                    tickmarkOffset: b,
                    index: k
                });
                return D;
            },
            getMarkPath: function(a, e, g, d, m, b) {
                return b.crispLine([ "M", a, e, "L", a + (m ? 0 : -g), e + (m ? g : 0) ], d);
            },
            renderGridLine: function(a, e, g) {
                var d = this.axis, m = d.options, b = this.gridLine, k = {}, p = this.pos, c = this.type, x = t(this.tickmarkOffset, d.tickmarkOffset), n = d.chart.renderer, w = c ? c + "Grid" : "grid", h = m[w + "LineWidth"], C = m[w + "LineColor"], m = m[w + "LineDashStyle"];
                b || (d.chart.styledMode || (k.stroke = C, k["stroke-width"] = h, m && (k.dashstyle = m)), 
                c || (k.zIndex = 1), a && (e = 0), this.gridLine = b = n.path().attr(k).addClass("highcharts-" + (c ? c + "-" : "") + "grid-line").add(d.gridGroup));
                if (b && (g = d.getPlotLinePath({
                    value: p + x,
                    lineWidth: b.strokeWidth() * g,
                    force: "pass",
                    old: a
                }))) b[a || this.isNew ? "attr" : "animate"]({
                    d: g,
                    opacity: e
                });
            },
            renderMark: function(a, e, g) {
                var d = this.axis, m = d.options, b = d.chart.renderer, k = this.type, p = k ? k + "Tick" : "tick", c = d.tickSize(p), x = this.mark, n = !x, w = a.x;
                a = a.y;
                var h = t(m[p + "Width"], !k && d.isXAxis ? 1 : 0), m = m[p + "Color"];
                c && (d.opposite && (c[0] = -c[0]), n && (this.mark = x = b.path().addClass("highcharts-" + (k ? k + "-" : "") + "tick").add(d.axisGroup), 
                d.chart.styledMode || x.attr({
                    stroke: m,
                    "stroke-width": h
                })), x[n ? "attr" : "animate"]({
                    d: this.getMarkPath(w, a, c[0], x.strokeWidth() * g, d.horiz, b),
                    opacity: e
                }));
            },
            renderLabel: function(a, n, g, d) {
                var m = this.axis, b = m.horiz, k = m.options, p = this.label, c = k.labels, x = c.step, m = t(this.tickmarkOffset, m.tickmarkOffset), h = !0, w = a.x;
                a = a.y;
                p && e(w) && (p.xy = a = this.getLabelPosition(w, a, p, b, c, m, d, x), this.isFirst && !this.isLast && !t(k.showFirstLabel, 1) || this.isLast && !this.isFirst && !t(k.showLastLabel, 1) ? h = !1 : !b || c.step || c.rotation || n || 0 === g || this.handleOverflow(a), 
                x && d % x && (h = !1), h && e(a.y) ? (a.opacity = g, p[this.isNewLabel ? "attr" : "animate"](a), 
                this.isNewLabel = !1) : (p.attr("y", -9999), this.isNewLabel = !0));
            },
            render: function(e, n, g) {
                var d = this.axis, m = d.horiz, b = this.pos, k = t(this.tickmarkOffset, d.tickmarkOffset), b = this.getPosition(m, b, k, n), k = b.x, p = b.y, d = m && k === d.pos + d.len || !m && p === d.pos ? -1 : 1;
                g = t(g, 1);
                this.isActive = !0;
                this.renderGridLine(n, g, d);
                this.renderMark(b, g, d);
                this.renderLabel(b, n, g, e);
                this.isNew = !1;
                a.fireEvent(this, "afterRender");
            },
            destroy: function() {
                B(this, this.axis);
            }
        };
    });
    J(G, "parts/Axis.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.animObject, B = a.arrayMax, h = a.arrayMin, e = a.color, q = a.correctFloat, t = a.defaultOptions, u = a.defined, v = a.deg2rad, n = a.destroyObjectProperties, g = a.extend, d = a.fireEvent, m = a.format, b = a.getMagnitude, k = a.isArray, p = a.isNumber, c = a.isString, x = a.merge, K = a.normalizeTickInterval, w = a.objectEach, F = a.pick, C = a.removeEvent, l = a.seriesTypes, D = a.splat, A = a.syncTimeout, z = a.Tick, I = function() {
            this.init.apply(this, arguments);
        };
        a.extend(I.prototype, {
            defaultOptions: {
                dateTimeLabelFormats: {
                    millisecond: {
                        main: "%H:%M:%S.%L",
                        range: !1
                    },
                    second: {
                        main: "%H:%M:%S",
                        range: !1
                    },
                    minute: {
                        main: "%H:%M",
                        range: !1
                    },
                    hour: {
                        main: "%H:%M",
                        range: !1
                    },
                    day: {
                        main: "%e. %b"
                    },
                    week: {
                        main: "%e. %b"
                    },
                    month: {
                        main: "%b '%y"
                    },
                    year: {
                        main: "%Y"
                    }
                },
                endOnTick: !1,
                labels: {
                    enabled: !0,
                    indentation: 10,
                    x: 0,
                    style: {
                        color: "#666666",
                        cursor: "default",
                        fontSize: "11px"
                    }
                },
                maxPadding: .01,
                minorTickLength: 2,
                minorTickPosition: "outside",
                minPadding: .01,
                showEmpty: !0,
                startOfWeek: 1,
                startOnTick: !1,
                tickLength: 10,
                tickPixelInterval: 100,
                tickmarkPlacement: "between",
                tickPosition: "outside",
                title: {
                    align: "middle",
                    style: {
                        color: "#666666"
                    }
                },
                type: "linear",
                minorGridLineColor: "#f2f2f2",
                minorGridLineWidth: 1,
                minorTickColor: "#999999",
                lineColor: "#ccd6eb",
                lineWidth: 1,
                gridLineColor: "#e6e6e6",
                tickColor: "#ccd6eb"
            },
            defaultYAxisOptions: {
                endOnTick: !0,
                maxPadding: .05,
                minPadding: .05,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: {
                    x: -8
                },
                startOnTick: !0,
                title: {
                    rotation: 270,
                    text: "Values"
                },
                stackLabels: {
                    allowOverlap: !1,
                    enabled: !1,
                    formatter: function() {
                        return a.numberFormat(this.total, -1);
                    },
                    style: {
                        color: "#000000",
                        fontSize: "11px",
                        fontWeight: "bold",
                        textOutline: "1px contrast"
                    }
                },
                gridLineWidth: 1,
                lineWidth: 0
            },
            defaultLeftAxisOptions: {
                labels: {
                    x: -15
                },
                title: {
                    rotation: 270
                }
            },
            defaultRightAxisOptions: {
                labels: {
                    x: 15
                },
                title: {
                    rotation: 90
                }
            },
            defaultBottomAxisOptions: {
                labels: {
                    autoRotation: [ -45 ],
                    x: 0
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            },
            defaultTopAxisOptions: {
                labels: {
                    autoRotation: [ -45 ],
                    x: 0
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            },
            init: function(f, b) {
                var c = b.isX, r = this;
                r.chart = f;
                r.horiz = f.inverted && !r.isZAxis ? !c : c;
                r.isXAxis = c;
                r.coll = r.coll || (c ? "xAxis" : "yAxis");
                d(this, "init", {
                    userOptions: b
                });
                r.opposite = b.opposite;
                r.side = b.side || (r.horiz ? r.opposite ? 0 : 2 : r.opposite ? 1 : 3);
                r.setOptions(b);
                var l = this.options, p = l.type;
                r.labelFormatter = l.labels.formatter || r.defaultLabelFormatter;
                r.userOptions = b;
                r.minPixelPadding = 0;
                r.reversed = l.reversed;
                r.visible = !1 !== l.visible;
                r.zoomEnabled = !1 !== l.zoomEnabled;
                r.hasNames = "category" === p || !0 === l.categories;
                r.categories = l.categories || r.hasNames;
                r.names || (r.names = [], r.names.keys = {});
                r.plotLinesAndBandsGroups = {};
                r.isLog = "logarithmic" === p;
                r.isDatetimeAxis = "datetime" === p;
                r.positiveValuesOnly = r.isLog && !r.allowNegativeLog;
                r.isLinked = u(l.linkedTo);
                r.ticks = {};
                r.labelEdge = [];
                r.minorTicks = {};
                r.plotLinesAndBands = [];
                r.alternateBands = {};
                r.len = 0;
                r.minRange = r.userMinRange = l.minRange || l.maxZoom;
                r.range = l.range;
                r.offset = l.offset || 0;
                r.stacks = {};
                r.oldStacks = {};
                r.stacksTouched = 0;
                r.max = null;
                r.min = null;
                r.crosshair = F(l.crosshair, D(f.options.tooltip.crosshairs)[c ? 0 : 1], !1);
                b = r.options.events;
                -1 === f.axes.indexOf(r) && (c ? f.axes.splice(f.xAxis.length, 0, r) : f.axes.push(r), 
                f[r.coll].push(r));
                r.series = r.series || [];
                f.inverted && !r.isZAxis && c && void 0 === r.reversed && (r.reversed = !0);
                w(b, function(f, b) {
                    a.isFunction(f) && E(r, b, f);
                });
                r.lin2log = l.linearToLogConverter || r.lin2log;
                r.isLog && (r.val2lin = r.log2lin, r.lin2val = r.lin2log);
                d(this, "afterInit");
            },
            setOptions: function(a) {
                this.options = x(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [ this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions ][this.side], x(t[this.coll], a));
                d(this, "afterSetOptions", {
                    userOptions: a
                });
            },
            defaultLabelFormatter: function() {
                var f = this.axis, b = this.value, c = f.chart.time, d = f.categories, l = this.dateTimeLabelFormat, p = t.lang, k = p.numericSymbols, p = p.numericSymbolMagnitude || 1e3, e = k && k.length, g, A = f.options.labels.format, f = f.isLog ? Math.abs(b) : f.tickInterval;
                if (A) g = m(A, this, c); else if (d) g = b; else if (l) g = c.dateFormat(l, b); else if (e && 1e3 <= f) for (;e-- && void 0 === g; ) c = Math.pow(p, e + 1), 
                f >= c && 0 === 10 * b % c && null !== k[e] && 0 !== b && (g = a.numberFormat(b / c, -1) + k[e]);
                void 0 === g && (g = 1e4 <= Math.abs(b) ? a.numberFormat(b, -1) : a.numberFormat(b, -1, void 0, ""));
                return g;
            },
            getSeriesExtremes: function() {
                var a = this, b = a.chart, c;
                d(this, "getSeriesExtremes", null, function() {
                    a.hasVisibleSeries = !1;
                    a.dataMin = a.dataMax = a.threshold = null;
                    a.softThreshold = !a.isXAxis;
                    a.buildStacks && a.buildStacks();
                    a.series.forEach(function(f) {
                        if (f.visible || !b.options.chart.ignoreHiddenSeries) {
                            var r = f.options, d = r.threshold, l, k;
                            a.hasVisibleSeries = !0;
                            a.positiveValuesOnly && 0 >= d && (d = null);
                            if (a.isXAxis) r = f.xData, r.length && (c = f.getXExtremes(r), l = c.min, k = c.max, 
                            p(l) || l instanceof Date || (r = r.filter(p), c = f.getXExtremes(r), l = c.min, 
                            k = c.max), r.length && (a.dataMin = Math.min(F(a.dataMin, l), l), a.dataMax = Math.max(F(a.dataMax, k), k))); else if (f.getExtremes(), 
                            k = f.dataMax, l = f.dataMin, u(l) && u(k) && (a.dataMin = Math.min(F(a.dataMin, l), l), 
                            a.dataMax = Math.max(F(a.dataMax, k), k)), u(d) && (a.threshold = d), !r.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
                        }
                    });
                });
                d(this, "afterGetSeriesExtremes");
            },
            translate: function(a, b, c, d, l, k) {
                var f = this.linkedParent || this, r = 1, e = 0, g = d ? f.oldTransA : f.transA;
                d = d ? f.oldMin : f.min;
                var m = f.minPixelPadding;
                l = (f.isOrdinal || f.isBroken || f.isLog && l) && f.lin2val;
                g || (g = f.transA);
                c && (r *= -1, e = f.len);
                f.reversed && (r *= -1, e -= r * (f.sector || f.len));
                b ? (a = (a * r + e - m) / g + d, l && (a = f.lin2val(a))) : (l && (a = f.val2lin(a)), 
                a = p(d) ? r * (a - d) * g + e + r * m + (p(k) ? g * k : 0) : void 0);
                return a;
            },
            toPixels: function(a, b) {
                return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
            },
            toValue: function(a, b) {
                return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
            },
            getPlotLinePath: function(a) {
                var f = this, b = f.chart, c = f.left, l = f.top, k = a.old, e = a.value, g = a.translatedValue, m = a.lineWidth, A = a.force, x, D, n, w, z = k && b.oldChartHeight || b.chartHeight, h = k && b.oldChartWidth || b.chartWidth, C, I = f.transB, q = function(a, f, b) {
                    if ("pass" !== A && a < f || a > b) A ? a = Math.min(Math.max(f, a), b) : C = !0;
                    return a;
                };
                a = {
                    value: e,
                    lineWidth: m,
                    old: k,
                    force: A,
                    acrossPanes: a.acrossPanes,
                    translatedValue: g
                };
                d(this, "getPlotLinePath", a, function(a) {
                    g = F(g, f.translate(e, null, null, k));
                    g = Math.min(Math.max(-1e5, g), 1e5);
                    x = n = Math.round(g + I);
                    D = w = Math.round(z - g - I);
                    p(g) ? f.horiz ? (D = l, w = z - f.bottom, x = n = q(x, c, c + f.width)) : (x = c, 
                    n = h - f.right, D = w = q(D, l, l + f.height)) : (C = !0, A = !1);
                    a.path = C && !A ? null : b.renderer.crispLine([ "M", x, D, "L", n, w ], m || 1);
                });
                return a.path;
            },
            getLinearTickPositions: function(a, b, c) {
                var f, r = q(Math.floor(b / a) * a);
                c = q(Math.ceil(c / a) * a);
                var d = [], l;
                q(r + a) === r && (l = 20);
                if (this.single) return [ b ];
                for (b = r; b <= c; ) {
                    d.push(b);
                    b = q(b + a, l);
                    if (b === f) break;
                    f = b;
                }
                return d;
            },
            getMinorTickInterval: function() {
                var a = this.options;
                return !0 === a.minorTicks ? F(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
            },
            getMinorTickPositions: function() {
                var a = this, b = a.options, c = a.tickPositions, d = a.minorTickInterval, l = [], p = a.pointRangePadding || 0, k = a.min - p, p = a.max + p, g = p - k;
                if (g && g / d < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function(f, b, c) {
                    b && l.push.apply(l, a.getLogTickPositions(d, c[b - 1], c[b], !0));
                }); else if (a.isDatetimeAxis && "auto" === this.getMinorTickInterval()) l = l.concat(a.getTimeTicks(a.normalizeTimeTickInterval(d), k, p, b.startOfWeek)); else for (b = k + (c[0] - k) % d; b <= p && b !== l[0]; b += d) l.push(b);
                0 !== l.length && a.trimTicks(l);
                return l;
            },
            adjustForMinRange: function() {
                var a = this.options, b = this.min, c = this.max, d, l, p, k, g, e, m, A;
                this.isXAxis && void 0 === this.minRange && !this.isLog && (u(a.min) || u(a.max) ? this.minRange = null : (this.series.forEach(function(a) {
                    e = a.xData;
                    for (k = m = a.xIncrement ? 1 : e.length - 1; 0 < k; k--) if (g = e[k] - e[k - 1], 
                    void 0 === p || g < p) p = g;
                }), this.minRange = Math.min(5 * p, this.dataMax - this.dataMin)));
                c - b < this.minRange && (l = this.dataMax - this.dataMin >= this.minRange, A = this.minRange, 
                d = (A - c + b) / 2, d = [ b - d, F(a.min, b - d) ], l && (d[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), 
                b = B(d), c = [ b + A, F(a.max, b + A) ], l && (c[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), 
                c = h(c), c - b < A && (d[0] = c - A, d[1] = F(a.min, c - A), b = B(d)));
                this.min = b;
                this.max = c;
            },
            getClosest: function() {
                var a;
                this.categories ? a = 1 : this.series.forEach(function(f) {
                    var b = f.closestPointRange, c = f.visible || !f.chart.options.chart.ignoreHiddenSeries;
                    !f.noSharedTooltip && u(b) && c && (a = u(a) ? Math.min(a, b) : b);
                });
                return a;
            },
            nameToX: function(a) {
                var f = k(this.categories), b = f ? this.categories : this.names, c = a.options.x, d;
                a.series.requireSorting = !1;
                u(c) || (c = !1 === this.options.uniqueNames ? a.series.autoIncrement() : f ? b.indexOf(a.name) : F(b.keys[a.name], -1));
                -1 === c ? f || (d = b.length) : d = c;
                void 0 !== d && (this.names[d] = a.name, this.names.keys[a.name] = d);
                return d;
            },
            updateNames: function() {
                var a = this, b = this.names;
                0 < b.length && (Object.keys(b.keys).forEach(function(a) {
                    delete b.keys[a];
                }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function(f) {
                    f.xIncrement = null;
                    if (!f.points || f.isDirtyData) a.max = Math.max(a.max, f.xData.length - 1), f.processData(), 
                    f.generatePoints();
                    f.data.forEach(function(b, c) {
                        var r;
                        b && b.options && void 0 !== b.name && (r = a.nameToX(b), void 0 !== r && r !== b.x && (b.x = r, 
                        f.xData[c] = r));
                    });
                }));
            },
            setAxisTranslation: function(a) {
                var f = this, b = f.max - f.min, p = f.axisPointRange || 0, k, g = 0, e = 0, A = f.linkedParent, m = !!f.categories, x = f.transA, D = f.isXAxis;
                if (D || m || p) k = f.getClosest(), A ? (g = A.minPointOffset, e = A.pointRangePadding) : f.series.forEach(function(a) {
                    var b = m ? 1 : D ? F(a.options.pointRange, k, 0) : f.axisPointRange || 0, r = a.options.pointPlacement;
                    p = Math.max(p, b);
                    if (!f.single || m) a = l.xrange && a instanceof l.xrange ? !D : D, g = Math.max(g, a && c(r) ? 0 : b / 2), 
                    e = Math.max(e, a && "on" === r ? 0 : b);
                }), A = f.ordinalSlope && k ? f.ordinalSlope / k : 1, f.minPointOffset = g *= A, 
                f.pointRangePadding = e *= A, f.pointRange = Math.min(p, b), D && (f.closestPointRange = k);
                a && (f.oldTransA = x);
                f.translationSlope = f.transA = x = f.staticScale || f.len / (b + e || 1);
                f.transB = f.horiz ? f.left : f.bottom;
                f.minPixelPadding = x * g;
                d(this, "afterSetAxisTranslation");
            },
            minFromRange: function() {
                return this.max - this.range;
            },
            setTickInterval: function(f) {
                var c = this, l = c.chart, k = c.options, g = c.isLog, e = c.isDatetimeAxis, A = c.isXAxis, m = c.isLinked, x = k.maxPadding, D = k.minPadding, n, w = k.tickInterval, z = k.tickPixelInterval, h = c.categories, C = p(c.threshold) ? c.threshold : null, I = c.softThreshold, t, v, B;
                e || h || m || this.getTickAmount();
                v = F(c.userMin, k.min);
                B = F(c.userMax, k.max);
                m ? (c.linkedParent = l[c.coll][k.linkedTo], n = c.linkedParent.getExtremes(), c.min = F(n.min, n.dataMin), 
                c.max = F(n.max, n.dataMax), k.type !== c.linkedParent.options.type && a.error(11, 1, l)) : (!I && u(C) && (c.dataMin >= C ? (n = C, 
                D = 0) : c.dataMax <= C && (t = C, x = 0)), c.min = F(v, n, c.dataMin), c.max = F(B, t, c.dataMax));
                g && (c.positiveValuesOnly && !f && 0 >= Math.min(c.min, F(c.dataMin, c.min)) && a.error(10, 1, l), 
                c.min = q(c.log2lin(c.min), 15), c.max = q(c.log2lin(c.max), 15));
                c.range && u(c.max) && (c.userMin = c.min = v = Math.max(c.dataMin, c.minFromRange()), 
                c.userMax = B = c.max, c.range = null);
                d(c, "foundExtremes");
                c.beforePadding && c.beforePadding();
                c.adjustForMinRange();
                !(h || c.axisPointRange || c.usePercentage || m) && u(c.min) && u(c.max) && (l = c.max - c.min) && (!u(v) && D && (c.min -= l * D), 
                !u(B) && x && (c.max += l * x));
                p(k.softMin) && !p(c.userMin) && k.softMin < c.min && (c.min = v = k.softMin);
                p(k.softMax) && !p(c.userMax) && k.softMax > c.max && (c.max = B = k.softMax);
                p(k.floor) && (c.min = Math.min(Math.max(c.min, k.floor), Number.MAX_VALUE));
                p(k.ceiling) && (c.max = Math.max(Math.min(c.max, k.ceiling), F(c.userMax, -Number.MAX_VALUE)));
                I && u(c.dataMin) && (C = C || 0, !u(v) && c.min < C && c.dataMin >= C ? c.min = c.options.minRange ? Math.min(C, c.max - c.minRange) : C : !u(B) && c.max > C && c.dataMax <= C && (c.max = c.options.minRange ? Math.max(C, c.min + c.minRange) : C));
                c.tickInterval = c.min === c.max || void 0 === c.min || void 0 === c.max ? 1 : m && !w && z === c.linkedParent.options.tickPixelInterval ? w = c.linkedParent.tickInterval : F(w, this.tickAmount ? (c.max - c.min) / Math.max(this.tickAmount - 1, 1) : void 0, h ? 1 : (c.max - c.min) * z / Math.max(c.len, z));
                A && !f && c.series.forEach(function(a) {
                    a.processData(c.min !== c.oldMin || c.max !== c.oldMax);
                });
                c.setAxisTranslation(!0);
                c.beforeSetTickPositions && c.beforeSetTickPositions();
                c.postProcessTickInterval && (c.tickInterval = c.postProcessTickInterval(c.tickInterval));
                c.pointRange && !w && (c.tickInterval = Math.max(c.pointRange, c.tickInterval));
                f = F(k.minTickInterval, c.isDatetimeAxis && c.closestPointRange);
                !w && c.tickInterval < f && (c.tickInterval = f);
                e || g || w || (c.tickInterval = K(c.tickInterval, null, b(c.tickInterval), F(k.allowDecimals, !(.5 < c.tickInterval && 5 > c.tickInterval && 1e3 < c.max && 9999 > c.max)), !!this.tickAmount));
                this.tickAmount || (c.tickInterval = c.unsquish());
                this.setTickPositions();
            },
            setTickPositions: function() {
                var f = this.options, c, b = f.tickPositions;
                c = this.getMinorTickInterval();
                var l = f.tickPositioner, k = f.startOnTick, p = f.endOnTick;
                this.tickmarkOffset = this.categories && "between" === f.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
                this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
                this.single = this.min === this.max && u(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== f.allowDecimals);
                this.tickPositions = c = b && b.slice();
                !c && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (c = [ this.min, this.max ], 
                a.error(19, !1, this.chart)) : c = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, f.units), this.min, this.max, f.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), 
                c.length > this.len && (c = [ c[0], c.pop() ], c[0] === c[1] && (c.length = 1)), 
                this.tickPositions = c, l && (l = l.apply(this, [ this.min, this.max ]))) && (this.tickPositions = c = l);
                this.paddedTicks = c.slice(0);
                this.trimTicks(c, k, p);
                this.isLinked || (this.single && 2 > c.length && !this.categories && (this.min -= .5, 
                this.max += .5), b || l || this.adjustTickAmount());
                d(this, "afterSetTickPositions");
            },
            trimTicks: function(a, c, b) {
                var f = a[0], l = a[a.length - 1], k = this.minPointOffset || 0;
                d(this, "trimTicks");
                if (!this.isLinked) {
                    if (c && -Infinity !== f) this.min = f; else for (;this.min - k > a[0]; ) a.shift();
                    if (b) this.max = l; else for (;this.max + k < a[a.length - 1]; ) a.pop();
                    0 === a.length && u(f) && !this.options.tickPositions && a.push((l + f) / 2);
                }
            },
            alignToOthers: function() {
                var a = {}, c, b = this.options;
                !1 === this.chart.options.chart.alignTicks || !1 === b.alignTicks || !1 === b.startOnTick || !1 === b.endOnTick || this.isLog || this.chart[this.coll].forEach(function(f) {
                    var b = f.options, b = [ f.horiz ? b.left : b.top, b.width, b.height, b.pane ].join();
                    f.series.length && (a[b] ? c = !0 : a[b] = 1);
                });
                return c;
            },
            getTickAmount: function() {
                var a = this.options, c = a.tickAmount, b = a.tickPixelInterval;
                !u(a.tickInterval) && this.len < b && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (c = 2);
                !c && this.alignToOthers() && (c = Math.ceil(this.len / b) + 1);
                4 > c && (this.finalTickAmt = c, c = 5);
                this.tickAmount = c;
            },
            adjustTickAmount: function() {
                var a = this.options, c = this.tickInterval, b = this.tickPositions, d = this.tickAmount, l = this.finalTickAmt, k = b && b.length, p = F(this.threshold, this.softThreshold ? 0 : null), g;
                if (this.hasData()) {
                    if (k < d) {
                        for (g = this.min; b.length < d; ) b.length % 2 || g === p ? b.push(q(b[b.length - 1] + c)) : b.unshift(q(b[0] - c));
                        this.transA *= (k - 1) / (d - 1);
                        this.min = a.startOnTick ? b[0] : Math.min(this.min, b[0]);
                        this.max = a.endOnTick ? b[b.length - 1] : Math.max(this.max, b[b.length - 1]);
                    } else k > d && (this.tickInterval *= 2, this.setTickPositions());
                    if (u(l)) {
                        for (c = a = b.length; c--; ) (3 === l && 1 === c % 2 || 2 >= l && 0 < c && c < a - 1) && b.splice(c, 1);
                        this.finalTickAmt = void 0;
                    }
                }
            },
            setScale: function() {
                var a = this.series.some(function(a) {
                    return a.isDirtyData || a.isDirty || a.xAxis.isDirty;
                }), c;
                this.oldMin = this.min;
                this.oldMax = this.max;
                this.oldAxisLength = this.len;
                this.setAxisSize();
                (c = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), 
                this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, 
                this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = c || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
                d(this, "afterSetScale");
            },
            setExtremes: function(a, c, b, l, k) {
                var f = this, p = f.chart;
                b = F(b, !0);
                f.series.forEach(function(a) {
                    delete a.kdTree;
                });
                k = g(k, {
                    min: a,
                    max: c
                });
                d(f, "setExtremes", k, function() {
                    f.userMin = a;
                    f.userMax = c;
                    f.eventArgs = k;
                    b && p.redraw(l);
                });
            },
            zoom: function(a, c) {
                var f = this.dataMin, b = this.dataMax, l = this.options, k = Math.min(f, F(l.min, f)), p = Math.max(b, F(l.max, b));
                a = {
                    newMin: a,
                    newMax: c
                };
                d(this, "zoom", a, function(a) {
                    var c = a.newMin, d = a.newMax;
                    if (c !== this.min || d !== this.max) this.allowZoomOutside || (u(f) && (c < k && (c = k), 
                    c > p && (c = p)), u(b) && (d < k && (d = k), d > p && (d = p))), this.displayBtn = void 0 !== c || void 0 !== d, 
                    this.setExtremes(c, d, !1, void 0, {
                        trigger: "zoom"
                    });
                    a.zoomed = !0;
                });
                return a.zoomed;
            },
            setAxisSize: function() {
                var f = this.chart, c = this.options, b = c.offsets || [ 0, 0, 0, 0 ], d = this.horiz, l = this.width = Math.round(a.relativeLength(F(c.width, f.plotWidth - b[3] + b[1]), f.plotWidth)), k = this.height = Math.round(a.relativeLength(F(c.height, f.plotHeight - b[0] + b[2]), f.plotHeight)), p = this.top = Math.round(a.relativeLength(F(c.top, f.plotTop + b[0]), f.plotHeight, f.plotTop)), c = this.left = Math.round(a.relativeLength(F(c.left, f.plotLeft + b[3]), f.plotWidth, f.plotLeft));
                this.bottom = f.chartHeight - k - p;
                this.right = f.chartWidth - l - c;
                this.len = Math.max(d ? l : k, 0);
                this.pos = d ? c : p;
            },
            getExtremes: function() {
                var a = this.isLog;
                return {
                    min: a ? q(this.lin2log(this.min)) : this.min,
                    max: a ? q(this.lin2log(this.max)) : this.max,
                    dataMin: this.dataMin,
                    dataMax: this.dataMax,
                    userMin: this.userMin,
                    userMax: this.userMax
                };
            },
            getThreshold: function(a) {
                var f = this.isLog, c = f ? this.lin2log(this.min) : this.min, f = f ? this.lin2log(this.max) : this.max;
                null === a || -Infinity === a ? a = c : Infinity === a ? a = f : c > a ? a = c : f < a && (a = f);
                return this.translate(a, 0, 1, 0, 1);
            },
            autoLabelAlign: function(a) {
                var f = (F(a, 0) - 90 * this.side + 720) % 360;
                a = {
                    align: "center"
                };
                d(this, "autoLabelAlign", a, function(a) {
                    15 < f && 165 > f ? a.align = "right" : 195 < f && 345 > f && (a.align = "left");
                });
                return a.align;
            },
            tickSize: function(a) {
                var f = this.options, c = f[a + "Length"], b = F(f[a + "Width"], "tick" === a && this.isXAxis && !this.categories ? 1 : 0), l;
                b && c && ("inside" === f[a + "Position"] && (c = -c), l = [ c, b ]);
                a = {
                    tickSize: l
                };
                d(this, "afterTickSize", a);
                return a.tickSize;
            },
            labelMetrics: function() {
                var a = this.tickPositions && this.tickPositions[0] || 0;
                return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
            },
            unsquish: function() {
                var a = this.options.labels, c = this.horiz, b = this.tickInterval, d = b, l = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / b), k, p = a.rotation, g = this.labelMetrics(), e, A = Number.MAX_VALUE, m, x = this.max - this.min, D = function(a) {
                    var f = a / (l || 1), f = 1 < f ? Math.ceil(f) : 1;
                    f * b > x && Infinity !== a && Infinity !== l && (f = Math.ceil(x / b));
                    return q(f * b);
                };
                c ? (m = !a.staggerLines && !a.step && (u(p) ? [ p ] : l < F(a.autoRotationLimit, 80) && a.autoRotation)) && m.forEach(function(a) {
                    var f;
                    if (a === p || a && -90 <= a && 90 >= a) e = D(Math.abs(g.h / Math.sin(v * a))), 
                    f = e + Math.abs(a / 360), f < A && (A = f, k = a, d = e);
                }) : a.step || (d = D(g.h));
                this.autoRotation = m;
                this.labelRotation = F(k, p);
                return d;
            },
            getSlotWidth: function(a) {
                var f = this.chart, c = this.horiz, b = this.options.labels, d = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), l = f.margin[3];
                return a && a.slotWidth || c && 2 > (b.step || 0) && !b.rotation && (this.staggerLines || 1) * this.len / d || !c && (b.style && parseInt(b.style.width, 10) || l && l - f.spacing[3] || .33 * f.chartWidth);
            },
            renderUnsquish: function() {
                var a = this.chart, b = a.renderer, d = this.tickPositions, l = this.ticks, k = this.options.labels, p = k && k.style || {}, g = this.horiz, e = this.getSlotWidth(), A = Math.max(1, Math.round(e - 2 * (k.padding || 5))), m = {}, x = this.labelMetrics(), D = k.style && k.style.textOverflow, n, w, z = 0, C;
                c(k.rotation) || (m.rotation = k.rotation || 0);
                d.forEach(function(a) {
                    (a = l[a]) && a.label && a.label.textPxLength > z && (z = a.label.textPxLength);
                });
                this.maxLabelLength = z;
                if (this.autoRotation) z > A && z > x.h ? m.rotation = this.labelRotation : this.labelRotation = 0; else if (e && (n = A, 
                !D)) for (w = "clip", A = d.length; !g && A--; ) if (C = d[A], C = l[C].label) C.styles && "ellipsis" === C.styles.textOverflow ? C.css({
                    textOverflow: "clip"
                }) : C.textPxLength > e && C.css({
                    width: e + "px"
                }), C.getBBox().height > this.len / d.length - (x.h - x.f) && (C.specificTextOverflow = "ellipsis");
                m.rotation && (n = z > .5 * a.chartHeight ? .33 * a.chartHeight : z, D || (w = "ellipsis"));
                if (this.labelAlign = k.align || this.autoLabelAlign(this.labelRotation)) m.align = this.labelAlign;
                d.forEach(function(a) {
                    var f = (a = l[a]) && a.label, c = p.width, b = {};
                    f && (f.attr(m), a.shortenLabel ? a.shortenLabel() : n && !c && "nowrap" !== p.whiteSpace && (n < f.textPxLength || "SPAN" === f.element.tagName) ? (b.width = n, 
                    D || (b.textOverflow = f.specificTextOverflow || w), f.css(b)) : f.styles && f.styles.width && !b.width && !c && f.css({
                        width: null
                    }), delete f.specificTextOverflow, a.rotation = m.rotation);
                }, this);
                this.tickRotCorr = b.rotCorr(x.b, this.labelRotation || 0, 0 !== this.side);
            },
            hasData: function() {
                return this.series.some(function(a) {
                    return a.hasData();
                }) || this.options.showEmpty && u(this.min) && u(this.max);
            },
            addTitle: function(a) {
                var f = this.chart.renderer, c = this.horiz, b = this.opposite, d = this.options.title, l, k = this.chart.styledMode;
                this.axisTitle || ((l = d.textAlign) || (l = (c ? {
                    low: "left",
                    middle: "center",
                    high: "right"
                } : {
                    low: b ? "right" : "left",
                    middle: "center",
                    high: b ? "left" : "right"
                })[d.align]), this.axisTitle = f.text(d.text, 0, 0, d.useHTML).attr({
                    zIndex: 7,
                    rotation: d.rotation || 0,
                    align: l
                }).addClass("highcharts-axis-title"), k || this.axisTitle.css(x(d.style)), this.axisTitle.add(this.axisGroup), 
                this.axisTitle.isNew = !0);
                k || d.style.width || this.isRadial || this.axisTitle.css({
                    width: this.len
                });
                this.axisTitle[a ? "show" : "hide"](!0);
            },
            generateTick: function(a) {
                var f = this.ticks;
                f[a] ? f[a].addLabel() : f[a] = new z(this, a);
            },
            getOffset: function() {
                var a = this, c = a.chart, b = c.renderer, l = a.options, k = a.tickPositions, p = a.ticks, g = a.horiz, e = a.side, A = c.inverted && !a.isZAxis ? [ 1, 0, 3, 2 ][e] : e, m, x, D = 0, n, z = 0, C = l.title, h = l.labels, I = 0, q = c.axisOffset, c = c.clipOffset, K = [ -1, 1, 1, -1 ][e], t = l.className, v = a.axisParent;
                m = a.hasData();
                a.showAxis = x = m || F(l.showEmpty, !0);
                a.staggerLines = a.horiz && h.staggerLines;
                a.axisGroup || (a.gridGroup = b.g("grid").attr({
                    zIndex: l.gridZIndex || 1
                }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (t || "")).add(v), 
                a.axisGroup = b.g("axis").attr({
                    zIndex: l.zIndex || 2
                }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (t || "")).add(v), a.labelGroup = b.g("axis-labels").attr({
                    zIndex: h.zIndex || 7
                }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (t || "")).add(v));
                m || a.isLinked ? (k.forEach(function(c, b) {
                    a.generateTick(c, b);
                }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === e || 2 === e || {
                    1: "left",
                    3: "right"
                }[e] === a.labelAlign, F(h.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && k.forEach(function(a) {
                    I = Math.max(p[a].getLabelSize(), I);
                }), a.staggerLines && (I *= a.staggerLines), a.labelOffset = I * (a.opposite ? -1 : 1)) : w(p, function(a, c) {
                    a.destroy();
                    delete p[c];
                });
                C && C.text && !1 !== C.enabled && (a.addTitle(x), x && !1 !== C.reserveSpace && (a.titleOffset = D = a.axisTitle.getBBox()[g ? "height" : "width"], 
                n = C.offset, z = u(n) ? 0 : F(C.margin, g ? 5 : 10)));
                a.renderLine();
                a.offset = K * F(l.offset, q[e] ? q[e] + (l.margin || 0) : 0);
                a.tickRotCorr = a.tickRotCorr || {
                    x: 0,
                    y: 0
                };
                b = 0 === e ? -a.labelMetrics().h : 2 === e ? a.tickRotCorr.y : 0;
                z = Math.abs(I) + z;
                I && (z = z - b + K * (g ? F(h.y, a.tickRotCorr.y + 8 * K) : h.x));
                a.axisTitleMargin = F(n, z);
                a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(p, k));
                g = this.tickSize("tick");
                q[e] = Math.max(q[e], a.axisTitleMargin + D + K * a.offset, z, k && k.length && g ? g[0] + K * a.offset : 0);
                l = l.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
                c[A] = Math.max(c[A], l);
                d(this, "afterGetOffset");
            },
            getLinePath: function(a) {
                var c = this.chart, b = this.opposite, f = this.offset, d = this.horiz, l = this.left + (b ? this.width : 0) + f, f = c.chartHeight - this.bottom - (b ? this.height : 0) + f;
                b && (a *= -1);
                return c.renderer.crispLine([ "M", d ? this.left : l, d ? f : this.top, "L", d ? c.chartWidth - this.right : l, d ? f : c.chartHeight - this.bottom ], a);
            },
            renderLine: function() {
                this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), 
                this.chart.styledMode || this.axisLine.attr({
                    stroke: this.options.lineColor,
                    "stroke-width": this.options.lineWidth,
                    zIndex: 7
                }));
            },
            getTitlePosition: function() {
                var a = this.horiz, c = this.left, b = this.top, l = this.len, k = this.options.title, p = a ? c : b, e = this.opposite, g = this.offset, A = k.x || 0, m = k.y || 0, x = this.axisTitle, D = this.chart.renderer.fontMetrics(k.style && k.style.fontSize, x), x = Math.max(x.getBBox(null, 0).height - D.h - 1, 0), l = {
                    low: p + (a ? 0 : l),
                    middle: p + l / 2,
                    high: p + (a ? l : 0)
                }[k.align], c = (a ? b + this.height : c) + (a ? 1 : -1) * (e ? -1 : 1) * this.axisTitleMargin + [ -x, x, D.f, -x ][this.side], a = {
                    x: a ? l + A : c + (e ? this.width : 0) + g + A,
                    y: a ? c + m - (e ? this.height : 0) + g : l + m
                };
                d(this, "afterGetTitlePosition", {
                    titlePosition: a
                });
                return a;
            },
            renderMinorTick: function(a) {
                var c = this.chart.hasRendered && p(this.oldMin), b = this.minorTicks;
                b[a] || (b[a] = new z(this, a, "minor"));
                c && b[a].isNew && b[a].render(null, !0);
                b[a].render(null, !1, 1);
            },
            renderTick: function(a, c) {
                var b = this.isLinked, f = this.ticks, d = this.chart.hasRendered && p(this.oldMin);
                if (!b || a >= this.min && a <= this.max) f[a] || (f[a] = new z(this, a)), d && f[a].isNew && f[a].render(c, !0, -1), 
                f[a].render(c);
            },
            render: function() {
                var c = this, b = c.chart, l = c.options, k = c.isLog, e = c.isLinked, g = c.tickPositions, m = c.axisTitle, x = c.ticks, D = c.minorTicks, n = c.alternateBands, C = l.stackLabels, h = l.alternateGridColor, I = c.tickmarkOffset, q = c.axisLine, F = c.showAxis, K = H(b.renderer.globalAnimation), t, v;
                c.labelEdge.length = 0;
                c.overlap = !1;
                [ x, D, n ].forEach(function(a) {
                    w(a, function(a) {
                        a.isActive = !1;
                    });
                });
                if (c.hasData() || e) c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function(a) {
                    c.renderMinorTick(a);
                }), g.length && (g.forEach(function(a, b) {
                    c.renderTick(a, b);
                }), I && (0 === c.min || c.single) && (x[-1] || (x[-1] = new z(c, -1, null, !0)), 
                x[-1].render(-1))), h && g.forEach(function(f, l) {
                    v = void 0 !== g[l + 1] ? g[l + 1] + I : c.max - I;
                    0 === l % 2 && f < c.max && v <= c.max + (b.polar ? -I : I) && (n[f] || (n[f] = new a.PlotLineOrBand(c)), 
                    t = f + I, n[f].options = {
                        from: k ? c.lin2log(t) : t,
                        to: k ? c.lin2log(v) : v,
                        color: h
                    }, n[f].render(), n[f].isActive = !0);
                }), c._addedPlotLB || ((l.plotLines || []).concat(l.plotBands || []).forEach(function(a) {
                    c.addPlotBandOrLine(a);
                }), c._addedPlotLB = !0);
                [ x, D, n ].forEach(function(a) {
                    var c, f = [], l = K.duration;
                    w(a, function(a, c) {
                        a.isActive || (a.render(c, !1, 0), a.isActive = !1, f.push(c));
                    });
                    A(function() {
                        for (c = f.length; c--; ) a[f[c]] && !a[f[c]].isActive && (a[f[c]].destroy(), delete a[f[c]]);
                    }, a !== n && b.hasRendered && l ? l : 0);
                });
                q && (q[q.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(q.strokeWidth())
                }), q.isPlaced = !0, q[F ? "show" : "hide"](!0));
                m && F && (l = c.getTitlePosition(), p(l.y) ? (m[m.isNew ? "attr" : "animate"](l), 
                m.isNew = !1) : (m.attr("y", -9999), m.isNew = !0));
                C && C.enabled && c.renderStackTotals();
                c.isDirty = !1;
                d(this, "afterRender");
            },
            redraw: function() {
                this.visible && (this.render(), this.plotLinesAndBands.forEach(function(a) {
                    a.render();
                }));
                this.series.forEach(function(a) {
                    a.isDirty = !0;
                });
            },
            keepProps: "extKey hcEvents names series userMax userMin".split(" "),
            destroy: function(a) {
                var c = this, b = c.stacks, f = c.plotLinesAndBands, l;
                d(this, "destroy", {
                    keepEvents: a
                });
                a || C(c);
                w(b, function(a, c) {
                    n(a);
                    b[c] = null;
                });
                [ c.ticks, c.minorTicks, c.alternateBands ].forEach(function(a) {
                    n(a);
                });
                if (f) for (a = f.length; a--; ) f[a].destroy();
                "stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(a) {
                    c[a] && (c[a] = c[a].destroy());
                });
                for (l in c.plotLinesAndBandsGroups) c.plotLinesAndBandsGroups[l] = c.plotLinesAndBandsGroups[l].destroy();
                w(c, function(a, b) {
                    -1 === c.keepProps.indexOf(b) && delete c[b];
                });
            },
            drawCrosshair: function(a, c) {
                var b, f = this.crosshair, l = F(f.snap, !0), k, p = this.cross;
                d(this, "drawCrosshair", {
                    e: a,
                    point: c
                });
                a || (a = this.cross && this.cross.e);
                if (this.crosshair && !1 !== (u(c) || !l)) {
                    l ? u(c) && (k = F(c.crosshairPos, this.isXAxis ? c.plotX : this.len - c.plotY)) : k = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);
                    u(k) && (b = this.getPlotLinePath({
                        value: c && (this.isXAxis ? c.x : F(c.stackY, c.y)),
                        translatedValue: k
                    }) || null);
                    if (!u(b)) {
                        this.hideCrosshair();
                        return;
                    }
                    l = this.categories && !this.isRadial;
                    p || (this.cross = p = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (l ? "category " : "thin ") + f.className).attr({
                        zIndex: F(f.zIndex, 2)
                    }).add(), this.chart.styledMode || (p.attr({
                        stroke: f.color || (l ? e("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                        "stroke-width": F(f.width, 1)
                    }).css({
                        "pointer-events": "none"
                    }), f.dashStyle && p.attr({
                        dashstyle: f.dashStyle
                    })));
                    p.show().attr({
                        d: b
                    });
                    l && !f.width && p.attr({
                        "stroke-width": this.transA
                    });
                    this.cross.e = a;
                } else this.hideCrosshair();
                d(this, "afterDrawCrosshair", {
                    e: a,
                    point: c
                });
            },
            hideCrosshair: function() {
                this.cross && this.cross.hide();
                d(this, "afterHideCrosshair");
            }
        });
        return a.Axis = I;
    });
    J(G, "parts/DateTimeAxis.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.Axis, H = a.getMagnitude, B = a.normalizeTickInterval, h = a.timeUnits;
        E.prototype.getTimeTicks = function() {
            return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        };
        E.prototype.normalizeTimeTickInterval = function(a, q) {
            var e = q || [ [ "millisecond", [ 1, 2, 5, 10, 20, 25, 50, 100, 200, 500 ] ], [ "second", [ 1, 2, 5, 10, 15, 30 ] ], [ "minute", [ 1, 2, 5, 10, 15, 30 ] ], [ "hour", [ 1, 2, 3, 4, 6, 8, 12 ] ], [ "day", [ 1, 2 ] ], [ "week", [ 1, 2 ] ], [ "month", [ 1, 2, 3, 4, 6 ] ], [ "year", null ] ];
            q = e[e.length - 1];
            var u = h[q[0]], v = q[1], n;
            for (n = 0; n < e.length && !(q = e[n], u = h[q[0]], v = q[1], e[n + 1] && a <= (u * v[v.length - 1] + h[e[n + 1][0]]) / 2); n++) ;
            u === h.year && a < 5 * u && (v = [ 1, 2, 5 ]);
            a = B(a / u, v, "year" === q[0] ? Math.max(H(a / u), 1) : 1);
            return {
                unitRange: u,
                count: a,
                unitName: q[0]
            };
        };
    });
    J(G, "parts/LogarithmicAxis.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.Axis, H = a.getMagnitude, B = a.normalizeTickInterval, h = a.pick;
        E.prototype.getLogTickPositions = function(a, q, t, u) {
            var e = this.options, n = this.len, g = [];
            u || (this._minorAutoInterval = null);
            if (.5 <= a) a = Math.round(a), g = this.getLinearTickPositions(a, q, t); else if (.08 <= a) for (var n = Math.floor(q), d, m, b, k, p, e = .3 < a ? [ 1, 2, 4 ] : .15 < a ? [ 1, 2, 4, 6, 8 ] : [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]; n < t + 1 && !p; n++) for (m = e.length, 
            d = 0; d < m && !p; d++) b = this.log2lin(this.lin2log(n) * e[d]), b > q && (!u || k <= t) && void 0 !== k && g.push(k), 
            k > t && (p = !0), k = b; else q = this.lin2log(q), t = this.lin2log(t), a = u ? this.getMinorTickInterval() : e.tickInterval, 
            a = h("auto" === a ? null : a, this._minorAutoInterval, e.tickPixelInterval / (u ? 5 : 1) * (t - q) / ((u ? n / this.tickPositions.length : n) || 1)), 
            a = B(a, null, H(a)), g = this.getLinearTickPositions(a, q, t).map(this.log2lin), 
            u || (this._minorAutoInterval = a / 5);
            u || (this.tickInterval = a);
            return g;
        };
        E.prototype.log2lin = function(a) {
            return Math.log(a) / Math.LN10;
        };
        E.prototype.lin2log = function(a) {
            return Math.pow(10, a);
        };
    });
    J(G, "parts/PlotLineOrBand.js", [ G["parts/Globals.js"], G["parts/Axis.js"] ], function(a, E) {
        var H = a.arrayMax, B = a.arrayMin, h = a.defined, e = a.destroyObjectProperties, q = a.erase, t = a.merge, u = a.pick;
        a.PlotLineOrBand = function(a, e) {
            this.axis = a;
            e && (this.options = e, this.id = e.id);
        };
        a.PlotLineOrBand.prototype = {
            render: function() {
                a.fireEvent(this, "render");
                var e = this, n = e.axis, g = n.horiz, d = e.options, m = d.label, b = e.label, k = d.to, p = d.from, c = d.value, x = h(p) && h(k), q = h(c), w = e.svgElem, F = !w, C = [], l = d.color, D = u(d.zIndex, 0), A = d.events, C = {
                    class: "highcharts-plot-" + (x ? "band " : "line ") + (d.className || "")
                }, z = {}, I = n.chart.renderer, f = x ? "bands" : "lines";
                n.isLog && (p = n.log2lin(p), k = n.log2lin(k), c = n.log2lin(c));
                n.chart.styledMode || (q ? (C.stroke = l, C["stroke-width"] = d.width, d.dashStyle && (C.dashstyle = d.dashStyle)) : x && (l && (C.fill = l), 
                d.borderWidth && (C.stroke = d.borderColor, C["stroke-width"] = d.borderWidth)));
                z.zIndex = D;
                f += "-" + D;
                (l = n.plotLinesAndBandsGroups[f]) || (n.plotLinesAndBandsGroups[f] = l = I.g("plot-" + f).attr(z).add());
                F && (e.svgElem = w = I.path().attr(C).add(l));
                if (q) C = n.getPlotLinePath({
                    value: c,
                    lineWidth: w.strokeWidth(),
                    acrossPanes: d.acrossPanes
                }); else if (x) C = n.getPlotBandPath(p, k, d); else return;
                (F || !w.d) && C && C.length ? (w.attr({
                    d: C
                }), A && a.objectEach(A, function(a, c) {
                    w.on(c, function(a) {
                        A[c].apply(e, [ a ]);
                    });
                })) : w && (C ? (w.show(!0), w.animate({
                    d: C
                })) : w.d && (w.hide(), b && (e.label = b = b.destroy())));
                m && h(m.text) && C && C.length && 0 < n.width && 0 < n.height && !C.isFlat ? (m = t({
                    align: g && x && "center",
                    x: g ? !x && 4 : 10,
                    verticalAlign: !g && x && "middle",
                    y: g ? x ? 16 : 10 : x ? 6 : -4,
                    rotation: g && !x && 90
                }, m), this.renderLabel(m, C, x, D)) : b && b.hide();
                return e;
            },
            renderLabel: function(a, e, g, d) {
                var m = this.label, b = this.axis.chart.renderer;
                m || (m = {
                    align: a.textAlign || a.align,
                    rotation: a.rotation,
                    class: "highcharts-plot-" + (g ? "band" : "line") + "-label " + (a.className || "")
                }, m.zIndex = d, this.label = m = b.text(a.text, 0, 0, a.useHTML).attr(m).add(), 
                this.axis.chart.styledMode || m.css(a.style));
                d = e.xBounds || [ e[1], e[4], g ? e[6] : e[1] ];
                e = e.yBounds || [ e[2], e[5], g ? e[7] : e[2] ];
                g = B(d);
                b = B(e);
                m.align(a, !1, {
                    x: g,
                    y: b,
                    width: H(d) - g,
                    height: H(e) - b
                });
                m.show(!0);
            },
            destroy: function() {
                q(this.axis.plotLinesAndBands, this);
                delete this.axis;
                e(this);
            }
        };
        a.extend(E.prototype, {
            getPlotBandPath: function(a, e) {
                var g = this.getPlotLinePath({
                    value: e,
                    force: !0,
                    acrossPanes: this.options.acrossPanes
                }), d = this.getPlotLinePath({
                    value: a,
                    force: !0,
                    acrossPanes: this.options.acrossPanes
                }), m = [], b = this.horiz, k = 1, p;
                a = a < this.min && e < this.min || a > this.max && e > this.max;
                if (d && g) for (a && (p = d.toString() === g.toString(), k = 0), a = 0; a < d.length; a += 6) b && g[a + 1] === d[a + 1] ? (g[a + 1] += k, 
                g[a + 4] += k) : b || g[a + 2] !== d[a + 2] || (g[a + 2] += k, g[a + 5] += k), m.push("M", d[a + 1], d[a + 2], "L", d[a + 4], d[a + 5], g[a + 4], g[a + 5], g[a + 1], g[a + 2], "z"), 
                m.isFlat = p;
                return m;
            },
            addPlotBand: function(a) {
                return this.addPlotBandOrLine(a, "plotBands");
            },
            addPlotLine: function(a) {
                return this.addPlotBandOrLine(a, "plotLines");
            },
            addPlotBandOrLine: function(e, n) {
                var g = new a.PlotLineOrBand(this, e).render(), d = this.userOptions;
                g && (n && (d[n] = d[n] || [], d[n].push(e)), this.plotLinesAndBands.push(g));
                return g;
            },
            removePlotBandOrLine: function(a) {
                for (var e = this.plotLinesAndBands, g = this.options, d = this.userOptions, m = e.length; m--; ) e[m].id === a && e[m].destroy();
                [ g.plotLines || [], d.plotLines || [], g.plotBands || [], d.plotBands || [] ].forEach(function(b) {
                    for (m = b.length; m--; ) b[m].id === a && q(b, b[m]);
                });
            },
            removePlotBand: function(a) {
                this.removePlotBandOrLine(a);
            },
            removePlotLine: function(a) {
                this.removePlotBandOrLine(a);
            }
        });
    });
    J(G, "parts/Tooltip.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.doc, H = a.extend, B = a.format, h = a.isNumber, e = a.merge, q = a.pick, t = a.splat, u = a.syncTimeout, v = a.timeUnits;
        a.Tooltip = function() {
            this.init.apply(this, arguments);
        };
        a.Tooltip.prototype = {
            init: function(a, e) {
                this.chart = a;
                this.options = e;
                this.crosshairs = [];
                this.now = {
                    x: 0,
                    y: 0
                };
                this.isHidden = !0;
                this.split = e.split && !a.inverted;
                this.shared = e.shared || this.split;
                this.outside = q(e.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY)) && !this.split;
            },
            cleanSplit: function(a) {
                this.chart.series.forEach(function(e) {
                    var d = e && e.tt;
                    d && (!d.isActive || a ? e.tt = d.destroy() : d.isActive = !1);
                });
            },
            applyFilter: function() {
                var a = this.chart;
                a.renderer.definition({
                    tagName: "filter",
                    id: "drop-shadow-" + a.index,
                    opacity: .5,
                    children: [ {
                        tagName: "feGaussianBlur",
                        in: "SourceAlpha",
                        stdDeviation: 1
                    }, {
                        tagName: "feOffset",
                        dx: 1,
                        dy: 1
                    }, {
                        tagName: "feComponentTransfer",
                        children: [ {
                            tagName: "feFuncA",
                            type: "linear",
                            slope: .3
                        } ]
                    }, {
                        tagName: "feMerge",
                        children: [ {
                            tagName: "feMergeNode"
                        }, {
                            tagName: "feMergeNode",
                            in: "SourceGraphic"
                        } ]
                    } ]
                });
                a.renderer.definition({
                    tagName: "style",
                    textContent: ".highcharts-tooltip-" + a.index + "{filter:url(#drop-shadow-" + a.index + ")}"
                });
            },
            getLabel: function() {
                var e = this, g = this.chart.renderer, d = this.chart.styledMode, m = this.options, b, k;
                this.label || (this.outside && (this.container = b = a.doc.createElement("div"), 
                b.className = "highcharts-tooltip-container", a.css(b, {
                    position: "absolute",
                    top: "1px",
                    pointerEvents: m.style && m.style.pointerEvents,
                    zIndex: 3
                }), a.doc.body.appendChild(b), this.renderer = g = new a.Renderer(b, 0, 0)), this.split ? this.label = g.g("tooltip") : (this.label = g.label("", 0, 0, m.shape || "callout", null, null, m.useHTML, null, "tooltip").attr({
                    padding: m.padding,
                    r: m.borderRadius
                }), d || this.label.attr({
                    fill: m.backgroundColor,
                    "stroke-width": m.borderWidth
                }).css(m.style).shadow(m.shadow)), d && (this.applyFilter(), this.label.addClass("highcharts-tooltip-" + this.chart.index)), 
                this.outside && (k = {
                    x: this.label.xSetter,
                    y: this.label.ySetter
                }, this.label.xSetter = function(a, c) {
                    k[c].call(this.label, e.distance);
                    b.style.left = a + "px";
                }, this.label.ySetter = function(a, c) {
                    k[c].call(this.label, e.distance);
                    b.style.top = a + "px";
                }), this.label.attr({
                    zIndex: 8
                }).add());
                return this.label;
            },
            update: function(a) {
                this.destroy();
                e(!0, this.chart.options.tooltip.userOptions, a);
                this.init(this.chart, e(!0, this.options, a));
            },
            destroy: function() {
                this.label && (this.label = this.label.destroy());
                this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
                this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));
                a.clearTimeout(this.hideTimer);
                a.clearTimeout(this.tooltipTimeout);
            },
            move: function(e, g, d, m) {
                var b = this, k = b.now, p = !1 !== b.options.animation && !b.isHidden && (1 < Math.abs(e - k.x) || 1 < Math.abs(g - k.y)), c = b.followPointer || 1 < b.len;
                H(k, {
                    x: p ? (2 * k.x + e) / 3 : e,
                    y: p ? (k.y + g) / 2 : g,
                    anchorX: c ? void 0 : p ? (2 * k.anchorX + d) / 3 : d,
                    anchorY: c ? void 0 : p ? (k.anchorY + m) / 2 : m
                });
                b.getLabel().attr(k);
                p && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
                    b && b.move(e, g, d, m);
                }, 32));
            },
            hide: function(e) {
                var g = this;
                a.clearTimeout(this.hideTimer);
                e = q(e, this.options.hideDelay, 500);
                this.isHidden || (this.hideTimer = u(function() {
                    g.getLabel()[e ? "fadeOut" : "hide"]();
                    g.isHidden = !0;
                }, e));
            },
            getAnchor: function(a, e) {
                var d = this.chart, g = d.pointer, b = d.inverted, k = d.plotTop, p = d.plotLeft, c = 0, x = 0, h, w;
                a = t(a);
                this.followPointer && e ? (void 0 === e.chartX && (e = g.normalize(e)), a = [ e.chartX - d.plotLeft, e.chartY - k ]) : a[0].tooltipPos ? a = a[0].tooltipPos : (a.forEach(function(a) {
                    h = a.series.yAxis;
                    w = a.series.xAxis;
                    c += a.plotX + (!b && w ? w.left - p : 0);
                    x += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!b && h ? h.top - k : 0);
                }), c /= a.length, x /= a.length, a = [ b ? d.plotWidth - x : c, this.shared && !b && 1 < a.length && e ? e.chartY - k : b ? d.plotHeight - c : x ]);
                return a.map(Math.round);
            },
            getPosition: function(a, e, d) {
                var g = this.chart, b = this.distance, k = {}, p = g.inverted && d.h || 0, c, x = this.outside, h = x ? E.documentElement.clientWidth - 2 * b : g.chartWidth, w = x ? Math.max(E.body.scrollHeight, E.documentElement.scrollHeight, E.body.offsetHeight, E.documentElement.offsetHeight, E.documentElement.clientHeight) : g.chartHeight, n = g.pointer.chartPosition, C = [ "y", w, e, (x ? n.top - b : 0) + d.plotY + g.plotTop, x ? 0 : g.plotTop, x ? w : g.plotTop + g.plotHeight ], l = [ "x", h, a, (x ? n.left - b : 0) + d.plotX + g.plotLeft, x ? 0 : g.plotLeft, x ? h : g.plotLeft + g.plotWidth ], D = !this.followPointer && q(d.ttBelow, !g.inverted === !!d.negative), A = function(a, c, f, l, d, e) {
                    var g = f < l - b, A = l + b + f < c, m = l - b - f;
                    l += b;
                    if (D && A) k[a] = l; else if (!D && g) k[a] = m; else if (g) k[a] = Math.min(e - f, 0 > m - p ? m : m - p); else if (A) k[a] = Math.max(d, l + p + f > c ? l : l + p); else return !1;
                }, z = function(a, c, f, l) {
                    var d;
                    l < b || l > c - b ? d = !1 : k[a] = l < f / 2 ? 1 : l > c - f / 2 ? c - f - 2 : l - f / 2;
                    return d;
                }, I = function(a) {
                    var b = C;
                    C = l;
                    l = b;
                    c = a;
                }, f = function() {
                    !1 !== A.apply(0, C) ? !1 !== z.apply(0, l) || c || (I(!0), f()) : c ? k.x = k.y = 0 : (I(!0), 
                    f());
                };
                (g.inverted || 1 < this.len) && I();
                f();
                return k;
            },
            defaultFormatter: function(a) {
                var e = this.points || t(this), d;
                d = [ a.tooltipFooterHeaderFormatter(e[0]) ];
                d = d.concat(a.bodyFormatter(e));
                d.push(a.tooltipFooterHeaderFormatter(e[0], !0));
                return d;
            },
            refresh: function(e, g) {
                var d = this.chart, m = this.options, b, k = e, p, c = {}, x, h = [];
                x = m.formatter || this.defaultFormatter;
                var c = this.shared, w = d.styledMode, n = [];
                m.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = t(k)[0].series.tooltipOptions.followPointer, 
                p = this.getAnchor(k, g), g = p[0], b = p[1], !c || k.series && k.series.noSharedTooltip ? c = k.getLabelConfig() : (n = d.pointer.getActiveSeries(k), 
                d.series.forEach(function(a) {
                    (a.options.inactiveOtherPoints || -1 === n.indexOf(a)) && a.setState("inactive", !0);
                }), k.forEach(function(a) {
                    a.setState("hover");
                    h.push(a.getLabelConfig());
                }), c = {
                    x: k[0].category,
                    y: k[0].y
                }, c.points = h, k = k[0]), this.len = h.length, x = x.call(c, this), c = k.series, 
                this.distance = q(c.tooltipOptions.distance, 16), !1 === x ? this.hide() : (d = this.getLabel(), 
                this.isHidden && d.attr({
                    opacity: 1
                }).show(), this.split ? this.renderSplit(x, t(e)) : (m.style.width && !w || d.css({
                    width: this.chart.spacingBox.width
                }), d.attr({
                    text: x && x.join ? x.join("") : x
                }), d.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + q(k.colorIndex, c.colorIndex)), 
                w || d.attr({
                    stroke: m.borderColor || k.color || c.color || "#666666"
                }), this.updatePosition({
                    plotX: g,
                    plotY: b,
                    negative: k.negative,
                    ttBelow: k.ttBelow,
                    h: p[2] || 0
                })), this.isHidden = !1), a.fireEvent(this, "refresh"));
            },
            renderSplit: function(e, g) {
                var d = this, m = [], b = this.chart, k = b.renderer, p = !0, c = this.options, x = 0, h, w = this.getLabel(), n = b.plotTop;
                a.isString(e) && (e = [ !1, e ]);
                e.slice(0, g.length + 1).forEach(function(a, l) {
                    if (!1 !== a && "" !== a) {
                        l = g[l - 1] || {
                            isHeader: !0,
                            plotX: g[0].plotX,
                            plotY: b.plotHeight
                        };
                        var e = l.series || d, A = e.tt, z = l.series || {}, C = "highcharts-color-" + q(l.colorIndex, z.colorIndex, "none");
                        A || (A = {
                            padding: c.padding,
                            r: c.borderRadius
                        }, b.styledMode || (A.fill = c.backgroundColor, A["stroke-width"] = c.borderWidth), 
                        e.tt = A = k.label(null, null, null, (l.isHeader ? c.headerShape : c.shape) || "callout", null, null, c.useHTML).addClass("highcharts-tooltip-box " + C).attr(A).add(w));
                        A.isActive = !0;
                        A.attr({
                            text: a
                        });
                        b.styledMode || A.css(c.style).shadow(c.shadow).attr({
                            stroke: c.borderColor || l.color || z.color || "#333333"
                        });
                        a = A.getBBox();
                        z = a.width + A.strokeWidth();
                        l.isHeader ? (x = a.height, b.xAxis[0].opposite && (h = !0, n -= x), z = Math.max(0, Math.min(l.plotX + b.plotLeft - z / 2, b.chartWidth + (b.scrollablePixelsX ? b.scrollablePixelsX - b.marginRight : 0) - z))) : z = l.plotX + b.plotLeft - q(c.distance, 16) - z;
                        0 > z && (p = !1);
                        a = (l.series && l.series.yAxis && l.series.yAxis.pos) + (l.plotY || 0);
                        a -= n;
                        l.isHeader && (a = h ? -x : b.plotHeight + x);
                        m.push({
                            target: a,
                            rank: l.isHeader ? 1 : 0,
                            size: e.tt.getBBox().height + 1,
                            point: l,
                            x: z,
                            tt: A
                        });
                    }
                });
                this.cleanSplit();
                c.positioner && m.forEach(function(a) {
                    var b = c.positioner.call(d, a.tt.getBBox().width, a.size, a.point);
                    a.x = b.x;
                    a.align = 0;
                    a.target = b.y;
                    a.rank = q(b.rank, a.rank);
                });
                a.distribute(m, b.plotHeight + x);
                m.forEach(function(a) {
                    var l = a.point, k = l.series;
                    a.tt.attr({
                        visibility: void 0 === a.pos ? "hidden" : "inherit",
                        x: p || l.isHeader || c.positioner ? a.x : l.plotX + b.plotLeft + d.distance,
                        y: a.pos + n,
                        anchorX: l.isHeader ? l.plotX + b.plotLeft : l.plotX + k.xAxis.pos,
                        anchorY: l.isHeader ? b.plotTop + b.plotHeight / 2 : l.plotY + k.yAxis.pos
                    });
                });
            },
            updatePosition: function(a) {
                var e = this.chart, d = this.getLabel(), m = (this.options.positioner || this.getPosition).call(this, d.width, d.height, a), b = a.plotX + e.plotLeft;
                a = a.plotY + e.plotTop;
                var k;
                this.outside && (k = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(d.width + k, d.height + k, !1), 
                b += e.pointer.chartPosition.left - m.x, a += e.pointer.chartPosition.top - m.y);
                this.move(Math.round(m.x), Math.round(m.y || 0), b, a);
            },
            getDateFormat: function(a, e, d, m) {
                var b = this.chart.time, k = b.dateFormat("%m-%d %H:%M:%S.%L", e), p, c, g = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                }, h = "millisecond";
                for (c in v) {
                    if (a === v.week && +b.dateFormat("%w", e) === d && "00:00:00.000" === k.substr(6)) {
                        c = "week";
                        break;
                    }
                    if (v[c] > a) {
                        c = h;
                        break;
                    }
                    if (g[c] && k.substr(g[c]) !== "01-01 00:00:00.000".substr(g[c])) break;
                    "week" !== c && (h = c);
                }
                c && (p = b.resolveDTLFormat(m[c]).main);
                return p;
            },
            getXDateFormat: function(a, e, d) {
                e = e.dateTimeLabelFormats;
                var g = d && d.closestPointRange;
                return (g ? this.getDateFormat(g, a.x, d.options.startOfWeek, e) : e.day) || e.year;
            },
            tooltipFooterHeaderFormatter: function(e, g) {
                var d = g ? "footer" : "header", m = e.series, b = m.tooltipOptions, k = b.xDateFormat, p = m.xAxis, c = p && "datetime" === p.options.type && h(e.key), x = b[d + "Format"];
                g = {
                    isFooter: g,
                    labelConfig: e
                };
                a.fireEvent(this, "headerFormatter", g, function(a) {
                    c && !k && (k = this.getXDateFormat(e, b, p));
                    c && k && (e.point && e.point.tooltipDateKeys || [ "key" ]).forEach(function(a) {
                        x = x.replace("{point." + a + "}", "{point." + a + ":" + k + "}");
                    });
                    m.chart.styledMode && (x = this.styledModeFormat(x));
                    a.text = B(x, {
                        point: e,
                        series: m
                    }, this.chart.time);
                });
                return g.text;
            },
            bodyFormatter: function(a) {
                return a.map(function(a) {
                    var d = a.series.tooltipOptions;
                    return (d[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, d[(a.point.formatPrefix || "point") + "Format"] || "");
                });
            },
            styledModeFormat: function(a) {
                return a.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            }
        };
    });
    J(G, "parts/Pointer.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.attr, B = a.charts, h = a.color, e = a.css, q = a.defined, t = a.extend, u = a.find, v = a.fireEvent, n = a.isNumber, g = a.isObject, d = a.offset, m = a.pick, b = a.splat, k = a.Tooltip;
        a.Pointer = function(a, c) {
            this.init(a, c);
        };
        a.Pointer.prototype = {
            init: function(a, c) {
                this.options = c;
                this.chart = a;
                this.runChartClick = c.chart.events && !!c.chart.events.click;
                this.pinchDown = [];
                this.lastValidTouch = {};
                k && (a.tooltip = new k(a, c.tooltip), this.followTouchMove = m(c.tooltip.followTouchMove, !0));
                this.setDOMEvents();
            },
            zoomOption: function(a) {
                var c = this.chart, b = c.options.chart, d = b.zoomType || "", c = c.inverted;
                /touch/.test(a.type) && (d = m(b.pinchType, d));
                this.zoomX = a = /x/.test(d);
                this.zoomY = d = /y/.test(d);
                this.zoomHor = a && !c || d && c;
                this.zoomVert = d && !c || a && c;
                this.hasZoom = a || d;
            },
            normalize: function(a, c) {
                var b;
                b = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;
                c || (this.chartPosition = c = d(this.chart.container));
                return t(a, {
                    chartX: Math.round(b.pageX - c.left),
                    chartY: Math.round(b.pageY - c.top)
                });
            },
            getCoordinates: function(a) {
                var c = {
                    xAxis: [],
                    yAxis: []
                };
                this.chart.axes.forEach(function(b) {
                    c[b.isXAxis ? "xAxis" : "yAxis"].push({
                        axis: b,
                        value: b.toValue(a[b.horiz ? "chartX" : "chartY"])
                    });
                });
                return c;
            },
            findNearestKDPoint: function(a, c, b) {
                var d;
                a.forEach(function(a) {
                    var k = !(a.noSharedTooltip && c) && 0 > a.options.findNearestPointBy.indexOf("y");
                    a = a.searchPoint(b, k);
                    if ((k = g(a, !0)) && !(k = !g(d, !0))) var k = d.distX - a.distX, e = d.dist - a.dist, l = (a.series.group && a.series.group.zIndex) - (d.series.group && d.series.group.zIndex), k = 0 < (0 !== k && c ? k : 0 !== e ? e : 0 !== l ? l : d.series.index > a.series.index ? -1 : 1);
                    k && (d = a);
                });
                return d;
            },
            getPointFromEvent: function(a) {
                a = a.target;
                for (var c; a && !c; ) c = a.point, a = a.parentNode;
                return c;
            },
            getChartCoordinatesFromPoint: function(a, c) {
                var b = a.series, d = b.xAxis, b = b.yAxis, k = m(a.clientX, a.plotX), e = a.shapeArgs;
                if (d && b) return c ? {
                    chartX: d.len + d.pos - k,
                    chartY: b.len + b.pos - a.plotY
                } : {
                    chartX: k + d.pos,
                    chartY: a.plotY + b.pos
                };
                if (e && e.x && e.y) return {
                    chartX: e.x,
                    chartY: e.y
                };
            },
            getHoverData: function(a, c, b, d, k, e) {
                var p, l = [];
                d = !(!d || !a);
                var x = c && !c.stickyTracking ? [ c ] : b.filter(function(a) {
                    return a.visible && !(!k && a.directTouch) && m(a.options.enableMouseTracking, !0) && a.stickyTracking;
                });
                c = (p = d ? a : this.findNearestKDPoint(x, k, e)) && p.series;
                p && (k && !c.noSharedTooltip ? (x = b.filter(function(a) {
                    return a.visible && !(!k && a.directTouch) && m(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
                }), x.forEach(function(a) {
                    var c = u(a.points, function(a) {
                        return a.x === p.x && !a.isNull;
                    });
                    g(c) && (a.chart.isBoosting && (c = a.getPoint(c)), l.push(c));
                })) : l.push(p));
                return {
                    hoverPoint: p,
                    hoverSeries: c,
                    hoverPoints: l
                };
            },
            runPointActions: function(b, c) {
                var d = this.chart, k = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0, e = k ? k.shared : !1, p = c || d.hoverPoint, g = p && p.series || d.hoverSeries, g = this.getHoverData(p, g, d.series, "touchmove" !== b.type && (!!c || g && g.directTouch && this.isDirectTouch), e, b), l = [], D, p = g.hoverPoint;
                D = g.hoverPoints;
                c = (g = g.hoverSeries) && g.tooltipOptions.followPointer;
                e = e && g && !g.noSharedTooltip;
                if (p && (p !== d.hoverPoint || k && k.isHidden)) {
                    (d.hoverPoints || []).forEach(function(a) {
                        -1 === D.indexOf(a) && a.setState();
                    });
                    if (d.hoverSeries !== g) g.onMouseOver();
                    l = this.getActiveSeries(D);
                    d.series.forEach(function(a) {
                        (a.options.inactiveOtherPoints || -1 === l.indexOf(a)) && a.setState("inactive", !0);
                    });
                    (D || []).forEach(function(a) {
                        a.setState("hover");
                    });
                    d.hoverPoint && d.hoverPoint.firePointEvent("mouseOut");
                    if (!p.series) return;
                    p.firePointEvent("mouseOver");
                    d.hoverPoints = D;
                    d.hoverPoint = p;
                    k && k.refresh(e ? D : p, b);
                } else c && k && !k.isHidden && (p = k.getAnchor([ {} ], b), k.updatePosition({
                    plotX: p[0],
                    plotY: p[1]
                }));
                this.unDocMouseMove || (this.unDocMouseMove = E(d.container.ownerDocument, "mousemove", function(c) {
                    var b = B[a.hoverChartIndex];
                    if (b) b.pointer.onDocumentMouseMove(c);
                }));
                d.axes.forEach(function(c) {
                    var d = m(c.crosshair.snap, !0), l = d ? a.find(D, function(a) {
                        return a.series[c.coll] === c;
                    }) : void 0;
                    l || !d ? c.drawCrosshair(b, l) : c.hideCrosshair();
                });
            },
            getActiveSeries: function(a) {
                var c = [], b;
                (a || []).forEach(function(a) {
                    b = a.series;
                    c.push(b);
                    b.linkedParent && c.push(b.linkedParent);
                    b.linkedSeries && (c = c.concat(b.linkedSeries));
                    b.navigatorSeries && c.push(b.navigatorSeries);
                });
                return c;
            },
            reset: function(a, c) {
                var d = this.chart, k = d.hoverSeries, e = d.hoverPoint, p = d.hoverPoints, g = d.tooltip, l = g && g.shared ? p : e;
                a && l && b(l).forEach(function(c) {
                    c.series.isCartesian && void 0 === c.plotX && (a = !1);
                });
                if (a) g && l && b(l).length && (g.refresh(l), g.shared && p ? p.forEach(function(a) {
                    a.setState(a.state, !0);
                    a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), 
                    a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
                }) : e && (e.setState(e.state, !0), d.axes.forEach(function(a) {
                    a.crosshair && a.drawCrosshair(null, e);
                }))); else {
                    if (e) e.onMouseOut();
                    p && p.forEach(function(a) {
                        a.setState();
                    });
                    if (k) k.onMouseOut();
                    g && g.hide(c);
                    this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
                    d.axes.forEach(function(a) {
                        a.hideCrosshair();
                    });
                    this.hoverX = d.hoverPoints = d.hoverPoint = null;
                }
            },
            scaleGroups: function(a, c) {
                var b = this.chart, d;
                b.series.forEach(function(k) {
                    d = a || k.getPlotBox();
                    k.xAxis && k.xAxis.zoomEnabled && k.group && (k.group.attr(d), k.markerGroup && (k.markerGroup.attr(d), 
                    k.markerGroup.clip(c ? b.clipRect : null)), k.dataLabelsGroup && k.dataLabelsGroup.attr(d));
                });
                b.clipRect.attr(c || b.clipBox);
            },
            dragStart: function(a) {
                var c = this.chart;
                c.mouseIsDown = a.type;
                c.cancelClick = !1;
                c.mouseDownX = this.mouseDownX = a.chartX;
                c.mouseDownY = this.mouseDownY = a.chartY;
            },
            drag: function(a) {
                var c = this.chart, b = c.options.chart, d = a.chartX, k = a.chartY, e = this.zoomHor, p = this.zoomVert, l = c.plotLeft, g = c.plotTop, m = c.plotWidth, z = c.plotHeight, n, f = this.selectionMarker, r = this.mouseDownX, q = this.mouseDownY, t = b.panKey && a[b.panKey + "Key"];
                f && f.touch || (d < l ? d = l : d > l + m && (d = l + m), k < g ? k = g : k > g + z && (k = g + z), 
                this.hasDragged = Math.sqrt(Math.pow(r - d, 2) + Math.pow(q - k, 2)), 10 < this.hasDragged && (n = c.isInsidePlot(r - l, q - g), 
                c.hasCartesianSeries && (this.zoomX || this.zoomY) && n && !t && !f && (this.selectionMarker = f = c.renderer.rect(l, g, e ? 1 : m, p ? 1 : z, 0).attr({
                    class: "highcharts-selection-marker",
                    zIndex: 7
                }).add(), c.styledMode || f.attr({
                    fill: b.selectionMarkerFill || h("#335cad").setOpacity(.25).get()
                })), f && e && (d -= r, f.attr({
                    width: Math.abs(d),
                    x: (0 < d ? 0 : d) + r
                })), f && p && (d = k - q, f.attr({
                    height: Math.abs(d),
                    y: (0 < d ? 0 : d) + q
                })), n && !f && b.panning && c.pan(a, b.panning)));
            },
            drop: function(a) {
                var c = this, b = this.chart, d = this.hasPinched;
                if (this.selectionMarker) {
                    var k = {
                        originalEvent: a,
                        xAxis: [],
                        yAxis: []
                    }, p = this.selectionMarker, g = p.attr ? p.attr("x") : p.x, l = p.attr ? p.attr("y") : p.y, m = p.attr ? p.attr("width") : p.width, A = p.attr ? p.attr("height") : p.height, z;
                    if (this.hasDragged || d) b.axes.forEach(function(b) {
                        if (b.zoomEnabled && q(b.min) && (d || c[{
                            xAxis: "zoomX",
                            yAxis: "zoomY"
                        }[b.coll]])) {
                            var f = b.horiz, e = "touchend" === a.type ? b.minPixelPadding : 0, p = b.toValue((f ? g : l) + e), f = b.toValue((f ? g + m : l + A) - e);
                            k[b.coll].push({
                                axis: b,
                                min: Math.min(p, f),
                                max: Math.max(p, f)
                            });
                            z = !0;
                        }
                    }), z && v(b, "selection", k, function(a) {
                        b.zoom(t(a, d ? {
                            animation: !1
                        } : null));
                    });
                    n(b.index) && (this.selectionMarker = this.selectionMarker.destroy());
                    d && this.scaleGroups();
                }
                b && n(b.index) && (e(b.container, {
                    cursor: b._cursor
                }), b.cancelClick = 10 < this.hasDragged, b.mouseIsDown = this.hasDragged = this.hasPinched = !1, 
                this.pinchDown = []);
            },
            onContainerMouseDown: function(a) {
                a = this.normalize(a);
                2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));
            },
            onDocumentMouseUp: function(b) {
                B[a.hoverChartIndex] && B[a.hoverChartIndex].pointer.drop(b);
            },
            onDocumentMouseMove: function(a) {
                var c = this.chart, b = this.chartPosition;
                a = this.normalize(a, b);
                !b || this.inClass(a.target, "highcharts-tracker") || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop) || this.reset();
            },
            onContainerMouseLeave: function(b) {
                var c = B[a.hoverChartIndex];
                c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null);
            },
            onContainerMouseMove: function(b) {
                var c = this.chart;
                q(a.hoverChartIndex) && B[a.hoverChartIndex] && B[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);
                b = this.normalize(b);
                b.preventDefault || (b.returnValue = !1);
                "mousedown" === c.mouseIsDown && this.drag(b);
                !this.inClass(b.target, "highcharts-tracker") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b);
            },
            inClass: function(a, c) {
                for (var b; a; ) {
                    if (b = H(a, "class")) {
                        if (-1 !== b.indexOf(c)) return !0;
                        if (-1 !== b.indexOf("highcharts-container")) return !1;
                    }
                    a = a.parentNode;
                }
            },
            onTrackerMouseOut: function(a) {
                var c = this.chart.hoverSeries;
                a = a.relatedTarget || a.toElement;
                this.isDirectTouch = !1;
                if (!(!c || !a || c.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + c.index) && this.inClass(a, "highcharts-tracker"))) c.onMouseOut();
            },
            onContainerClick: function(a) {
                var c = this.chart, b = c.hoverPoint, d = c.plotLeft, k = c.plotTop;
                a = this.normalize(a);
                c.cancelClick || (b && this.inClass(a.target, "highcharts-tracker") ? (v(b.series, "click", t(a, {
                    point: b
                })), c.hoverPoint && b.firePointEvent("click", a)) : (t(a, this.getCoordinates(a)), 
                c.isInsidePlot(a.chartX - d, a.chartY - k) && v(c, "click", a)));
            },
            setDOMEvents: function() {
                var b = this, c = b.chart.container, d = c.ownerDocument;
                c.onmousedown = function(a) {
                    b.onContainerMouseDown(a);
                };
                c.onmousemove = function(a) {
                    b.onContainerMouseMove(a);
                };
                c.onclick = function(a) {
                    b.onContainerClick(a);
                };
                this.unbindContainerMouseLeave = E(c, "mouseleave", b.onContainerMouseLeave);
                a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = E(d, "mouseup", b.onDocumentMouseUp));
                a.hasTouch && (c.ontouchstart = function(a) {
                    b.onContainerTouchStart(a);
                }, c.ontouchmove = function(a) {
                    b.onContainerTouchMove(a);
                }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = E(d, "touchend", b.onDocumentTouchEnd)));
            },
            destroy: function() {
                var b = this;
                b.unDocMouseMove && b.unDocMouseMove();
                this.unbindContainerMouseLeave();
                a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), 
                a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
                clearInterval(b.tooltipTimeout);
                a.objectEach(b, function(a, d) {
                    b[d] = null;
                });
            }
        };
    });
    J(G, "parts/TouchPointer.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.charts, H = a.extend, B = a.noop, h = a.pick;
        H(a.Pointer.prototype, {
            pinchTranslate: function(a, h, t, u, v, n) {
                this.zoomHor && this.pinchTranslateDirection(!0, a, h, t, u, v, n);
                this.zoomVert && this.pinchTranslateDirection(!1, a, h, t, u, v, n);
            },
            pinchTranslateDirection: function(a, h, t, u, v, n, g, d) {
                var e = this.chart, b = a ? "x" : "y", k = a ? "X" : "Y", p = "chart" + k, c = a ? "width" : "height", x = e["plot" + (a ? "Left" : "Top")], q, w, F = d || 1, C = e.inverted, l = e.bounds[a ? "h" : "v"], D = 1 === h.length, A = h[0][p], z = t[0][p], I = !D && h[1][p], f = !D && t[1][p], r;
                t = function() {
                    !D && 20 < Math.abs(A - I) && (F = d || Math.abs(z - f) / Math.abs(A - I));
                    w = (x - z) / F + A;
                    q = e["plot" + (a ? "Width" : "Height")] / F;
                };
                t();
                h = w;
                h < l.min ? (h = l.min, r = !0) : h + q > l.max && (h = l.max - q, r = !0);
                r ? (z -= .8 * (z - g[b][0]), D || (f -= .8 * (f - g[b][1])), t()) : g[b] = [ z, f ];
                C || (n[b] = w - x, n[c] = q);
                n = C ? 1 / F : F;
                v[c] = q;
                v[b] = h;
                u[C ? a ? "scaleY" : "scaleX" : "scale" + k] = F;
                u["translate" + k] = n * x + (z - n * A);
            },
            pinch: function(a) {
                var e = this, t = e.chart, u = e.pinchDown, v = a.touches, n = v.length, g = e.lastValidTouch, d = e.hasZoom, m = e.selectionMarker, b = {}, k = 1 === n && (e.inClass(a.target, "highcharts-tracker") && t.runTrackerClick || e.runChartClick), p = {};
                1 < n && (e.initiated = !0);
                d && e.initiated && !k && a.preventDefault();
                [].map.call(v, function(a) {
                    return e.normalize(a);
                });
                "touchstart" === a.type ? ([].forEach.call(v, function(a, b) {
                    u[b] = {
                        chartX: a.chartX,
                        chartY: a.chartY
                    };
                }), g.x = [ u[0].chartX, u[1] && u[1].chartX ], g.y = [ u[0].chartY, u[1] && u[1].chartY ], 
                t.axes.forEach(function(a) {
                    if (a.zoomEnabled) {
                        var b = t.bounds[a.horiz ? "h" : "v"], c = a.minPixelPadding, d = a.toPixels(Math.min(h(a.options.min, a.dataMin), a.dataMin)), k = a.toPixels(Math.max(h(a.options.max, a.dataMax), a.dataMax)), e = Math.max(d, k);
                        b.min = Math.min(a.pos, Math.min(d, k) - c);
                        b.max = Math.max(a.pos + a.len, e + c);
                    }
                }), e.res = !0) : e.followTouchMove && 1 === n ? this.runPointActions(e.normalize(a)) : u.length && (m || (e.selectionMarker = m = H({
                    destroy: B,
                    touch: !0
                }, t.plotBox)), e.pinchTranslate(u, v, b, m, p, g), e.hasPinched = d, e.scaleGroups(b, p), 
                e.res && (e.res = !1, this.reset(!1, 0)));
            },
            touch: function(e, q) {
                var t = this.chart, u, v;
                if (t.index !== a.hoverChartIndex) this.onContainerMouseLeave({
                    relatedTarget: !0
                });
                a.hoverChartIndex = t.index;
                1 === e.touches.length ? (e = this.normalize(e), (v = t.isInsidePlot(e.chartX - t.plotLeft, e.chartY - t.plotTop)) && !t.openMenu ? (q && this.runPointActions(e), 
                "touchmove" === e.type && (q = this.pinchDown, u = q[0] ? 4 <= Math.sqrt(Math.pow(q[0].chartX - e.chartX, 2) + Math.pow(q[0].chartY - e.chartY, 2)) : !1), 
                h(u, !0) && this.pinch(e)) : q && this.reset()) : 2 === e.touches.length && this.pinch(e);
            },
            onContainerTouchStart: function(a) {
                this.zoomOption(a);
                this.touch(a, !0);
            },
            onContainerTouchMove: function(a) {
                this.touch(a);
            },
            onDocumentTouchEnd: function(e) {
                E[a.hoverChartIndex] && E[a.hoverChartIndex].pointer.drop(e);
            }
        });
    });
    J(G, "parts/MSPointer.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.charts, B = a.css, h = a.doc, e = a.extend, q = a.noop, t = a.Pointer, u = a.removeEvent, v = a.win, n = a.wrap;
        if (!a.hasTouch && (v.PointerEvent || v.MSPointerEvent)) {
            var g = {}, d = !!v.PointerEvent, m = function() {
                var b = [];
                b.item = function(a) {
                    return this[a];
                };
                a.objectEach(g, function(a) {
                    b.push({
                        pageX: a.pageX,
                        pageY: a.pageY,
                        target: a.target
                    });
                });
                return b;
            }, b = function(b, d, c, e) {
                "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !H[a.hoverChartIndex] || (e(b), 
                e = H[a.hoverChartIndex].pointer, e[d]({
                    type: c,
                    target: b.currentTarget,
                    preventDefault: q,
                    touches: m()
                }));
            };
            e(t.prototype, {
                onContainerPointerDown: function(a) {
                    b(a, "onContainerTouchStart", "touchstart", function(a) {
                        g[a.pointerId] = {
                            pageX: a.pageX,
                            pageY: a.pageY,
                            target: a.currentTarget
                        };
                    });
                },
                onContainerPointerMove: function(a) {
                    b(a, "onContainerTouchMove", "touchmove", function(a) {
                        g[a.pointerId] = {
                            pageX: a.pageX,
                            pageY: a.pageY
                        };
                        g[a.pointerId].target || (g[a.pointerId].target = a.currentTarget);
                    });
                },
                onDocumentPointerUp: function(a) {
                    b(a, "onDocumentTouchEnd", "touchend", function(a) {
                        delete g[a.pointerId];
                    });
                },
                batchMSEvents: function(a) {
                    a(this.chart.container, d ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
                    a(this.chart.container, d ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
                    a(h, d ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
                }
            });
            n(t.prototype, "init", function(a, b, c) {
                a.call(this, b, c);
                this.hasZoom && B(b.container, {
                    "-ms-touch-action": "none",
                    "touch-action": "none"
                });
            });
            n(t.prototype, "setDOMEvents", function(a) {
                a.apply(this);
                (this.hasZoom || this.followTouchMove) && this.batchMSEvents(E);
            });
            n(t.prototype, "destroy", function(a) {
                this.batchMSEvents(u);
                a.call(this);
            });
        }
    });
    J(G, "parts/Legend.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.css, B = a.discardElement, h = a.defined, e = a.fireEvent, q = a.isFirefox, t = a.marginNames, u = a.merge, v = a.pick, n = a.setAnimation, g = a.stableSort, d = a.win, m = a.wrap;
        a.Legend = function(a, d) {
            this.init(a, d);
        };
        a.Legend.prototype = {
            init: function(a, d) {
                this.chart = a;
                this.setOptions(d);
                d.enabled && (this.render(), E(this.chart, "endResize", function() {
                    this.legend.positionCheckboxes();
                }), this.proximate ? this.unchartrender = E(this.chart, "render", function() {
                    this.legend.proximatePositions();
                    this.legend.positionItems();
                }) : this.unchartrender && this.unchartrender());
            },
            setOptions: function(a) {
                var b = v(a.padding, 8);
                this.options = a;
                this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = u(this.itemStyle, a.itemHiddenStyle));
                this.itemMarginTop = a.itemMarginTop || 0;
                this.padding = b;
                this.initialItemY = b - 5;
                this.symbolWidth = v(a.symbolWidth, 16);
                this.pages = [];
                this.proximate = "proximate" === a.layout && !this.chart.inverted;
            },
            update: function(a, d) {
                var b = this.chart;
                this.setOptions(u(!0, this.options, a));
                this.destroy();
                b.isDirtyLegend = b.isDirtyBox = !0;
                v(d, !0) && b.redraw();
                e(this, "afterUpdate");
            },
            colorizeItem: function(a, d) {
                a.legendGroup[d ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
                if (!this.chart.styledMode) {
                    var b = this.options, c = a.legendItem, k = a.legendLine, g = a.legendSymbol, m = this.itemHiddenStyle.color, b = d ? b.itemStyle.color : m, h = d ? a.color || m : m, n = a.options && a.options.marker, l = {
                        fill: h
                    };
                    c && c.css({
                        fill: b,
                        color: b
                    });
                    k && k.attr({
                        stroke: h
                    });
                    g && (n && g.isMarker && (l = a.pointAttribs(), d || (l.stroke = l.fill = m)), g.attr(l));
                }
                e(this, "afterColorizeItem", {
                    item: a,
                    visible: d
                });
            },
            positionItems: function() {
                this.allItems.forEach(this.positionItem, this);
                this.chart.isResizing || this.positionCheckboxes();
            },
            positionItem: function(a) {
                var b = this.options, d = b.symbolPadding, b = !b.rtl, c = a._legendItemPos, e = c[0], c = c[1], g = a.checkbox;
                if ((a = a.legendGroup) && a.element) a[h(a.translateY) ? "animate" : "attr"]({
                    translateX: b ? e : this.legendWidth - e - 2 * d - 4,
                    translateY: c
                });
                g && (g.x = e, g.y = c);
            },
            destroyItem: function(a) {
                var b = a.checkbox;
                [ "legendItem", "legendLine", "legendSymbol", "legendGroup" ].forEach(function(b) {
                    a[b] && (a[b] = a[b].destroy());
                });
                b && B(a.checkbox);
            },
            destroy: function() {
                function a(a) {
                    this[a] && (this[a] = this[a].destroy());
                }
                this.getAllItems().forEach(function(b) {
                    [ "legendItem", "legendGroup" ].forEach(a, b);
                });
                "clipRect up down pager nav box title group".split(" ").forEach(a, this);
                this.display = null;
            },
            positionCheckboxes: function() {
                var a = this.group && this.group.alignAttr, d, e = this.clipHeight || this.legendHeight, c = this.titleHeight;
                a && (d = a.translateY, this.allItems.forEach(function(b) {
                    var k = b.checkbox, g;
                    k && (g = d + c + k.y + (this.scrollOffset || 0) + 3, H(k, {
                        left: a.translateX + b.checkboxOffset + k.x - 20 + "px",
                        top: g + "px",
                        display: this.proximate || g > d - 6 && g < d + e - 6 ? "" : "none"
                    }));
                }, this));
            },
            renderTitle: function() {
                var a = this.options, d = this.padding, e = a.title, c = 0;
                e.text && (this.title || (this.title = this.chart.renderer.label(e.text, d - 3, d - 4, null, null, null, a.useHTML, null, "legend-title").attr({
                    zIndex: 1
                }), this.chart.styledMode || this.title.css(e.style), this.title.add(this.group)), 
                e.width || this.title.css({
                    width: this.maxLegendWidth + "px"
                }), a = this.title.getBBox(), c = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
                    translateY: c
                }));
                this.titleHeight = c;
            },
            setText: function(b) {
                var d = this.options;
                b.legendItem.attr({
                    text: d.labelFormat ? a.format(d.labelFormat, b, this.chart.time) : d.labelFormatter.call(b)
                });
            },
            renderItem: function(a) {
                var b = this.chart, d = b.renderer, c = this.options, e = this.symbolWidth, g = c.symbolPadding, m = this.itemStyle, h = this.itemHiddenStyle, n = "horizontal" === c.layout ? v(c.itemDistance, 20) : 0, l = !c.rtl, D = a.legendItem, A = !a.series, z = !A && a.series.drawLegendSymbol ? a.series : a, I = z.options, I = this.createCheckboxForItem && I && I.showCheckbox, n = e + g + n + (I ? 20 : 0), f = c.useHTML, r = a.options.className;
                D || (a.legendGroup = d.g("legend-item").addClass("highcharts-" + z.type + "-series highcharts-color-" + a.colorIndex + (r ? " " + r : "") + (A ? " highcharts-series-" + a.index : "")).attr({
                    zIndex: 1
                }).add(this.scrollGroup), a.legendItem = D = d.text("", l ? e + g : -g, this.baseline || 0, f), 
                b.styledMode || D.css(u(a.visible ? m : h)), D.attr({
                    align: l ? "left" : "right",
                    zIndex: 2
                }).add(a.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(b.styledMode ? 12 : m.fontSize, D), 
                this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, D.attr("y", this.baseline)), 
                this.symbolHeight = c.symbolHeight || this.fontMetrics.f, z.drawLegendSymbol(this, a), 
                this.setItemEvents && this.setItemEvents(a, D, f));
                I && !a.checkbox && this.createCheckboxForItem(a);
                this.colorizeItem(a, a.visible);
                !b.styledMode && m.width || D.css({
                    width: (c.itemWidth || this.widthOption || b.spacingBox.width) - n
                });
                this.setText(a);
                b = D.getBBox();
                a.itemWidth = a.checkboxOffset = c.itemWidth || a.legendItemWidth || b.width + n;
                this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
                this.totalItemWidth += a.itemWidth;
                this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);
            },
            layoutItem: function(a) {
                var b = this.options, d = this.padding, c = "horizontal" === b.layout, e = a.itemHeight, g = b.itemMarginBottom || 0, m = this.itemMarginTop, h = c ? v(b.itemDistance, 20) : 0, n = this.maxLegendWidth, b = b.alignColumns && this.totalItemWidth > n ? this.maxItemWidth : a.itemWidth;
                c && this.itemX - d + b > n && (this.itemX = d, this.lastLineHeight && (this.itemY += m + this.lastLineHeight + g), 
                this.lastLineHeight = 0);
                this.lastItemY = m + this.itemY + g;
                this.lastLineHeight = Math.max(e, this.lastLineHeight);
                a._legendItemPos = [ this.itemX, this.itemY ];
                c ? this.itemX += b : (this.itemY += m + e + g, this.lastLineHeight = e);
                this.offsetWidth = this.widthOption || Math.max((c ? this.itemX - d - (a.checkbox ? 0 : h) : b) + d, this.offsetWidth);
            },
            getAllItems: function() {
                var a = [];
                this.chart.series.forEach(function(b) {
                    var d = b && b.options;
                    b && v(d.showInLegend, h(d.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === d.legendType ? b.data : b)));
                });
                e(this, "afterGetAllItems", {
                    allItems: a
                });
                return a;
            },
            getAlignment: function() {
                var a = this.options;
                return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
            },
            adjustMargins: function(a, d) {
                var b = this.chart, c = this.options, e = this.getAlignment(), k = void 0 !== b.options.title.margin ? b.titleOffset + b.options.title.margin : 0;
                e && [ /(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/ ].forEach(function(g, m) {
                    g.test(e) && !h(a[m]) && (b[t[m]] = Math.max(b[t[m]], b.legend[(m + 1) % 2 ? "legendHeight" : "legendWidth"] + [ 1, -1, -1, 1 ][m] * c[m % 2 ? "x" : "y"] + v(c.margin, 12) + d[m] + (0 === m && (0 === b.titleOffset ? 0 : k))));
                });
            },
            proximatePositions: function() {
                var b = this.chart, d = [], e = "left" === this.options.align;
                this.allItems.forEach(function(c) {
                    var k, g;
                    g = e;
                    var m;
                    c.yAxis && c.points && (c.xAxis.options.reversed && (g = !g), k = a.find(g ? c.points : c.points.slice(0).reverse(), function(b) {
                        return a.isNumber(b.plotY);
                    }), g = c.legendGroup.getBBox().height, m = c.yAxis.top - b.plotTop, c.visible ? (k = k ? k.plotY : c.yAxis.height, 
                    k += m - .3 * g) : k = m + c.yAxis.height, d.push({
                        target: k,
                        size: g,
                        item: c
                    }));
                }, this);
                a.distribute(d, b.plotHeight);
                d.forEach(function(a) {
                    a.item._legendItemPos[1] = b.plotTop - b.spacing[0] + a.pos;
                });
            },
            render: function() {
                var b = this.chart, d = b.renderer, m = this.group, c, h, n, w = this.box, q = this.options, C = this.padding;
                this.itemX = C;
                this.itemY = this.initialItemY;
                this.lastItemY = this.offsetWidth = 0;
                this.widthOption = a.relativeLength(q.width, b.spacingBox.width - C);
                c = b.spacingBox.width - 2 * C - q.x;
                -1 < [ "rm", "lm" ].indexOf(this.getAlignment().substring(0, 2)) && (c /= 2);
                this.maxLegendWidth = this.widthOption || c;
                m || (this.group = m = d.g("legend").attr({
                    zIndex: 7
                }).add(), this.contentGroup = d.g().attr({
                    zIndex: 1
                }).add(m), this.scrollGroup = d.g().add(this.contentGroup));
                this.renderTitle();
                c = this.getAllItems();
                g(c, function(a, b) {
                    return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
                });
                q.reversed && c.reverse();
                this.allItems = c;
                this.display = h = !!c.length;
                this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
                c.forEach(this.renderItem, this);
                c.forEach(this.layoutItem, this);
                c = (this.widthOption || this.offsetWidth) + C;
                n = this.lastItemY + this.lastLineHeight + this.titleHeight;
                n = this.handleOverflow(n);
                n += C;
                w || (this.box = w = d.rect().addClass("highcharts-legend-box").attr({
                    r: q.borderRadius
                }).add(m), w.isNew = !0);
                b.styledMode || w.attr({
                    stroke: q.borderColor,
                    "stroke-width": q.borderWidth || 0,
                    fill: q.backgroundColor || "none"
                }).shadow(q.shadow);
                0 < c && 0 < n && (w[w.isNew ? "attr" : "animate"](w.crisp.call({}, {
                    x: 0,
                    y: 0,
                    width: c,
                    height: n
                }, w.strokeWidth())), w.isNew = !1);
                w[h ? "show" : "hide"]();
                b.styledMode && "none" === m.getStyle("display") && (c = n = 0);
                this.legendWidth = c;
                this.legendHeight = n;
                h && (d = b.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (w = d.y + b.titleOffset, 
                d = u(d, {
                    y: 0 < b.titleOffset ? w += b.options.title.margin : w
                })), m.align(u(q, {
                    width: c,
                    height: n,
                    verticalAlign: this.proximate ? "top" : q.verticalAlign
                }), !0, d));
                this.proximate || this.positionItems();
                e(this, "afterRender");
            },
            handleOverflow: function(a) {
                var b = this, d = this.chart, c = d.renderer, e = this.options, g = e.y, m = this.padding, g = d.spacingBox.height + ("top" === e.verticalAlign ? -g : g) - m, h = e.maxHeight, n, l = this.clipRect, D = e.navigation, A = v(D.animation, !0), z = D.arrowSize || 12, I = this.nav, f = this.pages, r, q = this.allItems, t = function(a) {
                    "number" === typeof a ? l.attr({
                        height: a
                    }) : l && (b.clipRect = l.destroy(), b.contentGroup.clip());
                    b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + m + "px,9999px," + (m + a) + "px,0)" : "auto");
                }, L = function(a) {
                    b[a] = c.circle(0, 0, 1.3 * z).translate(z / 2, z / 2).add(I);
                    d.styledMode || b[a].attr("fill", "rgba(0,0,0,0.0001)");
                    return b[a];
                };
                "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (g /= 2);
                h && (g = Math.min(g, h));
                f.length = 0;
                a > g && !1 !== D.enabled ? (this.clipHeight = n = Math.max(g - 20 - this.titleHeight - m, 0), 
                this.currentPage = v(this.currentPage, 1), this.fullHeight = a, q.forEach(function(a, b) {
                    var c = a._legendItemPos[1], d = Math.round(a.legendItem.getBBox().height), l = f.length;
                    if (!l || c - f[l - 1] > n && (r || c) !== f[l - 1]) f.push(r || c), l++;
                    a.pageIx = l - 1;
                    r && (q[b - 1].pageIx = l - 1);
                    b === q.length - 1 && c + d - f[l - 1] > n && c !== r && (f.push(c), a.pageIx = l);
                    c !== r && (r = c);
                }), l || (l = b.clipRect = c.clipRect(0, m, 9999, 0), b.contentGroup.clip(l)), t(n), 
                I || (this.nav = I = c.g().attr({
                    zIndex: 1
                }).add(this.group), this.up = c.symbol("triangle", 0, 0, z, z).add(I), L("upTracker").on("click", function() {
                    b.scroll(-1, A);
                }), this.pager = c.text("", 15, 10).addClass("highcharts-legend-navigation"), d.styledMode || this.pager.css(D.style), 
                this.pager.add(I), this.down = c.symbol("triangle-down", 0, 0, z, z).add(I), L("downTracker").on("click", function() {
                    b.scroll(1, A);
                })), b.scroll(0), a = g) : I && (t(), this.nav = I.destroy(), this.scrollGroup.attr({
                    translateY: 1
                }), this.clipHeight = 0);
                return a;
            },
            scroll: function(a, d) {
                var b = this.pages, c = b.length, e = this.currentPage + a;
                a = this.clipHeight;
                var k = this.options.navigation, g = this.pager, m = this.padding;
                e > c && (e = c);
                0 < e && (void 0 !== d && n(d, this.chart), this.nav.attr({
                    translateX: m,
                    translateY: a + this.padding + 7 + this.titleHeight,
                    visibility: "visible"
                }), [ this.up, this.upTracker ].forEach(function(a) {
                    a.attr({
                        class: 1 === e ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }), g.attr({
                    text: e + "/" + c
                }), [ this.down, this.downTracker ].forEach(function(a) {
                    a.attr({
                        x: 18 + this.pager.getBBox().width,
                        class: e === c ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                }, this), this.chart.styledMode || (this.up.attr({
                    fill: 1 === e ? k.inactiveColor : k.activeColor
                }), this.upTracker.css({
                    cursor: 1 === e ? "default" : "pointer"
                }), this.down.attr({
                    fill: e === c ? k.inactiveColor : k.activeColor
                }), this.downTracker.css({
                    cursor: e === c ? "default" : "pointer"
                })), this.scrollOffset = -b[e - 1] + this.initialItemY, this.scrollGroup.animate({
                    translateY: this.scrollOffset
                }), this.currentPage = e, this.positionCheckboxes());
            }
        };
        a.LegendSymbolMixin = {
            drawRectangle: function(a, d) {
                var b = a.symbolHeight, c = a.options.squareSymbol;
                d.legendSymbol = this.chart.renderer.rect(c ? (a.symbolWidth - b) / 2 : 0, a.baseline - b + 1, c ? b : a.symbolWidth, b, v(a.options.symbolRadius, b / 2)).addClass("highcharts-point").attr({
                    zIndex: 3
                }).add(d.legendGroup);
            },
            drawLineMarker: function(a) {
                var b = this.options, d = b.marker, c = a.symbolWidth, e = a.symbolHeight, g = e / 2, m = this.chart.renderer, h = this.legendGroup;
                a = a.baseline - Math.round(.3 * a.fontMetrics.b);
                var n = {};
                this.chart.styledMode || (n = {
                    "stroke-width": b.lineWidth || 0
                }, b.dashStyle && (n.dashstyle = b.dashStyle));
                this.legendLine = m.path([ "M", 0, a, "L", c, a ]).addClass("highcharts-graph").attr(n).add(h);
                d && !1 !== d.enabled && c && (b = Math.min(v(d.radius, g), g), 0 === this.symbol.indexOf("url") && (d = u(d, {
                    width: e,
                    height: e
                }), b = 0), this.legendSymbol = d = m.symbol(this.symbol, c / 2 - b, a - b, 2 * b, 2 * b, d).addClass("highcharts-point").add(h), 
                d.isMarker = !0);
            }
        };
        (/Trident\/7\.0/.test(d.navigator && d.navigator.userAgent) || q) && m(a.Legend.prototype, "positionItem", function(a, d) {
            var b = this, c = function() {
                d._legendItemPos && a.call(b, d);
            };
            c();
            b.bubbleLegend || setTimeout(c);
        });
    });
    J(G, "parts/Chart.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.animate, B = a.animObject, h = a.attr, e = a.doc, q = a.Axis, t = a.createElement, u = a.defaultOptions, v = a.discardElement, n = a.charts, g = a.css, d = a.defined, m = a.extend, b = a.find, k = a.fireEvent, p = a.isNumber, c = a.isObject, x = a.isString, K = a.Legend, w = a.marginNames, F = a.merge, C = a.objectEach, l = a.Pointer, D = a.pick, A = a.pInt, z = a.removeEvent, I = a.seriesTypes, f = a.splat, r = a.syncTimeout, Q = a.win, N = a.Chart = function() {
            this.getArgs.apply(this, arguments);
        };
        a.chart = function(a, b, c) {
            return new N(a, b, c);
        };
        m(N.prototype, {
            callbacks: [],
            getArgs: function() {
                var a = [].slice.call(arguments);
                if (x(a[0]) || a[0].nodeName) this.renderTo = a.shift();
                this.init(a[0], a[1]);
            },
            init: function(b, f) {
                var d, l = b.series, e = b.plotOptions || {};
                k(this, "init", {
                    args: arguments
                }, function() {
                    b.series = null;
                    d = F(u, b);
                    C(d.plotOptions, function(a, b) {
                        c(a) && (a.tooltip = e[b] && F(e[b].tooltip) || void 0);
                    });
                    d.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
                    d.series = b.series = l;
                    this.userOptions = b;
                    var g = d.chart, m = g.events;
                    this.margin = [];
                    this.spacing = [];
                    this.bounds = {
                        h: {},
                        v: {}
                    };
                    this.labelCollectors = [];
                    this.callback = f;
                    this.isResizing = 0;
                    this.options = d;
                    this.axes = [];
                    this.series = [];
                    this.time = b.time && Object.keys(b.time).length ? new a.Time(b.time) : a.time;
                    this.styledMode = g.styledMode;
                    this.hasCartesianSeries = g.showAxes;
                    var A = this;
                    A.index = n.length;
                    n.push(A);
                    a.chartCount++;
                    m && C(m, function(b, c) {
                        a.isFunction(b) && E(A, c, b);
                    });
                    A.xAxis = [];
                    A.yAxis = [];
                    A.pointCount = A.colorCounter = A.symbolCounter = 0;
                    k(A, "afterInit");
                    A.firstRender();
                });
            },
            initSeries: function(b) {
                var c = this.options.chart;
                (c = I[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0, this);
                c = new c();
                c.init(this, b);
                return c;
            },
            orderSeries: function(a) {
                var b = this.series;
                for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName());
            },
            isInsidePlot: function(a, b, c) {
                var f = c ? b : a;
                a = c ? a : b;
                return 0 <= f && f <= this.plotWidth && 0 <= a && a <= this.plotHeight;
            },
            redraw: function(b) {
                k(this, "beforeRedraw");
                var c = this.axes, f = this.series, d = this.pointer, l = this.legend, e = this.userOptions.legend, g = this.isDirtyLegend, A, p, r = this.hasCartesianSeries, h = this.isDirtyBox, D, z = this.renderer, n = z.isHidden(), x = [];
                this.setResponsive && this.setResponsive(!1);
                a.setAnimation(b, this);
                n && this.temporaryDisplay();
                this.layOutTitles();
                for (b = f.length; b--; ) if (D = f[b], D.options.stacking && (A = !0, D.isDirty)) {
                    p = !0;
                    break;
                }
                if (p) for (b = f.length; b--; ) D = f[b], D.options.stacking && (D.isDirty = !0);
                f.forEach(function(a) {
                    a.isDirty && ("point" === a.options.legendType ? (a.updateTotals && a.updateTotals(), 
                    g = !0) : e && (e.labelFormatter || e.labelFormat) && (g = !0));
                    a.isDirtyData && k(a, "updatedData");
                });
                g && l && l.options.enabled && (l.render(), this.isDirtyLegend = !1);
                A && this.getStacks();
                r && c.forEach(function(a) {
                    a.updateNames();
                    a.setScale();
                });
                this.getMargins();
                r && (c.forEach(function(a) {
                    a.isDirty && (h = !0);
                }), c.forEach(function(a) {
                    var b = a.min + "," + a.max;
                    a.extKey !== b && (a.extKey = b, x.push(function() {
                        k(a, "afterSetExtremes", m(a.eventArgs, a.getExtremes()));
                        delete a.eventArgs;
                    }));
                    (h || A) && a.redraw();
                }));
                h && this.drawChartBox();
                k(this, "predraw");
                f.forEach(function(a) {
                    (h || a.isDirty) && a.visible && a.redraw();
                    a.isDirtyData = !1;
                });
                d && d.reset(!0);
                z.draw();
                k(this, "redraw");
                k(this, "render");
                n && this.temporaryDisplay(!0);
                x.forEach(function(a) {
                    a.call();
                });
            },
            get: function(a) {
                function c(b) {
                    return b.id === a || b.options && b.options.id === a;
                }
                var f, d = this.series, l;
                f = b(this.axes, c) || b(this.series, c);
                for (l = 0; !f && l < d.length; l++) f = b(d[l].points || [], c);
                return f;
            },
            getAxes: function() {
                var a = this, b = this.options, c = b.xAxis = f(b.xAxis || {}), b = b.yAxis = f(b.yAxis || {});
                k(this, "getAxes");
                c.forEach(function(a, b) {
                    a.index = b;
                    a.isX = !0;
                });
                b.forEach(function(a, b) {
                    a.index = b;
                });
                c.concat(b).forEach(function(b) {
                    new q(a, b);
                });
                k(this, "afterGetAxes");
            },
            getSelectedPoints: function() {
                var a = [];
                this.series.forEach(function(b) {
                    a = a.concat((b[b.hasGroupedData ? "points" : "data"] || []).filter(function(a) {
                        return a.selected;
                    }));
                });
                return a;
            },
            getSelectedSeries: function() {
                return this.series.filter(function(a) {
                    return a.selected;
                });
            },
            setTitle: function(a, b, c) {
                var f = this, d = f.options, l = f.styledMode, e;
                e = d.title = F(!l && {
                    style: {
                        color: "#333333",
                        fontSize: d.isStock ? "16px" : "18px"
                    }
                }, d.title, a);
                d = d.subtitle = F(!l && {
                    style: {
                        color: "#666666"
                    }
                }, d.subtitle, b);
                [ [ "title", a, e ], [ "subtitle", b, d ] ].forEach(function(a, b) {
                    var c = a[0], d = f[c], e = a[1];
                    a = a[2];
                    d && e && (f[c] = d = d.destroy());
                    a && !d && (f[c] = f.renderer.text(a.text, 0, 0, a.useHTML).attr({
                        align: a.align,
                        class: "highcharts-" + c,
                        zIndex: a.zIndex || 4
                    }).add(), f[c].update = function(a) {
                        f.setTitle(!b && a, b && a);
                    }, l || f[c].css(a.style));
                });
                f.layOutTitles(c);
            },
            layOutTitles: function(a) {
                var b = 0, c, f = this.renderer, d = this.spacingBox;
                [ "title", "subtitle" ].forEach(function(a) {
                    var c = this[a], l = this.options[a];
                    a = "title" === a ? -3 : l.verticalAlign ? 0 : b + 2;
                    var e;
                    c && (this.styledMode || (e = l.style.fontSize), e = f.fontMetrics(e, c).b, c.css({
                        width: (l.width || d.width + l.widthAdjust) + "px"
                    }).align(m({
                        y: a + e
                    }, l), !1, "spacingBox"), l.floating || l.verticalAlign || (b = Math.ceil(b + c.getBBox(l.useHTML).height)));
                }, this);
                c = this.titleOffset !== b;
                this.titleOffset = b;
                !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && D(a, !0) && this.isDirtyBox && this.redraw());
            },
            getChartSize: function() {
                var b = this.options.chart, c = b.width, b = b.height, f = this.renderTo;
                d(c) || (this.containerWidth = a.getStyle(f, "width"));
                d(b) || (this.containerHeight = a.getStyle(f, "height"));
                this.chartWidth = Math.max(0, c || this.containerWidth || 600);
                this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            },
            temporaryDisplay: function(b) {
                var c = this.renderTo;
                if (b) for (;c && c.style; ) c.hcOrigStyle && (a.css(c, c.hcOrigStyle), delete c.hcOrigStyle), 
                c.hcOrigDetached && (e.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode; else for (;c && c.style; ) {
                    e.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, e.body.appendChild(c));
                    if ("none" === a.getStyle(c, "display", !1) || c.hcOricDetached) c.hcOrigStyle = {
                        display: c.style.display,
                        height: c.style.height,
                        overflow: c.style.overflow
                    }, b = {
                        display: "block",
                        overflow: "hidden"
                    }, c !== this.renderTo && (b.height = 0), a.css(c, b), c.offsetWidth || c.style.setProperty("display", "block", "important");
                    c = c.parentNode;
                    if (c === e.body) break;
                }
            },
            setClassName: function(a) {
                this.container.className = "highcharts-container " + (a || "");
            },
            getContainer: function() {
                var b, c = this.options, f = c.chart, d, l;
                b = this.renderTo;
                var r = a.uniqueKey(), D, z;
                b || (this.renderTo = b = f.renderTo);
                x(b) && (this.renderTo = b = e.getElementById(b));
                b || a.error(13, !0, this);
                d = A(h(b, "data-highcharts-chart"));
                p(d) && n[d] && n[d].hasRendered && n[d].destroy();
                h(b, "data-highcharts-chart", this.index);
                b.innerHTML = "";
                f.skipClone || b.offsetWidth || this.temporaryDisplay();
                this.getChartSize();
                d = this.chartWidth;
                l = this.chartHeight;
                g(b, {
                    overflow: "hidden"
                });
                this.styledMode || (D = m({
                    position: "relative",
                    overflow: "hidden",
                    width: d + "px",
                    height: l + "px",
                    textAlign: "left",
                    lineHeight: "normal",
                    zIndex: 0,
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
                }, f.style));
                this.container = b = t("div", {
                    id: r
                }, D, b);
                this._cursor = b.style.cursor;
                this.renderer = new (a[f.renderer] || a.Renderer)(b, d, l, null, f.forExport, c.exporting && c.exporting.allowHTML, this.styledMode);
                this.setClassName(f.className);
                if (this.styledMode) for (z in c.defs) this.renderer.definition(c.defs[z]); else this.renderer.setStyle(f.style);
                this.renderer.chartIndex = this.index;
                k(this, "afterGetContainer");
            },
            getMargins: function(a) {
                var b = this.spacing, c = this.margin, f = this.titleOffset;
                this.resetMargins();
                f && !d(c[0]) && (this.plotTop = Math.max(this.plotTop, f + this.options.title.margin + b[0]));
                this.legend && this.legend.display && this.legend.adjustMargins(c, b);
                k(this, "getMargins");
                a || this.getAxisMargins();
            },
            getAxisMargins: function() {
                var a = this, b = a.axisOffset = [ 0, 0, 0, 0 ], c = a.margin;
                a.hasCartesianSeries && a.axes.forEach(function(a) {
                    a.visible && a.getOffset();
                });
                w.forEach(function(f, l) {
                    d(c[l]) || (a[f] += b[l]);
                });
                a.setChartSize();
            },
            reflow: function(b) {
                var c = this, f = c.options.chart, l = c.renderTo, g = d(f.width) && d(f.height), k = f.width || a.getStyle(l, "width"), f = f.height || a.getStyle(l, "height"), l = b ? b.target : Q;
                if (!g && !c.isPrinting && k && f && (l === Q || l === e)) {
                    if (k !== c.containerWidth || f !== c.containerHeight) a.clearTimeout(c.reflowTimeout), 
                    c.reflowTimeout = r(function() {
                        c.container && c.setSize(void 0, void 0, !1);
                    }, b ? 100 : 0);
                    c.containerWidth = k;
                    c.containerHeight = f;
                }
            },
            setReflow: function(a) {
                var b = this;
                !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = E(Q, "resize", function(a) {
                    b.reflow(a);
                }), E(this, "destroy", this.unbindReflow));
            },
            setSize: function(b, c, f) {
                var d = this, l = d.renderer, e;
                d.isResizing += 1;
                a.setAnimation(f, d);
                d.oldChartHeight = d.chartHeight;
                d.oldChartWidth = d.chartWidth;
                void 0 !== b && (d.options.chart.width = b);
                void 0 !== c && (d.options.chart.height = c);
                d.getChartSize();
                d.styledMode || (e = l.globalAnimation, (e ? H : g)(d.container, {
                    width: d.chartWidth + "px",
                    height: d.chartHeight + "px"
                }, e));
                d.setChartSize(!0);
                l.setSize(d.chartWidth, d.chartHeight, f);
                d.axes.forEach(function(a) {
                    a.isDirty = !0;
                    a.setScale();
                });
                d.isDirtyLegend = !0;
                d.isDirtyBox = !0;
                d.layOutTitles();
                d.getMargins();
                d.redraw(f);
                d.oldChartHeight = null;
                k(d, "resize");
                r(function() {
                    d && k(d, "endResize", null, function() {
                        --d.isResizing;
                    });
                }, B(e).duration);
            },
            setChartSize: function(a) {
                var b = this.inverted, c = this.renderer, f = this.chartWidth, d = this.chartHeight, l = this.options.chart, e = this.spacing, g = this.clipOffset, m, A, p, r;
                this.plotLeft = m = Math.round(this.plotLeft);
                this.plotTop = A = Math.round(this.plotTop);
                this.plotWidth = p = Math.max(0, Math.round(f - m - this.marginRight));
                this.plotHeight = r = Math.max(0, Math.round(d - A - this.marginBottom));
                this.plotSizeX = b ? r : p;
                this.plotSizeY = b ? p : r;
                this.plotBorderWidth = l.plotBorderWidth || 0;
                this.spacingBox = c.spacingBox = {
                    x: e[3],
                    y: e[0],
                    width: f - e[3] - e[1],
                    height: d - e[0] - e[2]
                };
                this.plotBox = c.plotBox = {
                    x: m,
                    y: A,
                    width: p,
                    height: r
                };
                f = 2 * Math.floor(this.plotBorderWidth / 2);
                b = Math.ceil(Math.max(f, g[3]) / 2);
                c = Math.ceil(Math.max(f, g[0]) / 2);
                this.clipBox = {
                    x: b,
                    y: c,
                    width: Math.floor(this.plotSizeX - Math.max(f, g[1]) / 2 - b),
                    height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, g[2]) / 2 - c))
                };
                a || this.axes.forEach(function(a) {
                    a.setAxisSize();
                    a.setAxisTranslation();
                });
                k(this, "afterSetChartSize", {
                    skipAxes: a
                });
            },
            resetMargins: function() {
                k(this, "resetMargins");
                var a = this, b = a.options.chart;
                [ "margin", "spacing" ].forEach(function(f) {
                    var d = b[f], l = c(d) ? d : [ d, d, d, d ];
                    [ "Top", "Right", "Bottom", "Left" ].forEach(function(c, d) {
                        a[f][d] = D(b[f + c], l[d]);
                    });
                });
                w.forEach(function(b, c) {
                    a[b] = D(a.margin[c], a.spacing[c]);
                });
                a.axisOffset = [ 0, 0, 0, 0 ];
                a.clipOffset = [ 0, 0, 0, 0 ];
            },
            drawChartBox: function() {
                var a = this.options.chart, b = this.renderer, c = this.chartWidth, f = this.chartHeight, d = this.chartBackground, l = this.plotBackground, e = this.plotBorder, g, m = this.styledMode, A = this.plotBGImage, p = a.backgroundColor, r = a.plotBackgroundColor, h = a.plotBackgroundImage, D, z = this.plotLeft, n = this.plotTop, x = this.plotWidth, w = this.plotHeight, C = this.plotBox, I = this.clipRect, q = this.clipBox, t = "animate";
                d || (this.chartBackground = d = b.rect().addClass("highcharts-background").add(), 
                t = "attr");
                if (m) g = D = d.strokeWidth(); else {
                    g = a.borderWidth || 0;
                    D = g + (a.shadow ? 8 : 0);
                    p = {
                        fill: p || "none"
                    };
                    if (g || d["stroke-width"]) p.stroke = a.borderColor, p["stroke-width"] = g;
                    d.attr(p).shadow(a.shadow);
                }
                d[t]({
                    x: D / 2,
                    y: D / 2,
                    width: c - D - g % 2,
                    height: f - D - g % 2,
                    r: a.borderRadius
                });
                t = "animate";
                l || (t = "attr", this.plotBackground = l = b.rect().addClass("highcharts-plot-background").add());
                l[t](C);
                m || (l.attr({
                    fill: r || "none"
                }).shadow(a.plotShadow), h && (A ? A.animate(C) : this.plotBGImage = b.image(h, z, n, x, w).add()));
                I ? I.animate({
                    width: q.width,
                    height: q.height
                }) : this.clipRect = b.clipRect(q);
                t = "animate";
                e || (t = "attr", this.plotBorder = e = b.rect().addClass("highcharts-plot-border").attr({
                    zIndex: 1
                }).add());
                m || e.attr({
                    stroke: a.plotBorderColor,
                    "stroke-width": a.plotBorderWidth || 0,
                    fill: "none"
                });
                e[t](e.crisp({
                    x: z,
                    y: n,
                    width: x,
                    height: w
                }, -e.strokeWidth()));
                this.isDirtyBox = !1;
                k(this, "afterDrawChartBox");
            },
            propFromSeries: function() {
                var a = this, b = a.options.chart, c, f = a.options.series, d, l;
                [ "inverted", "angular", "polar" ].forEach(function(e) {
                    c = I[b.type || b.defaultSeriesType];
                    l = b[e] || c && c.prototype[e];
                    for (d = f && f.length; !l && d--; ) (c = I[f[d].type]) && c.prototype[e] && (l = !0);
                    a[e] = l;
                });
            },
            linkSeries: function() {
                var a = this, b = a.series;
                b.forEach(function(a) {
                    a.linkedSeries.length = 0;
                });
                b.forEach(function(b) {
                    var c = b.options.linkedTo;
                    x(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), 
                    b.linkedParent = c, b.visible = D(b.options.visible, c.options.visible, b.visible));
                });
                k(this, "afterLinkSeries");
            },
            renderSeries: function() {
                this.series.forEach(function(a) {
                    a.translate();
                    a.render();
                });
            },
            renderLabels: function() {
                var a = this, b = a.options.labels;
                b.items && b.items.forEach(function(c) {
                    var f = m(b.style, c.style), d = A(f.left) + a.plotLeft, l = A(f.top) + a.plotTop + 12;
                    delete f.left;
                    delete f.top;
                    a.renderer.text(c.html, d, l).attr({
                        zIndex: 2
                    }).css(f).add();
                });
            },
            render: function() {
                var a = this.axes, b = this.renderer, c = this.options, f = 0, d, l, e;
                this.setTitle();
                this.legend = new K(this, c.legend);
                this.getStacks && this.getStacks();
                this.getMargins(!0);
                this.setChartSize();
                c = this.plotWidth;
                a.some(function(a) {
                    if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return f = 21, 
                    !0;
                });
                d = this.plotHeight = Math.max(this.plotHeight - f, 0);
                a.forEach(function(a) {
                    a.setScale();
                });
                this.getAxisMargins();
                l = 1.1 < c / this.plotWidth;
                e = 1.05 < d / this.plotHeight;
                if (l || e) a.forEach(function(a) {
                    (a.horiz && l || !a.horiz && e) && a.setTickInterval(!0);
                }), this.getMargins();
                this.drawChartBox();
                this.hasCartesianSeries && a.forEach(function(a) {
                    a.visible && a.render();
                });
                this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({
                    zIndex: 3
                }).add());
                this.renderSeries();
                this.renderLabels();
                this.addCredits();
                this.setResponsive && this.setResponsive();
                this.hasRendered = !0;
            },
            addCredits: function(a) {
                var b = this;
                a = F(!0, this.options.credits, a);
                a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
                    a.href && (Q.location.href = a.href);
                }).attr({
                    align: a.position.align,
                    zIndex: 8
                }), b.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), 
                this.credits.update = function(a) {
                    b.credits = b.credits.destroy();
                    b.addCredits(a);
                });
            },
            destroy: function() {
                var b = this, c = b.axes, f = b.series, d = b.container, l, e = d && d.parentNode;
                k(b, "destroy");
                b.renderer.forExport ? a.erase(n, b) : n[b.index] = void 0;
                a.chartCount--;
                b.renderTo.removeAttribute("data-highcharts-chart");
                z(b);
                for (l = c.length; l--; ) c[l] = c[l].destroy();
                this.scroller && this.scroller.destroy && this.scroller.destroy();
                for (l = f.length; l--; ) f[l] = f[l].destroy();
                "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(a) {
                    var c = b[a];
                    c && c.destroy && (b[a] = c.destroy());
                });
                d && (d.innerHTML = "", z(d), e && v(d));
                C(b, function(a, c) {
                    delete b[c];
                });
            },
            firstRender: function() {
                var b = this, c = b.options;
                if (!b.isReadyToRender || b.isReadyToRender()) {
                    b.getContainer();
                    b.resetMargins();
                    b.setChartSize();
                    b.propFromSeries();
                    b.getAxes();
                    (a.isArray(c.series) ? c.series : []).forEach(function(a) {
                        b.initSeries(a);
                    });
                    b.linkSeries();
                    k(b, "beforeRender");
                    l && (b.pointer = new l(b, c));
                    b.render();
                    if (!b.renderer.imgCount && b.onload) b.onload();
                    b.temporaryDisplay(!0);
                }
            },
            onload: function() {
                this.callbacks.concat([ this.callback ]).forEach(function(a) {
                    a && void 0 !== this.index && a.apply(this, [ this ]);
                }, this);
                k(this, "load");
                k(this, "render");
                d(this.index) && this.setReflow(this.options.chart.reflow);
                this.onload = null;
            }
        });
    });
    J(G, "parts/ScrollablePlotArea.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.Chart;
        E(H, "afterSetChartSize", function(B) {
            var h = this.options.chart.scrollablePlotArea, e = h && h.minWidth, h = h && h.minHeight, q;
            if (!this.renderer.forExport) {
                if (e) {
                    if (this.scrollablePixelsX = e = Math.max(0, e - this.chartWidth)) this.plotWidth += e, 
                    this.inverted ? this.clipBox.height += e : this.clipBox.width += e, q = {
                        1: {
                            name: "right",
                            value: e
                        }
                    };
                } else h && (this.scrollablePixelsY = e = Math.max(0, h - this.chartHeight)) && (this.plotHeight += e, 
                this.inverted ? this.clipBox.width += e : this.clipBox.height += e, q = {
                    2: {
                        name: "bottom",
                        value: e
                    }
                });
                q && !B.skipAxes && this.axes.forEach(function(e) {
                    q[e.side] ? e.getPlotLinePath = function() {
                        var h = q[e.side].name, t = this[h], n;
                        this[h] = t - q[e.side].value;
                        n = a.Axis.prototype.getPlotLinePath.apply(this, arguments);
                        this[h] = t;
                        return n;
                    } : (e.setAxisSize(), e.setAxisTranslation());
                });
            }
        });
        E(H, "render", function() {
            this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), 
            this.applyFixed()) : this.fixedDiv && this.applyFixed();
        });
        H.prototype.setUpScrolling = function() {
            var B = {
                WebkitOverflowScrolling: "touch",
                overflowX: "hidden",
                overflowY: "hidden"
            };
            this.scrollablePixelsX && (B.overflowX = "auto");
            this.scrollablePixelsY && (B.overflowY = "auto");
            this.scrollingContainer = a.createElement("div", {
                className: "highcharts-scrolling"
            }, B, this.renderTo);
            this.innerContainer = a.createElement("div", {
                className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
        };
        H.prototype.moveFixedElements = function() {
            var a = this.container, h = this.fixedRenderer, e = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-reset-zoom .highcharts-subtitle .highcharts-title .highcharts-legend-checkbox".split(" "), q;
            this.scrollablePixelsX && !this.inverted ? q = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? q = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? q = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (q = ".highcharts-yaxis");
            e.push(q, q + "-labels");
            e.forEach(function(e) {
                [].forEach.call(a.querySelectorAll(e), function(a) {
                    (a.namespaceURI === h.SVG_NS ? h.box : h.box.parentNode).appendChild(a);
                    a.style.pointerEvents = "auto";
                });
            });
        };
        H.prototype.applyFixed = function() {
            var B, h, e = !this.fixedDiv, q = this.options.chart.scrollablePlotArea;
            e ? (this.fixedDiv = a.createElement("div", {
                className: "highcharts-fixed"
            }, {
                position: "absolute",
                overflow: "hidden",
                pointerEvents: "none",
                zIndex: 2
            }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), 
            this.renderTo.style.overflow = "visible", this.fixedRenderer = B = new a.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), 
            this.scrollableMask = B.path().attr({
                fill: a.color(this.options.chart.backgroundColor || "#fff").setOpacity(a.pick(q.opacity, .85)).get(),
                zIndex: -1
            }).addClass("highcharts-scrollable-mask").add(), this.moveFixedElements(), E(this, "afterShowResetZoom", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            B = this.chartWidth + (this.scrollablePixelsX || 0);
            h = this.chartHeight + (this.scrollablePixelsY || 0);
            a.stop(this.container);
            this.container.style.width = B + "px";
            this.container.style.height = h + "px";
            this.renderer.boxWrapper.attr({
                width: B,
                height: h,
                viewBox: [ 0, 0, B, h ].join(" ")
            });
            this.chartBackground.attr({
                width: B,
                height: h
            });
            this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + "px");
            e && (q.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * q.scrollPositionX), 
            q.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * q.scrollPositionY));
            h = this.axisOffset;
            e = this.plotTop - h[0] - 1;
            q = this.plotLeft - h[3] - 1;
            B = this.plotTop + this.plotHeight + h[2] + 1;
            h = this.plotLeft + this.plotWidth + h[1] + 1;
            var t = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), u = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0), e = this.scrollablePixelsX ? [ "M", 0, e, "L", this.plotLeft - 1, e, "L", this.plotLeft - 1, B, "L", 0, B, "Z", "M", t, e, "L", this.chartWidth, e, "L", this.chartWidth, B, "L", t, B, "Z" ] : this.scrollablePixelsY ? [ "M", q, 0, "L", q, this.plotTop - 1, "L", h, this.plotTop - 1, "L", h, 0, "Z", "M", q, u, "L", q, this.chartHeight, "L", h, this.chartHeight, "L", h, u, "Z" ] : [ "M", 0, 0 ];
            "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
                d: e
            });
        };
    });
    J(G, "parts/Point.js", [ G["parts/Globals.js"] ], function(a) {
        var E, H = a.extend, B = a.erase, h = a.fireEvent, e = a.format, q = a.isArray, t = a.isNumber, u = a.pick, v = a.uniqueKey, n = a.defined, g = a.removeEvent;
        a.Point = E = function() {};
        a.Point.prototype = {
            init: function(a, e, b) {
                this.series = a;
                this.applyOptions(e, b);
                this.id = n(this.id) ? this.id : v();
                this.resolveColor();
                a.chart.pointCount++;
                h(this, "afterInit");
                return this;
            },
            resolveColor: function() {
                var a = this.series, e;
                e = a.chart.options.chart.colorCount;
                var b = a.chart.styledMode;
                b || this.options.color || (this.color = a.color);
                a.options.colorByPoint ? (b || (e = a.options.colors || a.chart.options.colors, 
                this.color = this.color || e[a.colorCounter], e = e.length), b = a.colorCounter, 
                a.colorCounter++, a.colorCounter === e && (a.colorCounter = 0)) : b = a.colorIndex;
                this.colorIndex = u(this.colorIndex, b);
            },
            applyOptions: function(a, e) {
                var b = this.series, d = b.options.pointValKey || b.pointValKey;
                a = E.prototype.optionsToObject.call(this, a);
                H(this, a);
                this.options = this.options ? H(this.options, a) : a;
                a.group && delete this.group;
                a.dataLabels && delete this.dataLabels;
                d && (this.y = this[d]);
                if (this.isNull = u(this.isValid && !this.isValid(), null === this.x || !t(this.y, !0))) this.formatPrefix = "null";
                this.selected && (this.state = "select");
                "name" in this && void 0 === e && b.xAxis && b.xAxis.hasNames && (this.x = b.xAxis.nameToX(this));
                void 0 === this.x && b && (this.x = void 0 === e ? b.autoIncrement(this) : e);
                return this;
            },
            setNestedProperty: function(d, e, b) {
                b.split(".").reduce(function(b, d, c, g) {
                    b[d] = g.length - 1 === c ? e : a.isObject(b[d], !0) ? b[d] : {};
                    return b[d];
                }, d);
                return d;
            },
            optionsToObject: function(d) {
                var e = {}, b = this.series, g = b.options.keys, p = g || b.pointArrayMap || [ "y" ], c = p.length, h = 0, n = 0;
                if (t(d) || null === d) e[p[0]] = d; else if (q(d)) for (!g && d.length > c && (b = typeof d[0], 
                "string" === b ? e.name = d[0] : "number" === b && (e.x = d[0]), h++); n < c; ) g && void 0 === d[h] || (0 < p[n].indexOf(".") ? a.Point.prototype.setNestedProperty(e, d[h], p[n]) : e[p[n]] = d[h]), 
                h++, n++; else "object" === typeof d && (e = d, d.dataLabels && (b._hasPointLabels = !0), 
                d.marker && (b._hasPointMarkers = !0));
                return e;
            },
            getClassName: function() {
                return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            },
            getZone: function() {
                var a = this.series, e = a.zones, a = a.zoneAxis || "y", b = 0, g;
                for (g = e[b]; this[a] >= g.value; ) g = e[++b];
                this.nonZonedColor || (this.nonZonedColor = this.color);
                this.color = g && g.color && !this.options.color ? g.color : this.nonZonedColor;
                return g;
            },
            destroy: function() {
                var a = this.series.chart, e = a.hoverPoints, b;
                a.pointCount--;
                e && (this.setState(), B(e, this), e.length || (a.hoverPoints = null));
                if (this === a.hoverPoint) this.onMouseOut();
                if (this.graphic || this.dataLabel || this.dataLabels) g(this), this.destroyElements();
                this.legendItem && a.legend.destroyItem(this);
                for (b in this) this[b] = null;
            },
            destroyElements: function(a) {
                var d = this, b = [], e, g;
                a = a || {
                    graphic: 1,
                    dataLabel: 1
                };
                a.graphic && b.push("graphic", "shadowGroup");
                a.dataLabel && b.push("dataLabel", "dataLabelUpper", "connector");
                for (g = b.length; g--; ) e = b[g], d[e] && (d[e] = d[e].destroy());
                [ "dataLabel", "connector" ].forEach(function(b) {
                    var c = b + "s";
                    a[b] && d[c] && (d[c].forEach(function(a) {
                        a.element && a.destroy();
                    }), delete d[c]);
                });
            },
            getLabelConfig: function() {
                return {
                    x: this.category,
                    y: this.y,
                    color: this.color,
                    colorIndex: this.colorIndex,
                    key: this.name || this.category,
                    series: this.series,
                    point: this,
                    percentage: this.percentage,
                    total: this.total || this.stackTotal
                };
            },
            tooltipFormatter: function(a) {
                var d = this.series, b = d.tooltipOptions, g = u(b.valueDecimals, ""), p = b.valuePrefix || "", c = b.valueSuffix || "";
                d.chart.styledMode && (a = d.chart.tooltip.styledModeFormat(a));
                (d.pointArrayMap || [ "y" ]).forEach(function(b) {
                    b = "{point." + b;
                    if (p || c) a = a.replace(RegExp(b + "}", "g"), p + b + "}" + c);
                    a = a.replace(RegExp(b + "}", "g"), b + ":,." + g + "f}");
                });
                return e(a, {
                    point: this,
                    series: this.series
                }, d.chart.time);
            },
            firePointEvent: function(a, e, b) {
                var d = this, g = this.series.options;
                (g.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();
                "click" === a && g.allowPointSelect && (b = function(a) {
                    d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
                });
                h(this, a, e, b);
            },
            visible: !0
        };
    });
    J(G, "parts/Series.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.animObject, B = a.arrayMax, h = a.arrayMin, e = a.correctFloat, q = a.defaultOptions, t = a.defaultPlotOptions, u = a.defined, v = a.erase, n = a.extend, g = a.fireEvent, d = a.isArray, m = a.isNumber, b = a.isString, k = a.merge, p = a.objectEach, c = a.pick, x = a.removeEvent, K = a.splat, w = a.SVGElement, F = a.syncTimeout, C = a.win;
        a.Series = a.seriesType("line", null, {
            lineWidth: 2,
            allowPointSelect: !1,
            showCheckbox: !1,
            animation: {
                duration: 1e3
            },
            events: {},
            marker: {
                lineWidth: 0,
                lineColor: "#ffffff",
                enabledThreshold: 2,
                radius: 4,
                states: {
                    normal: {
                        animation: !0
                    },
                    hover: {
                        animation: {
                            duration: 50
                        },
                        enabled: !0,
                        radiusPlus: 2,
                        lineWidthPlus: 1
                    },
                    select: {
                        fillColor: "#cccccc",
                        lineColor: "#000000",
                        lineWidth: 2
                    }
                }
            },
            point: {
                events: {}
            },
            dataLabels: {
                align: "center",
                formatter: function() {
                    return null === this.y ? "" : a.numberFormat(this.y, -1);
                },
                padding: 5,
                style: {
                    fontSize: "11px",
                    fontWeight: "bold",
                    color: "contrast",
                    textOutline: "1px contrast"
                },
                verticalAlign: "bottom",
                x: 0,
                y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
                normal: {
                    animation: !0
                },
                hover: {
                    animation: {
                        duration: 50
                    },
                    lineWidthPlus: 1,
                    marker: {},
                    halo: {
                        size: 10,
                        opacity: .25
                    }
                },
                select: {
                    animation: {
                        duration: 0
                    }
                },
                inactive: {
                    animation: {
                        duration: 50
                    },
                    opacity: .2
                }
            },
            stickyTracking: !0,
            turboThreshold: 1e3,
            findNearestPointBy: "x"
        }, {
            isCartesian: !0,
            pointClass: a.Point,
            sorted: !0,
            requireSorting: !0,
            directTouch: !1,
            axisTypes: [ "xAxis", "yAxis" ],
            colorCounter: 0,
            parallelArrays: [ "x", "y" ],
            coll: "series",
            cropShoulder: 1,
            init: function(b, d) {
                g(this, "init", {
                    options: d
                });
                var e = this, l, k = b.series, f;
                e.chart = b;
                e.options = d = e.setOptions(d);
                e.linkedSeries = [];
                e.bindAxes();
                n(e, {
                    name: d.name,
                    state: "",
                    visible: !1 !== d.visible,
                    selected: !0 === d.selected
                });
                l = d.events;
                p(l, function(b, c) {
                    !a.isFunction(b) || e.hcEvents && e.hcEvents[c] && e.hcEvents[c].some(function(a) {
                        return a.fn === b;
                    }) || E(e, c, b);
                });
                if (l && l.click || d.point && d.point.events && d.point.events.click || d.allowPointSelect) b.runTrackerClick = !0;
                e.getColor();
                e.getSymbol();
                e.parallelArrays.forEach(function(a) {
                    e[a + "Data"] || (e[a + "Data"] = []);
                });
                e.points || e.setData(d.data, !1);
                e.isCartesian && (b.hasCartesianSeries = !0);
                k.length && (f = k[k.length - 1]);
                e._i = c(f && f._i, -1) + 1;
                b.orderSeries(this.insert(k));
                g(this, "afterInit");
            },
            insert: function(a) {
                var b = this.options.index, d;
                if (m(b)) {
                    for (d = a.length; d--; ) if (b >= c(a[d].options.index, a[d]._i)) {
                        a.splice(d + 1, 0, this);
                        break;
                    }
                    -1 === d && a.unshift(this);
                    d += 1;
                } else a.push(this);
                return c(d, a.length - 1);
            },
            bindAxes: function() {
                var b = this, c = b.options, d = b.chart, e;
                g(this, "bindAxes", null, function() {
                    (b.axisTypes || []).forEach(function(l) {
                        d[l].forEach(function(a) {
                            e = a.options;
                            if (c[l] === e.index || void 0 !== c[l] && c[l] === e.id || void 0 === c[l] && 0 === e.index) b.insert(a.series), 
                            b[l] = a, a.isDirty = !0;
                        });
                        b[l] || b.optionalAxis === l || a.error(18, !0, d);
                    });
                });
            },
            updateParallelArrays: function(a, b) {
                var c = a.series, d = arguments, e = m(b) ? function(f) {
                    var d = "y" === f && c.toYData ? c.toYData(a) : a[f];
                    c[f + "Data"][b] = d;
                } : function(a) {
                    Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2));
                };
                c.parallelArrays.forEach(e);
            },
            hasData: function() {
                return this.visible && void 0 !== this.dataMax && void 0 !== this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            },
            autoIncrement: function() {
                var a = this.options, b = this.xIncrement, d, e = a.pointIntervalUnit, g = this.chart.time, b = c(b, a.pointStart, 0);
                this.pointInterval = d = c(this.pointInterval, a.pointInterval, 1);
                e && (a = new g.Date(b), "day" === e ? g.set("Date", a, g.get("Date", a) + d) : "month" === e ? g.set("Month", a, g.get("Month", a) + d) : "year" === e && g.set("FullYear", a, g.get("FullYear", a) + d), 
                d = a.getTime() - b);
                this.xIncrement = b + d;
                return b;
            },
            setOptions: function(a) {
                var b = this.chart, d = b.options, e = d.plotOptions, l = b.userOptions || {};
                a = k(a);
                var b = b.styledMode, f = {
                    plotOptions: e,
                    userOptions: a
                };
                g(this, "setOptions", f);
                var m = l.plotOptions || {}, p = f.plotOptions[this.type];
                this.userOptions = f.userOptions;
                l = k(p, e.series, l.plotOptions && l.plotOptions[this.type], a);
                this.tooltipOptions = k(q.tooltip, q.plotOptions.series && q.plotOptions.series.tooltip, q.plotOptions[this.type].tooltip, d.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, a.tooltip);
                this.stickyTracking = c(a.stickyTracking, m[this.type] && m[this.type].stickyTracking, m.series && m.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : l.stickyTracking);
                null === p.marker && delete l.marker;
                this.zoneAxis = l.zoneAxis;
                d = this.zones = (l.zones || []).slice();
                !l.negativeColor && !l.negativeFillColor || l.zones || (e = {
                    value: l[this.zoneAxis + "Threshold"] || l.threshold || 0,
                    className: "highcharts-negative"
                }, b || (e.color = l.negativeColor, e.fillColor = l.negativeFillColor), d.push(e));
                d.length && u(d[d.length - 1].value) && d.push(b ? {} : {
                    color: this.color,
                    fillColor: this.fillColor
                });
                g(this, "afterSetOptions", {
                    options: l
                });
                return l;
            },
            getName: function() {
                return c(this.options.name, "Series " + (this.index + 1));
            },
            getCyclic: function(a, b, d) {
                var e, l = this.chart, f = this.userOptions, g = a + "Index", k = a + "Counter", m = d ? d.length : c(l.options.chart[a + "Count"], l[a + "Count"]);
                b || (e = c(f[g], f["_" + g]), u(e) || (l.series.length || (l[k] = 0), f["_" + g] = e = l[k] % m, 
                l[k] += 1), d && (b = d[e]));
                void 0 !== e && (this[g] = e);
                this[a] = b;
            },
            getColor: function() {
                this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || t[this.type].color, this.chart.options.colors);
            },
            getSymbol: function() {
                this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            },
            findPointIndex: function(a, b) {
                var c = a.id;
                a = a.x;
                var d = this.points, e, f;
                c && (f = (c = this.chart.get(c)) && c.index, void 0 !== f && (e = !0));
                void 0 === f && m(a) && (f = this.xData.indexOf(a, b));
                -1 !== f && void 0 !== f && this.cropped && (f = f >= this.cropStart ? f - this.cropStart : f);
                !e && d[f] && d[f].touched && (f = void 0);
                return f;
            },
            drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,
            updateData: function(b) {
                var c = this.options, d = this.points, e = [], l, f, g, k = this.requireSorting, p = b.length === d.length, h = !0;
                this.xIncrement = null;
                b.forEach(function(b, f) {
                    var h, A = a.defined(b) && this.pointClass.prototype.optionsToObject.call({
                        series: this
                    }, b) || {};
                    h = A.x;
                    if (A.id || m(h)) if (h = this.findPointIndex(A, g), -1 === h || void 0 === h ? e.push(b) : d[h] && b !== c.data[h] ? (d[h].update(b, !1, null, !1), 
                    d[h].touched = !0, k && (g = h + 1)) : d[h] && (d[h].touched = !0), !p || f !== h || this.hasDerivedData) l = !0;
                }, this);
                if (l) for (b = d.length; b--; ) (f = d[b]) && !f.touched && f.remove(!1); else p ? b.forEach(function(a, b) {
                    d[b].update && a !== d[b].y && d[b].update(a, !1, null, !1);
                }) : h = !1;
                d.forEach(function(a) {
                    a && (a.touched = !1);
                });
                if (!h) return !1;
                e.forEach(function(a) {
                    this.addPoint(a, !1, null, null, !1);
                }, this);
                return !0;
            },
            setData: function(e, g, k, p) {
                var l = this, f = l.points, h = f && f.length || 0, A, n = l.options, D = l.chart, z = null, x = l.xAxis, w = n.turboThreshold, C = this.xData, q = this.yData, t = (A = l.pointArrayMap) && A.length, u = n.keys, F = 0, v = 1, K;
                e = e || [];
                A = e.length;
                g = c(g, !0);
                !1 !== p && A && h && !l.cropped && !l.hasGroupedData && l.visible && !l.isSeriesBoosting && (K = this.updateData(e));
                if (!K) {
                    l.xIncrement = null;
                    l.colorCounter = 0;
                    this.parallelArrays.forEach(function(a) {
                        l[a + "Data"].length = 0;
                    });
                    if (w && A > w) {
                        for (k = 0; null === z && k < A; ) z = e[k], k++;
                        if (m(z)) for (k = 0; k < A; k++) C[k] = this.autoIncrement(), q[k] = e[k]; else if (d(z)) if (t) for (k = 0; k < A; k++) z = e[k], 
                        C[k] = z[0], q[k] = z.slice(1, t + 1); else for (u && (F = u.indexOf("x"), v = u.indexOf("y"), 
                        F = 0 <= F ? F : 0, v = 0 <= v ? v : 1), k = 0; k < A; k++) z = e[k], C[k] = z[F], 
                        q[k] = z[v]; else a.error(12, !1, D);
                    } else for (k = 0; k < A; k++) void 0 !== e[k] && (z = {
                        series: l
                    }, l.pointClass.prototype.applyOptions.apply(z, [ e[k] ]), l.updateParallelArrays(z, k));
                    q && b(q[0]) && a.error(14, !0, D);
                    l.data = [];
                    l.options.data = l.userOptions.data = e;
                    for (k = h; k--; ) f[k] && f[k].destroy && f[k].destroy();
                    x && (x.minRange = x.userMinRange);
                    l.isDirty = D.isDirtyBox = !0;
                    l.isDirtyData = !!f;
                    k = !1;
                }
                "point" === n.legendType && (this.processData(), this.generatePoints());
                g && D.redraw(k);
            },
            processData: function(b) {
                var c = this.xData, d = this.yData, e = c.length, l;
                l = 0;
                var f, g, k = this.xAxis, m, p = this.options;
                m = p.cropThreshold;
                var h = this.getExtremesFromAll || p.getExtremesFromAll, n = this.isCartesian, p = k && k.val2lin, x = k && k.isLog, w = this.requireSorting, C, q;
                if (n && !this.isDirty && !k.isDirty && !this.yAxis.isDirty && !b) return !1;
                k && (b = k.getExtremes(), C = b.min, q = b.max);
                n && this.sorted && !h && (!m || e > m || this.forceCrop) && (c[e - 1] < C || c[0] > q ? (c = [], 
                d = []) : this.yData && (c[0] < C || c[e - 1] > q) && (l = this.cropData(this.xData, this.yData, C, q), 
                c = l.xData, d = l.yData, l = l.start, f = !0));
                for (m = c.length || 1; --m; ) e = x ? p(c[m]) - p(c[m - 1]) : c[m] - c[m - 1], 
                0 < e && (void 0 === g || e < g) ? g = e : 0 > e && w && (a.error(15, !1, this.chart), 
                w = !1);
                this.cropped = f;
                this.cropStart = l;
                this.processedXData = c;
                this.processedYData = d;
                this.closestPointRange = g;
            },
            cropData: function(a, b, d, e, g) {
                var f = a.length, l = 0, k = f, m;
                g = c(g, this.cropShoulder);
                for (m = 0; m < f; m++) if (a[m] >= d) {
                    l = Math.max(0, m - g);
                    break;
                }
                for (d = m; d < f; d++) if (a[d] > e) {
                    k = d + g;
                    break;
                }
                return {
                    xData: a.slice(l, k),
                    yData: b.slice(l, k),
                    start: l,
                    end: k
                };
            },
            generatePoints: function() {
                var a = this.options, b = a.data, c = this.data, d, e = this.processedXData, f = this.processedYData, k = this.pointClass, m = e.length, p = this.cropStart || 0, h, x = this.hasGroupedData, a = a.keys, w, C = [], q;
                c || x || (c = [], c.length = b.length, c = this.data = c);
                a && x && (this.options.keys = !1);
                for (q = 0; q < m; q++) h = p + q, x ? (w = new k().init(this, [ e[q] ].concat(K(f[q]))), 
                w.dataGroup = this.groupMap[q], w.dataGroup.options && (w.options = w.dataGroup.options, 
                n(w, w.dataGroup.options), delete w.dataLabels)) : (w = c[h]) || void 0 === b[h] || (c[h] = w = new k().init(this, b[h], e[q])), 
                w && (w.index = h, C[q] = w);
                this.options.keys = a;
                if (c && (m !== (d = c.length) || x)) for (q = 0; q < d; q++) q !== p || x || (q += m), 
                c[q] && (c[q].destroyElements(), c[q].plotX = void 0);
                this.data = c;
                this.points = C;
                g(this, "afterGeneratePoints");
            },
            getXExtremes: function(a) {
                return {
                    min: h(a),
                    max: B(a)
                };
            },
            getExtremes: function(a) {
                var b = this.yAxis, c = this.processedXData, e, l = [], f = 0;
                e = this.xAxis.getExtremes();
                var k = e.min, p = e.max, n, w, x = this.requireSorting ? this.cropShoulder : 0, q, C;
                a = a || this.stackedYData || this.processedYData || [];
                e = a.length;
                for (C = 0; C < e; C++) if (w = c[C], q = a[C], n = (m(q, !0) || d(q)) && (!b.positiveValuesOnly || q.length || 0 < q), 
                w = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[C + x] || w) >= k && (c[C - x] || w) <= p, 
                n && w) if (n = q.length) for (;n--; ) "number" === typeof q[n] && (l[f++] = q[n]); else l[f++] = q;
                this.dataMin = h(l);
                this.dataMax = B(l);
                g(this, "afterGetExtremes");
            },
            translate: function() {
                this.processedXData || this.processData();
                this.generatePoints();
                var a = this.options, b = a.stacking, k = this.xAxis, p = k.categories, h = this.yAxis, f = this.points, r = f.length, n = !!this.modifyValue, w, q = this.pointPlacementToXValue(), C = m(q), x = a.threshold, t = a.startFromThreshold ? x : 0, F, v, K, B, E = this.zoneAxis || "y", H = Number.MAX_VALUE;
                for (w = 0; w < r; w++) {
                    var G = f[w], J = G.x;
                    v = G.y;
                    var V = G.low, O = b && h.stacks[(this.negStacks && v < (t ? 0 : x) ? "-" : "") + this.stackKey], W, X;
                    h.positiveValuesOnly && null !== v && 0 >= v && (G.isNull = !0);
                    G.plotX = F = e(Math.min(Math.max(-1e5, k.translate(J, 0, 0, 0, 1, q, "flags" === this.type)), 1e5));
                    b && this.visible && !G.isNull && O && O[J] && (B = this.getStackIndicator(B, J, this.index), 
                    W = O[J], X = W.points[B.key]);
                    d(X) && (V = X[0], v = X[1], V === t && B.key === O[J].base && (V = c(m(x) && x, h.min)), 
                    h.positiveValuesOnly && 0 >= V && (V = null), G.total = G.stackTotal = W.total, 
                    G.percentage = W.total && G.y / W.total * 100, G.stackY = v, W.setOffset(this.pointXOffset || 0, this.barW || 0));
                    G.yBottom = u(V) ? Math.min(Math.max(-1e5, h.translate(V, 0, 1, 0, 1)), 1e5) : null;
                    n && (v = this.modifyValue(v, G));
                    G.plotY = v = "number" === typeof v && Infinity !== v ? Math.min(Math.max(-1e5, h.translate(v, 0, 1, 0, 1)), 1e5) : void 0;
                    G.isInside = void 0 !== v && 0 <= v && v <= h.len && 0 <= F && F <= k.len;
                    G.clientX = C ? e(k.translate(J, 0, 0, 0, 1, q)) : F;
                    G.negative = G[E] < (a[E + "Threshold"] || x || 0);
                    G.category = p && void 0 !== p[G.x] ? p[G.x] : G.x;
                    G.isNull || (void 0 !== K && (H = Math.min(H, Math.abs(F - K))), K = F);
                    G.zone = this.zones.length && G.getZone();
                }
                this.closestPointRangePx = H;
                g(this, "afterTranslate");
            },
            getValidPoints: function(a, b, c) {
                var d = this.chart;
                return (a || this.points || []).filter(function(a) {
                    return b && !d.isInsidePlot(a.plotX, a.plotY, d.inverted) ? !1 : c || !a.isNull;
                });
            },
            getClipBox: function(a, b) {
                var c = this.options, d = this.chart, e = d.inverted, f = this.xAxis, l = f && this.yAxis;
                a && !1 === c.clip && l ? a = e ? {
                    y: -d.chartWidth + l.len + l.pos,
                    height: d.chartWidth,
                    width: d.chartHeight,
                    x: -d.chartHeight + f.len + f.pos
                } : {
                    y: -l.pos,
                    height: d.chartHeight,
                    width: d.chartWidth,
                    x: -f.pos
                } : (a = this.clipBox || d.clipBox, b && (a.width = d.plotSizeX, a.x = 0));
                return b ? {
                    width: a.width,
                    x: a.x
                } : a;
            },
            setClip: function(a) {
                var b = this.chart, c = this.options, d = b.renderer, e = b.inverted, f = this.clipBox, l = this.getClipBox(a), g = this.sharedClipKey || [ "_sharedClip", a && a.duration, a && a.easing, l.height, c.xAxis, c.yAxis ].join(), k = b[g], m = b[g + "m"];
                k || (a && (l.width = 0, e && (l.x = b.plotSizeX + (!1 !== c.clip ? 0 : b.plotTop)), 
                b[g + "m"] = m = d.clipRect(e ? b.plotSizeX + 99 : -99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight)), 
                b[g] = k = d.clipRect(l), k.count = {
                    length: 0
                });
                a && !k.count[this.index] && (k.count[this.index] = !0, k.count.length += 1);
                if (!1 !== c.clip || a) this.group.clip(a || f ? k : b.clipRect), this.markerGroup.clip(m), 
                this.sharedClipKey = g;
                a || (k.count[this.index] && (delete k.count[this.index], --k.count.length), 0 === k.count.length && g && b[g] && (f || (b[g] = b[g].destroy()), 
                b[g + "m"] && (b[g + "m"] = b[g + "m"].destroy())));
            },
            animate: function(a) {
                var b = this.chart, c = H(this.options.animation), d, e;
                a ? this.setClip(c) : (d = this.sharedClipKey, a = b[d], e = this.getClipBox(c, !0), 
                a && a.animate(e, c), b[d + "m"] && b[d + "m"].animate({
                    width: e.width + 99,
                    x: e.x - (b.inverted ? 0 : 99)
                }, c), this.animate = null);
            },
            afterAnimate: function() {
                this.setClip();
                g(this, "afterAnimate");
                this.finishedAnimating = !0;
            },
            drawPoints: function() {
                var a = this.points, b = this.chart, d, e, g, f, k, m = this.options.marker, p, h, n, w = this[this.specialGroup] || this.markerGroup;
                d = this.xAxis;
                var q, x = c(m.enabled, !d || d.isRadial ? !0 : null, this.closestPointRangePx >= m.enabledThreshold * m.radius);
                if (!1 !== m.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) if (e = a[d], 
                k = (f = e.graphic) ? "animate" : "attr", p = e.marker || {}, h = !!e.marker, g = x && void 0 === p.enabled || p.enabled, 
                n = !1 !== e.isInside, g && !e.isNull) {
                    g = c(p.symbol, this.symbol);
                    q = this.markerAttribs(e, e.selected && "select");
                    f ? f[n ? "show" : "hide"](!0).animate(q) : n && (0 < q.width || e.hasImage) && (e.graphic = f = b.renderer.symbol(g, q.x, q.y, q.width, q.height, h ? p : m).add(w));
                    if (f && !b.styledMode) f[k](this.pointAttribs(e, e.selected && "select"));
                    f && f.addClass(e.getClassName(), !0);
                } else f && (e.graphic = f.destroy());
            },
            markerAttribs: function(a, b) {
                var d = this.options.marker, e = a.marker || {}, l = e.symbol || d.symbol, f = c(e.radius, d.radius);
                b && (d = d.states[b], b = e.states && e.states[b], f = c(b && b.radius, d && d.radius, f + (d && d.radiusPlus || 0)));
                a.hasImage = l && 0 === l.indexOf("url");
                a.hasImage && (f = 0);
                a = {
                    x: Math.floor(a.plotX) - f,
                    y: a.plotY - f
                };
                f && (a.width = a.height = 2 * f);
                return a;
            },
            pointAttribs: function(a, b) {
                var d = this.options.marker, e = a && a.options, l = e && e.marker || {}, f = this.color, g = e && e.color, k = a && a.color, e = c(l.lineWidth, d.lineWidth), m = a && a.zone && a.zone.color;
                a = 1;
                f = g || m || k || f;
                g = l.fillColor || d.fillColor || f;
                f = l.lineColor || d.lineColor || f;
                b = b || "normal";
                d = d.states[b];
                b = l.states && l.states[b] || {};
                e = c(b.lineWidth, d.lineWidth, e + c(b.lineWidthPlus, d.lineWidthPlus, 0));
                g = b.fillColor || d.fillColor || g;
                f = b.lineColor || d.lineColor || f;
                a = c(b.opacity, d.opacity, a);
                return {
                    stroke: f,
                    "stroke-width": e,
                    fill: g,
                    opacity: a
                };
            },
            destroy: function(b) {
                var c = this, d = c.chart, e = /AppleWebKit\/533/.test(C.navigator.userAgent), l, f, k = c.data || [], m, h;
                g(c, "destroy");
                b || x(c);
                (c.axisTypes || []).forEach(function(a) {
                    (h = c[a]) && h.series && (v(h.series, c), h.isDirty = h.forceRedraw = !0);
                });
                c.legendItem && c.chart.legend.destroyItem(c);
                for (f = k.length; f--; ) (m = k[f]) && m.destroy && m.destroy();
                c.points = null;
                a.clearTimeout(c.animationTimeout);
                p(c, function(a, b) {
                    a instanceof w && !a.survive && (l = e && "group" === b ? "hide" : "destroy", a[l]());
                });
                d.hoverSeries === c && (d.hoverSeries = null);
                v(d.series, c);
                d.orderSeries();
                p(c, function(a, d) {
                    b && "hcEvents" === d || delete c[d];
                });
            },
            getGraphPath: function(a, b, c) {
                var d = this, e = d.options, f = e.step, l, g = [], k = [], m;
                a = a || d.points;
                (l = a.reversed) && a.reverse();
                (f = {
                    right: 1,
                    center: 2
                }[f] || f && 3) && l && (f = 4 - f);
                !e.connectNulls || b || c || (a = this.getValidPoints(a));
                a.forEach(function(l, p) {
                    var h = l.plotX, n = l.plotY, r = a[p - 1];
                    (l.leftCliff || r && r.rightCliff) && !c && (m = !0);
                    l.isNull && !u(b) && 0 < p ? m = !e.connectNulls : l.isNull && !b ? m = !0 : (0 === p || m ? p = [ "M", l.plotX, l.plotY ] : d.getPointSpline ? p = d.getPointSpline(a, l, p) : f ? (p = 1 === f ? [ "L", r.plotX, n ] : 2 === f ? [ "L", (r.plotX + h) / 2, r.plotY, "L", (r.plotX + h) / 2, n ] : [ "L", h, r.plotY ], 
                    p.push("L", h, n)) : p = [ "L", h, n ], k.push(l.x), f && (k.push(l.x), 2 === f && k.push(l.x)), 
                    g.push.apply(g, p), m = !1);
                });
                g.xMap = k;
                return d.graphPath = g;
            },
            drawGraph: function() {
                var a = this, b = this.options, c = (this.gappedPath || this.getGraphPath).call(this), d = this.chart.styledMode, e = [ [ "graph", "highcharts-graph" ] ];
                d || e[0].push(b.lineColor || this.color || "#cccccc", b.dashStyle);
                e = a.getZonesGraphs(e);
                e.forEach(function(f, e) {
                    var l = f[0], g = a[l], k = g ? "animate" : "attr";
                    g ? (g.endX = a.preventGraphAnimation ? null : c.xMap, g.animate({
                        d: c
                    })) : c.length && (a[l] = g = a.chart.renderer.path(c).addClass(f[1]).attr({
                        zIndex: 1
                    }).add(a.group));
                    g && !d && (l = {
                        stroke: f[2],
                        "stroke-width": b.lineWidth,
                        fill: a.fillGraph && a.color || "none"
                    }, f[3] ? l.dashstyle = f[3] : "square" !== b.linecap && (l["stroke-linecap"] = l["stroke-linejoin"] = "round"), 
                    g[k](l).shadow(2 > e && b.shadow));
                    g && (g.startX = c.xMap, g.isArea = c.isArea);
                });
            },
            getZonesGraphs: function(a) {
                this.zones.forEach(function(b, c) {
                    c = [ "zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (b.className || "") ];
                    this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);
                    a.push(c);
                }, this);
                return a;
            },
            applyZones: function() {
                var a = this, b = this.chart, d = b.renderer, e = this.zones, g, f, k = this.clips || [], m, p = this.graph, h = this.area, n = Math.max(b.chartWidth, b.chartHeight), w = this[(this.zoneAxis || "y") + "Axis"], q, x, C = b.inverted, t, u, v, F, K = !1;
                e.length && (p || h) && w && void 0 !== w.min ? (x = w.reversed, t = w.horiz, p && !this.showLine && p.hide(), 
                h && h.hide(), q = w.getExtremes(), e.forEach(function(e, l) {
                    g = x ? t ? b.plotWidth : 0 : t ? 0 : w.toPixels(q.min) || 0;
                    g = Math.min(Math.max(c(f, g), 0), n);
                    f = Math.min(Math.max(Math.round(w.toPixels(c(e.value, q.max), !0) || 0), 0), n);
                    K && (g = f = w.toPixels(q.max));
                    u = Math.abs(g - f);
                    v = Math.min(g, f);
                    F = Math.max(g, f);
                    w.isXAxis ? (m = {
                        x: C ? F : v,
                        y: 0,
                        width: u,
                        height: n
                    }, t || (m.x = b.plotHeight - m.x)) : (m = {
                        x: 0,
                        y: C ? F : v,
                        width: n,
                        height: u
                    }, t && (m.y = b.plotWidth - m.y));
                    C && d.isVML && (m = w.isXAxis ? {
                        x: 0,
                        y: x ? v : F,
                        height: m.width,
                        width: b.chartWidth
                    } : {
                        x: m.y - b.plotLeft - b.spacingBox.x,
                        y: 0,
                        width: m.height,
                        height: b.chartHeight
                    });
                    k[l] ? k[l].animate(m) : k[l] = d.clipRect(m);
                    p && a["zone-graph-" + l].clip(k[l]);
                    h && a["zone-area-" + l].clip(k[l]);
                    K = e.value > q.max;
                    a.resetZones && 0 === f && (f = void 0);
                }), this.clips = k) : a.visible && (p && p.show(!0), h && h.show(!0));
            },
            invertGroups: function(a) {
                function b() {
                    [ "group", "markerGroup" ].forEach(function(b) {
                        c[b] && (d.renderer.isVML && c[b].attr({
                            width: c.yAxis.len,
                            height: c.xAxis.len
                        }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));
                    });
                }
                var c = this, d = c.chart, e;
                c.xAxis && (e = E(d, "resize", b), E(c, "destroy", e), b(a), c.invertGroups = b);
            },
            plotGroup: function(a, b, c, d, e) {
                var f = this[a], l = !f;
                l && (this[a] = f = this.chart.renderer.g().attr({
                    zIndex: d || .1
                }).add(e));
                f.addClass("highcharts-" + b + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (u(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
                f.attr({
                    visibility: c
                })[l ? "attr" : "animate"](this.getPlotBox());
                return f;
            },
            getPlotBox: function() {
                var a = this.chart, b = this.xAxis, c = this.yAxis;
                a.inverted && (b = c, c = this.xAxis);
                return {
                    translateX: b ? b.left : a.plotLeft,
                    translateY: c ? c.top : a.plotTop,
                    scaleX: 1,
                    scaleY: 1
                };
            },
            render: function() {
                var a = this, b = a.chart, c, d = a.options, e = !!a.animate && b.renderer.isSVG && H(d.animation).duration, f = a.visible ? "inherit" : "hidden", k = d.zIndex, m = a.hasRendered, p = b.seriesGroup, h = b.inverted;
                g(this, "render");
                c = a.plotGroup("group", "series", f, k, p);
                a.markerGroup = a.plotGroup("markerGroup", "markers", f, k, p);
                e && a.animate(!0);
                c.inverted = a.isCartesian || a.invertable ? h : !1;
                a.drawGraph && (a.drawGraph(), a.applyZones());
                a.visible && a.drawPoints();
                a.drawDataLabels && a.drawDataLabels();
                a.redrawPoints && a.redrawPoints();
                a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
                a.invertGroups(h);
                !1 === d.clip || a.sharedClipKey || m || c.clip(b.clipRect);
                e && a.animate();
                m || (a.animationTimeout = F(function() {
                    a.afterAnimate();
                }, e));
                a.isDirty = !1;
                a.hasRendered = !0;
                g(a, "afterRender");
            },
            redraw: function() {
                var a = this.chart, b = this.isDirty || this.isDirtyData, d = this.group, e = this.xAxis, g = this.yAxis;
                d && (a.inverted && d.attr({
                    width: a.plotWidth,
                    height: a.plotHeight
                }), d.animate({
                    translateX: c(e && e.left, a.plotLeft),
                    translateY: c(g && g.top, a.plotTop)
                }));
                this.translate();
                this.render();
                b && delete this.kdTree;
            },
            kdAxisArray: [ "clientX", "plotY" ],
            searchPoint: function(a, b) {
                var c = this.xAxis, d = this.yAxis, e = this.chart.inverted;
                return this.searchKDTree({
                    clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos,
                    plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos
                }, b, a);
            },
            buildKDTree: function(a) {
                function b(a, d, e) {
                    var f, g;
                    if (g = a && a.length) return f = c.kdAxisArray[d % e], a.sort(function(a, b) {
                        return a[f] - b[f];
                    }), g = Math.floor(g / 2), {
                        point: a[g],
                        left: b(a.slice(0, g), d + 1, e),
                        right: b(a.slice(g + 1), d + 1, e)
                    };
                }
                this.buildingKdTree = !0;
                var c = this, d = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
                delete c.kdTree;
                F(function() {
                    c.kdTree = b(c.getValidPoints(null, !c.directTouch), d, d);
                    c.buildingKdTree = !1;
                }, c.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
            },
            searchKDTree: function(a, b, c) {
                function d(a, b, c, k) {
                    var m = b.point, p = e.kdAxisArray[c % k], h, n, r = m;
                    n = u(a[f]) && u(m[f]) ? Math.pow(a[f] - m[f], 2) : null;
                    h = u(a[g]) && u(m[g]) ? Math.pow(a[g] - m[g], 2) : null;
                    h = (n || 0) + (h || 0);
                    m.dist = u(h) ? Math.sqrt(h) : Number.MAX_VALUE;
                    m.distX = u(n) ? Math.sqrt(n) : Number.MAX_VALUE;
                    p = a[p] - m[p];
                    h = 0 > p ? "left" : "right";
                    n = 0 > p ? "right" : "left";
                    b[h] && (h = d(a, b[h], c + 1, k), r = h[l] < r[l] ? h : m);
                    b[n] && Math.sqrt(p * p) < r[l] && (a = d(a, b[n], c + 1, k), r = a[l] < r[l] ? a : r);
                    return r;
                }
                var e = this, f = this.kdAxisArray[0], g = this.kdAxisArray[1], l = b ? "distX" : "dist";
                b = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
                this.kdTree || this.buildingKdTree || this.buildKDTree(c);
                if (this.kdTree) return d(a, this.kdTree, b, b);
            },
            pointPlacementToXValue: function() {
                var a = this.options.pointPlacement;
                "between" === a && (a = .5);
                m(a) && (a *= c(this.options.pointRange || this.xAxis.pointRange));
                return a;
            }
        });
    });
    J(G, "parts/Stacking.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.Axis, H = a.Chart, B = a.correctFloat, h = a.defined, e = a.destroyObjectProperties, q = a.format, t = a.objectEach, u = a.pick, v = a.Series;
        a.StackItem = function(a, e, d, m, b) {
            var g = a.chart.inverted;
            this.axis = a;
            this.isNegative = d;
            this.options = e;
            this.x = m;
            this.total = null;
            this.points = {};
            this.stack = b;
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = {
                align: e.align || (g ? d ? "left" : "right" : "center"),
                verticalAlign: e.verticalAlign || (g ? "middle" : d ? "bottom" : "top"),
                y: u(e.y, g ? 4 : d ? 14 : -6),
                x: u(e.x, g ? d ? -6 : 6 : 0)
            };
            this.textAlign = e.textAlign || (g ? d ? "right" : "left" : "center");
        };
        a.StackItem.prototype = {
            destroy: function() {
                e(this, this.axis);
            },
            render: function(a) {
                var e = this.axis.chart, d = this.options, m = d.format, m = m ? q(m, this, e.time) : d.formatter.call(this);
                this.label ? this.label.attr({
                    text: m,
                    visibility: "hidden"
                }) : this.label = e.renderer.text(m, null, null, d.useHTML).css(d.style).attr({
                    align: this.textAlign,
                    rotation: d.rotation,
                    visibility: "hidden"
                }).add(a);
                this.label.labelrank = e.plotHeight;
            },
            setOffset: function(a, e, d, m) {
                var b = this.axis, g = b.chart;
                m = b.translate(b.usePercentage ? 100 : m ? m : this.total, 0, 0, 0, 1);
                d = b.translate(d ? d : 0);
                d = h(m) && Math.abs(m - d);
                a = g.xAxis[0].translate(this.x) + a;
                b = h(m) && this.getStackBox(g, this, a, m, e, d, b);
                (e = this.label) && b && (e.align(this.alignOptions, null, b), b = e.alignAttr, 
                e[!1 === this.options.crop || g.isInsidePlot(b.x, b.y) ? "show" : "hide"](!0));
            },
            getStackBox: function(a, e, d, m, b, k, p) {
                var c = e.axis.reversed, g = a.inverted;
                a = p.height + p.pos - (g ? a.plotLeft : a.plotTop);
                e = e.isNegative && !c || !e.isNegative && c;
                return {
                    x: g ? e ? m : m - k : d,
                    y: g ? a - d - b : e ? a - m - k : a - m,
                    width: g ? k : b,
                    height: g ? b : k
                };
            }
        };
        H.prototype.getStacks = function() {
            var a = this;
            a.yAxis.forEach(function(a) {
                a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);
            });
            a.series.forEach(function(e) {
                !e.options.stacking || !0 !== e.visible && !1 !== a.options.chart.ignoreHiddenSeries || (e.stackKey = e.type + u(e.options.stack, ""));
            });
        };
        E.prototype.buildStacks = function() {
            var a = this.series, e = u(this.options.reversedStacks, !0), d = a.length, m;
            if (!this.isXAxis) {
                this.usePercentage = !1;
                for (m = d; m--; ) a[e ? m : d - m - 1].setStackedPoints();
                for (m = 0; m < d; m++) a[m].modifyStacks();
            }
        };
        E.prototype.renderStackTotals = function() {
            var a = this.chart, e = a.renderer, d = this.stacks, m = this.stackTotalGroup;
            m || (this.stackTotalGroup = m = e.g("stack-labels").attr({
                visibility: "visible",
                zIndex: 6
            }).add());
            m.translate(a.plotLeft, a.plotTop);
            t(d, function(a) {
                t(a, function(a) {
                    a.render(m);
                });
            });
        };
        E.prototype.resetStacks = function() {
            var a = this, e = a.stacks;
            a.isXAxis || t(e, function(d) {
                t(d, function(e, b) {
                    e.touched < a.stacksTouched ? (e.destroy(), delete d[b]) : (e.total = null, e.cumulative = null);
                });
            });
        };
        E.prototype.cleanStacks = function() {
            var a;
            this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), t(a, function(a) {
                t(a, function(a) {
                    a.cumulative = a.total;
                });
            }));
        };
        v.prototype.setStackedPoints = function() {
            if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
                var e = this.processedXData, g = this.processedYData, d = [], m = g.length, b = this.options, k = b.threshold, p = u(b.startFromThreshold && k, 0), c = b.stack, b = b.stacking, q = this.stackKey, t = "-" + q, w = this.negStacks, v = this.yAxis, C = v.stacks, l = v.oldStacks, D, A, z, I, f, r, E;
                v.stacksTouched += 1;
                for (f = 0; f < m; f++) r = e[f], E = g[f], D = this.getStackIndicator(D, r, this.index), 
                I = D.key, z = (A = w && E < (p ? 0 : k)) ? t : q, C[z] || (C[z] = {}), C[z][r] || (l[z] && l[z][r] ? (C[z][r] = l[z][r], 
                C[z][r].total = null) : C[z][r] = new a.StackItem(v, v.options.stackLabels, A, r, c)), 
                z = C[z][r], null !== E ? (z.points[I] = z.points[this.index] = [ u(z.cumulative, p) ], 
                h(z.cumulative) || (z.base = I), z.touched = v.stacksTouched, 0 < D.index && !1 === this.singleStacks && (z.points[I][0] = z.points[this.index + "," + r + ",0"][0])) : z.points[I] = z.points[this.index] = null, 
                "percent" === b ? (A = A ? q : t, w && C[A] && C[A][r] ? (A = C[A][r], z.total = A.total = Math.max(A.total, z.total) + Math.abs(E) || 0) : z.total = B(z.total + (Math.abs(E) || 0))) : z.total = B(z.total + (E || 0)), 
                z.cumulative = u(z.cumulative, p) + (E || 0), null !== E && (z.points[I].push(z.cumulative), 
                d[f] = z.cumulative);
                "percent" === b && (v.usePercentage = !0);
                this.stackedYData = d;
                v.oldStacks = {};
            }
        };
        v.prototype.modifyStacks = function() {
            var a = this, e = a.stackKey, d = a.yAxis.stacks, m = a.processedXData, b, k = a.options.stacking;
            a[k + "Stacker"] && [ e, "-" + e ].forEach(function(e) {
                for (var c = m.length, g, p; c--; ) if (g = m[c], b = a.getStackIndicator(b, g, a.index, e), 
                p = (g = d[e] && d[e][g]) && g.points[b.key]) a[k + "Stacker"](p, g, c);
            });
        };
        v.prototype.percentStacker = function(a, e, d) {
            e = e.total ? 100 / e.total : 0;
            a[0] = B(a[0] * e);
            a[1] = B(a[1] * e);
            this.stackedYData[d] = a[1];
        };
        v.prototype.getStackIndicator = function(a, e, d, m) {
            !h(a) || a.x !== e || m && a.key !== m ? a = {
                x: e,
                index: 0,
                key: m
            } : a.index++;
            a.key = [ d, e, a.index ].join();
            return a;
        };
    });
    J(G, "parts/Dynamics.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.animate, B = a.Axis, h = a.Chart, e = a.createElement, q = a.css, t = a.defined, u = a.erase, v = a.extend, n = a.fireEvent, g = a.isNumber, d = a.isObject, m = a.isArray, b = a.merge, k = a.objectEach, p = a.pick, c = a.Point, x = a.Series, K = a.seriesTypes, w = a.setAnimation, F = a.splat;
        a.cleanRecursively = function(b, c) {
            var e = {};
            k(b, function(g, l) {
                if (d(b[l], !0) && !b.nodeType && c[l]) g = a.cleanRecursively(b[l], c[l]), Object.keys(g).length && (e[l] = g); else if (d(b[l]) || b[l] !== c[l]) e[l] = b[l];
            });
            return e;
        };
        v(h.prototype, {
            addSeries: function(a, b, c) {
                var d, e = this;
                a && (b = p(b, !0), n(e, "addSeries", {
                    options: a
                }, function() {
                    d = e.initSeries(a);
                    e.isDirtyLegend = !0;
                    e.linkSeries();
                    n(e, "afterAddSeries", {
                        series: d
                    });
                    b && e.redraw(c);
                }));
                return d;
            },
            addAxis: function(a, c, d, e) {
                var g = c ? "xAxis" : "yAxis", l = this.options;
                a = b(a, {
                    index: this[g].length,
                    isX: c
                });
                c = new B(this, a);
                l[g] = F(l[g] || {});
                l[g].push(a);
                p(d, !0) && this.redraw(e);
                return c;
            },
            showLoading: function(a) {
                var b = this, c = b.options, d = b.loadingDiv, g = c.loading, k = function() {
                    d && q(d, {
                        left: b.plotLeft + "px",
                        top: b.plotTop + "px",
                        width: b.plotWidth + "px",
                        height: b.plotHeight + "px"
                    });
                };
                d || (b.loadingDiv = d = e("div", {
                    className: "highcharts-loading highcharts-loading-hidden"
                }, null, b.container), b.loadingSpan = e("span", {
                    className: "highcharts-loading-inner"
                }, null, d), E(b, "redraw", k));
                d.className = "highcharts-loading";
                b.loadingSpan.innerHTML = a || c.lang.loading;
                b.styledMode || (q(d, v(g.style, {
                    zIndex: 10
                })), q(b.loadingSpan, g.labelStyle), b.loadingShown || (q(d, {
                    opacity: 0,
                    display: ""
                }), H(d, {
                    opacity: g.style.opacity || .5
                }, {
                    duration: g.showDuration || 0
                })));
                b.loadingShown = !0;
                k();
            },
            hideLoading: function() {
                var a = this.options, b = this.loadingDiv;
                b && (b.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || H(b, {
                    opacity: 0
                }, {
                    duration: a.loading.hideDuration || 100,
                    complete: function() {
                        q(b, {
                            display: "none"
                        });
                    }
                }));
                this.loadingShown = !1;
            },
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
            collectionsWithUpdate: "xAxis yAxis zAxis series colorAxis pane".split(" "),
            update: function(c, d, e, m) {
                var l = this, h = {
                    credits: "addCredits",
                    title: "setTitle",
                    subtitle: "setSubtitle"
                }, f, r, w, q, x = [];
                n(l, "update", {
                    options: c
                });
                c.isResponsiveOptions || l.setResponsive(!1, !0);
                c = a.cleanRecursively(c, l.options);
                b(!0, l.userOptions, c);
                if (f = c.chart) {
                    b(!0, l.options.chart, f);
                    "className" in f && l.setClassName(f.className);
                    "reflow" in f && l.setReflow(f.reflow);
                    if ("inverted" in f || "polar" in f || "type" in f) l.propFromSeries(), r = !0;
                    "alignTicks" in f && (r = !0);
                    k(f, function(a, b) {
                        -1 !== l.propsRequireUpdateSeries.indexOf("chart." + b) && (w = !0);
                        -1 !== l.propsRequireDirtyBox.indexOf(b) && (l.isDirtyBox = !0);
                        -1 !== l.propsRequireReflow.indexOf(b) && (q = !0);
                    });
                    !l.styledMode && "style" in f && l.renderer.setStyle(f.style);
                }
                !l.styledMode && c.colors && (this.options.colors = c.colors);
                c.plotOptions && b(!0, this.options.plotOptions, c.plotOptions);
                c.time && this.time === a.time && (this.time = new a.Time(c.time));
                k(c, function(a, b) {
                    if (l[b] && "function" === typeof l[b].update) l[b].update(a, !1); else if ("function" === typeof l[h[b]]) l[h[b]](a);
                    "chart" !== b && -1 !== l.propsRequireUpdateSeries.indexOf(b) && (w = !0);
                });
                this.collectionsWithUpdate.forEach(function(a) {
                    var b;
                    c[a] && ("series" === a && (b = [], l[a].forEach(function(a, c) {
                        a.options.isInternal || b.push(p(a.options.index, c));
                    })), F(c[a]).forEach(function(c, d) {
                        (d = t(c.id) && l.get(c.id) || l[a][b ? b[d] : d]) && d.coll === a && (d.update(c, !1), 
                        e && (d.touched = !0));
                        !d && e && l.collectionsWithInit[a] && (l.collectionsWithInit[a][0].apply(l, [ c ].concat(l.collectionsWithInit[a][1] || []).concat([ !1 ])).touched = !0);
                    }), e && l[a].forEach(function(a) {
                        a.touched || a.options.isInternal ? delete a.touched : x.push(a);
                    }));
                });
                x.forEach(function(a) {
                    a.remove && a.remove(!1);
                });
                r && l.axes.forEach(function(a) {
                    a.update({}, !1);
                });
                w && l.series.forEach(function(a) {
                    a.update({}, !1);
                });
                c.loading && b(!0, l.options.loading, c.loading);
                r = f && f.width;
                f = f && f.height;
                a.isString(f) && (f = a.relativeLength(f, r || l.chartWidth));
                q || g(r) && r !== l.chartWidth || g(f) && f !== l.chartHeight ? l.setSize(r, f, m) : p(d, !0) && l.redraw(m);
                n(l, "afterUpdate", {
                    options: c,
                    redraw: d,
                    animation: m
                });
            },
            setSubtitle: function(a) {
                this.setTitle(void 0, a);
            }
        });
        h.prototype.collectionsWithInit = {
            xAxis: [ h.prototype.addAxis, [ !0 ] ],
            yAxis: [ h.prototype.addAxis, [ !1 ] ],
            series: [ h.prototype.addSeries ]
        };
        v(c.prototype, {
            update: function(a, b, c, e) {
                function g() {
                    l.applyOptions(a);
                    null === l.y && k && (l.graphic = k.destroy());
                    d(a, !0) && (k && k.element && a && a.marker && void 0 !== a.marker.symbol && (l.graphic = k.destroy()), 
                    a && a.dataLabels && l.dataLabel && (l.dataLabel = l.dataLabel.destroy()), l.connector && (l.connector = l.connector.destroy()));
                    m = l.index;
                    f.updateParallelArrays(l, m);
                    n.data[m] = d(n.data[m], !0) || d(a, !0) ? l.options : p(a, n.data[m]);
                    f.isDirty = f.isDirtyData = !0;
                    !f.fixedBox && f.hasCartesianSeries && (h.isDirtyBox = !0);
                    "point" === n.legendType && (h.isDirtyLegend = !0);
                    b && h.redraw(c);
                }
                var l = this, f = l.series, k = l.graphic, m, h = f.chart, n = f.options;
                b = p(b, !0);
                !1 === e ? g() : l.firePointEvent("update", {
                    options: a
                }, g);
            },
            remove: function(a, b) {
                this.series.removePoint(this.series.data.indexOf(this), a, b);
            }
        });
        v(x.prototype, {
            addPoint: function(a, b, c, d, e) {
                var g = this.options, f = this.data, l = this.chart, k = this.xAxis, k = k && k.hasNames && k.names, m = g.data, h, w = this.xData, q, x, C;
                b = p(b, !0);
                h = {
                    series: this
                };
                this.pointClass.prototype.applyOptions.apply(h, [ a ]);
                C = h.x;
                x = w.length;
                if (this.requireSorting && C < w[x - 1]) for (q = !0; x && w[x - 1] > C; ) x--;
                this.updateParallelArrays(h, "splice", x, 0, 0);
                this.updateParallelArrays(h, x);
                k && h.name && (k[C] = h.name);
                m.splice(x, 0, a);
                q && (this.data.splice(x, 0, null), this.processData());
                "point" === g.legendType && this.generatePoints();
                c && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(h, "shift"), 
                m.shift()));
                !1 !== e && n(this, "addPoint", {
                    point: h
                });
                this.isDirtyData = this.isDirty = !0;
                b && l.redraw(d);
            },
            removePoint: function(a, b, c) {
                var d = this, e = d.data, g = e[a], f = d.points, l = d.chart, k = function() {
                    f && f.length === e.length && f.splice(a, 1);
                    e.splice(a, 1);
                    d.options.data.splice(a, 1);
                    d.updateParallelArrays(g || {
                        series: d
                    }, "splice", a, 1);
                    g && g.destroy();
                    d.isDirty = !0;
                    d.isDirtyData = !0;
                    b && l.redraw();
                };
                w(c, l);
                b = p(b, !0);
                g ? g.firePointEvent("remove", null, k) : k();
            },
            remove: function(a, b, c, d) {
                function e() {
                    g.destroy(d);
                    g.remove = null;
                    f.isDirtyLegend = f.isDirtyBox = !0;
                    f.linkSeries();
                    p(a, !0) && f.redraw(b);
                }
                var g = this, f = g.chart;
                !1 !== c ? n(g, "remove", null, e) : e();
            },
            update: function(c, d) {
                c = a.cleanRecursively(c, this.userOptions);
                n(this, "update", {
                    options: c
                });
                var e = this, g = e.chart, l = e.userOptions, k, f = e.initialType || e.type, m = c.type || l.type || g.options.chart.type, h = !(this.hasDerivedData || c.dataGrouping || m && m !== this.type || void 0 !== c.pointStart || c.pointInterval || c.pointIntervalUnit || c.keys), w = K[f].prototype, q, x = [ "group", "markerGroup", "dataLabelsGroup", "transformGroup" ], t = [ "navigatorSeries", "baseSeries" ], C = e.finishedAnimating && {
                    animation: !1
                }, u = {};
                h && (t.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "_hasPointMarkers", "_hasPointLabels", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), 
                !1 !== c.visible && t.push("area", "graph"), e.parallelArrays.forEach(function(a) {
                    t.push(a + "Data");
                }), c.data && this.setData(c.data, !1));
                c = b(l, C, {
                    index: void 0 === l.index ? e.index : l.index,
                    pointStart: p(l.pointStart, e.xData[0])
                }, !h && {
                    data: e.options.data
                }, c);
                t = x.concat(t);
                t.forEach(function(a) {
                    t[a] = e[a];
                    delete e[a];
                });
                e.remove(!1, null, !1, !0);
                for (q in w) e[q] = void 0;
                K[m || f] ? v(e, K[m || f].prototype) : a.error(17, !0, g);
                t.forEach(function(a) {
                    e[a] = t[a];
                });
                e.init(g, c);
                h && this.points && (k = e.options, !1 === k.visible ? (u.graphic = 1, u.dataLabel = 1) : (k.marker && !1 === k.marker.enabled && !e._hasPointMarkers && (u.graphic = 1), 
                k.dataLabels && !1 === k.dataLabels.enabled && !e._hasPointLabels && (u.dataLabel = 1)), 
                this.points.forEach(function(a) {
                    a && a.series && (a.resolveColor(), Object.keys(u).length && a.destroyElements(u), 
                    !1 === k.showInLegend && a.legendItem && g.legend.destroyItem(a));
                }, this));
                c.zIndex !== l.zIndex && x.forEach(function(a) {
                    e[a] && e[a].attr({
                        zIndex: c.zIndex
                    });
                });
                e.initialType = f;
                g.linkSeries();
                n(this, "afterUpdate");
                p(d, !0) && g.redraw(h ? void 0 : !1);
            },
            setName: function(a) {
                this.name = this.options.name = this.userOptions.name = a;
                this.chart.isDirtyLegend = !0;
            }
        });
        v(B.prototype, {
            update: function(a, c) {
                var d = this.chart, e = a && a.events || {};
                a = b(this.userOptions, a);
                d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);
                k(d.options[this.coll].events, function(a, b) {
                    "undefined" === typeof e[b] && (e[b] = void 0);
                });
                this.destroy(!0);
                this.init(d, v(a, {
                    events: e
                }));
                d.isDirtyBox = !0;
                p(c, !0) && d.redraw();
            },
            remove: function(a) {
                for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--; ) d[e] && d[e].remove(!1);
                u(b.axes, this);
                u(b[c], this);
                m(b.options[c]) ? b.options[c].splice(this.options.index, 1) : delete b.options[c];
                b[c].forEach(function(a, b) {
                    a.options.index = a.userOptions.index = b;
                });
                this.destroy();
                b.isDirtyBox = !0;
                p(a, !0) && b.redraw();
            },
            setTitle: function(a, b) {
                this.update({
                    title: a
                }, b);
            },
            setCategories: function(a, b) {
                this.update({
                    categories: a
                }, b);
            }
        });
    });
    J(G, "parts/AreaSeries.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.color, H = a.pick, B = a.Series, h = a.seriesType;
        h("area", "line", {
            softThreshold: !1,
            threshold: 0
        }, {
            singleStacks: !1,
            getStackPoints: function(e) {
                var h = [], t = [], u = this.xAxis, v = this.yAxis, n = v.stacks[this.stackKey], g = {}, d = this.index, m = v.series, b = m.length, k, p = H(v.options.reversedStacks, !0) ? 1 : -1, c;
                e = e || this.points;
                if (this.options.stacking) {
                    for (c = 0; c < e.length; c++) e[c].leftNull = e[c].rightNull = null, g[e[c].x] = e[c];
                    a.objectEach(n, function(a, b) {
                        null !== a.total && t.push(b);
                    });
                    t.sort(function(a, b) {
                        return a - b;
                    });
                    k = m.map(function(a) {
                        return a.visible;
                    });
                    t.forEach(function(a, e) {
                        var m = 0, q, x;
                        if (g[a] && !g[a].isNull) h.push(g[a]), [ -1, 1 ].forEach(function(l) {
                            var m = 1 === l ? "rightNull" : "leftNull", h = 0, w = n[t[e + l]];
                            if (w) for (c = d; 0 <= c && c < b; ) q = w.points[c], q || (c === d ? g[a][m] = !0 : k[c] && (x = n[a].points[c]) && (h -= x[1] - x[0])), 
                            c += p;
                            g[a][1 === l ? "rightCliff" : "leftCliff"] = h;
                        }); else {
                            for (c = d; 0 <= c && c < b; ) {
                                if (q = n[a].points[c]) {
                                    m = q[1];
                                    break;
                                }
                                c += p;
                            }
                            m = v.translate(m, 0, 1, 0, 1);
                            h.push({
                                isNull: !0,
                                plotX: u.translate(a, 0, 0, 0, 1),
                                x: a,
                                plotY: m,
                                yBottom: m
                            });
                        }
                    });
                }
                return h;
            },
            getGraphPath: function(e) {
                var h = B.prototype.getGraphPath, t = this.options, u = t.stacking, v = this.yAxis, n, g, d = [], m = [], b = this.index, k, p = v.stacks[this.stackKey], c = t.threshold, x = v.getThreshold(t.threshold), K, t = a.pick(t.connectNulls, "percent" === u), w = function(a, g, l) {
                    var h = e[a];
                    a = u && p[h.x].points[b];
                    var n = h[l + "Null"] || 0;
                    l = h[l + "Cliff"] || 0;
                    var w, q, h = !0;
                    l || n ? (w = (n ? a[0] : a[1]) + l, q = a[0] + l, h = !!n) : !u && e[g] && e[g].isNull && (w = q = c);
                    void 0 !== w && (m.push({
                        plotX: k,
                        plotY: null === w ? x : v.getThreshold(w),
                        isNull: h,
                        isCliff: !0
                    }), d.push({
                        plotX: k,
                        plotY: null === q ? x : v.getThreshold(q),
                        doCurve: !1
                    }));
                };
                e = e || this.points;
                u && (e = this.getStackPoints(e));
                for (n = 0; n < e.length; n++) if (g = e[n].isNull, k = H(e[n].rectPlotX, e[n].plotX), 
                K = H(e[n].yBottom, x), !g || t) t || w(n, n - 1, "left"), g && !u && t || (m.push(e[n]), 
                d.push({
                    x: n,
                    plotX: k,
                    plotY: K
                })), t || w(n, n + 1, "right");
                n = h.call(this, m, !0, !0);
                d.reversed = !0;
                g = h.call(this, d, !0, !0);
                g.length && (g[0] = "L");
                g = n.concat(g);
                h = h.call(this, m, !1, t);
                g.xMap = n.xMap;
                this.areaPath = g;
                return h;
            },
            drawGraph: function() {
                this.areaPath = [];
                B.prototype.drawGraph.apply(this);
                var a = this, h = this.areaPath, t = this.options, u = [ [ "area", "highcharts-area", this.color, t.fillColor ] ];
                this.zones.forEach(function(e, h) {
                    u.push([ "zone-area-" + h, "highcharts-area highcharts-zone-area-" + h + " " + e.className, e.color || a.color, e.fillColor || t.fillColor ]);
                });
                u.forEach(function(e) {
                    var n = e[0], g = a[n], d = g ? "animate" : "attr", m = {};
                    g ? (g.endX = a.preventGraphAnimation ? null : h.xMap, g.animate({
                        d: h
                    })) : (m.zIndex = 0, g = a[n] = a.chart.renderer.path(h).addClass(e[1]).add(a.group), 
                    g.isArea = !0);
                    a.chart.styledMode || (m.fill = H(e[3], E(e[2]).setOpacity(H(t.fillOpacity, .75)).get()));
                    g[d](m);
                    g.startX = h.xMap;
                    g.shiftUnit = t.step ? 2 : 1;
                });
            },
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
        });
    });
    J(G, "parts/SplineSeries.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.pick;
        a = a.seriesType;
        a("spline", "line", {}, {
            getPointSpline: function(a, B, h) {
                var e = B.plotX, q = B.plotY, t = a[h - 1];
                h = a[h + 1];
                var u, v, n, g;
                if (t && !t.isNull && !1 !== t.doCurve && !B.isCliff && h && !h.isNull && !1 !== h.doCurve && !B.isCliff) {
                    a = t.plotY;
                    n = h.plotX;
                    h = h.plotY;
                    var d = 0;
                    u = (1.5 * e + t.plotX) / 2.5;
                    v = (1.5 * q + a) / 2.5;
                    n = (1.5 * e + n) / 2.5;
                    g = (1.5 * q + h) / 2.5;
                    n !== u && (d = (g - v) * (n - e) / (n - u) + q - g);
                    v += d;
                    g += d;
                    v > a && v > q ? (v = Math.max(a, q), g = 2 * q - v) : v < a && v < q && (v = Math.min(a, q), 
                    g = 2 * q - v);
                    g > h && g > q ? (g = Math.max(h, q), v = 2 * q - g) : g < h && g < q && (g = Math.min(h, q), 
                    v = 2 * q - g);
                    B.rightContX = n;
                    B.rightContY = g;
                }
                B = [ "C", E(t.rightContX, t.plotX), E(t.rightContY, t.plotY), E(u, e), E(v, q), e, q ];
                t.rightContX = t.rightContY = null;
                return B;
            }
        });
    });
    J(G, "parts/AreaSplineSeries.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.seriesTypes.area.prototype, H = a.seriesType;
        H("areaspline", "spline", a.defaultPlotOptions.area, {
            getStackPoints: E.getStackPoints,
            getGraphPath: E.getGraphPath,
            drawGraph: E.drawGraph,
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
        });
    });
    J(G, "parts/ColumnSeries.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.animObject, H = a.color, B = a.extend, h = a.defined, e = a.isNumber, q = a.merge, t = a.pick, u = a.Series, v = a.seriesType, n = a.svg;
        v("column", "line", {
            borderRadius: 0,
            crisp: !0,
            groupPadding: .2,
            marker: null,
            pointPadding: .1,
            minPointLength: 0,
            cropThreshold: 50,
            pointRange: null,
            states: {
                hover: {
                    halo: !1,
                    brightness: .1
                },
                select: {
                    color: "#cccccc",
                    borderColor: "#000000"
                }
            },
            dataLabels: {
                align: null,
                verticalAlign: null,
                y: null
            },
            softThreshold: !1,
            startFromThreshold: !0,
            stickyTracking: !1,
            tooltip: {
                distance: 6
            },
            threshold: 0,
            borderColor: "#ffffff"
        }, {
            cropShoulder: 0,
            directTouch: !0,
            trackerGroups: [ "group", "dataLabelsGroup" ],
            negStacks: !0,
            init: function() {
                u.prototype.init.apply(this, arguments);
                var a = this, d = a.chart;
                d.hasRendered && d.series.forEach(function(d) {
                    d.type === a.type && (d.isDirty = !0);
                });
            },
            getColumnMetrics: function() {
                var a = this, d = a.options, e = a.xAxis, b = a.yAxis, k = e.options.reversedStacks, k = e.reversed && !k || !e.reversed && k, h, c = {}, n = 0;
                !1 === d.grouping ? n = 1 : a.chart.series.forEach(function(d) {
                    var e = d.options, g = d.yAxis, k;
                    d.type !== a.type || !d.visible && a.chart.options.chart.ignoreHiddenSeries || b.len !== g.len || b.pos !== g.pos || (e.stacking ? (h = d.stackKey, 
                    void 0 === c[h] && (c[h] = n++), k = c[h]) : !1 !== e.grouping && (k = n++), d.columnIndex = k);
                });
                var q = Math.min(Math.abs(e.transA) * (e.ordinalSlope || d.pointRange || e.closestPointRange || e.tickInterval || 1), e.len), w = q * d.groupPadding, u = (q - 2 * w) / (n || 1), d = Math.min(d.maxPointWidth || e.len, t(d.pointWidth, u * (1 - 2 * d.pointPadding)));
                a.columnMetrics = {
                    width: d,
                    offset: (u - d) / 2 + (w + ((a.columnIndex || 0) + (k ? 1 : 0)) * u - q / 2) * (k ? -1 : 1)
                };
                return a.columnMetrics;
            },
            crispCol: function(a, d, e, b) {
                var g = this.chart, m = this.borderWidth, c = -(m % 2 ? .5 : 0), m = m % 2 ? .5 : 1;
                g.inverted && g.renderer.isVML && (m += 1);
                this.options.crisp && (e = Math.round(a + e) + c, a = Math.round(a) + c, e -= a);
                b = Math.round(d + b) + m;
                c = .5 >= Math.abs(d) && .5 < b;
                d = Math.round(d) + m;
                b -= d;
                c && b && (--d, b += 1);
                return {
                    x: a,
                    y: d,
                    width: e,
                    height: b
                };
            },
            translate: function() {
                var a = this, d = a.chart, e = a.options, b = a.dense = 2 > a.closestPointRange * a.xAxis.transA, b = a.borderWidth = t(e.borderWidth, b ? 0 : 1), k = a.yAxis, p = e.threshold, c = a.translatedThreshold = k.getThreshold(p), n = t(e.minPointLength, 5), q = a.getColumnMetrics(), w = q.width, v = a.barW = Math.max(w, 1 + 2 * b), C = a.pointXOffset = q.offset, l = a.dataMin, D = a.dataMax;
                d.inverted && (c -= .5);
                e.pointPadding && (v = Math.ceil(v));
                u.prototype.translate.apply(a);
                a.points.forEach(function(b) {
                    var e = t(b.yBottom, c), g = 999 + Math.abs(e), f = w, g = Math.min(Math.max(-g, b.plotY), k.len + g), m = b.plotX + C, q = v, x = Math.min(g, e), u, A = Math.max(g, e) - x;
                    n && Math.abs(A) < n && (A = n, u = !k.reversed && !b.negative || k.reversed && b.negative, 
                    b.y === p && a.dataMax <= p && k.min < p && l !== D && (u = !u), x = Math.abs(x - c) > n ? e - n : c - (u ? n : 0));
                    h(b.options.pointWidth) && (f = q = Math.ceil(b.options.pointWidth), m -= Math.round((f - w) / 2));
                    b.barX = m;
                    b.pointWidth = f;
                    b.tooltipPos = d.inverted ? [ k.len + k.pos - d.plotLeft - g, a.xAxis.len - m - q / 2, A ] : [ m + q / 2, g + k.pos - d.plotTop, A ];
                    b.shapeType = a.pointClass.prototype.shapeType || "rect";
                    b.shapeArgs = a.crispCol.apply(a, b.isNull ? [ m, c, q, 0 ] : [ m, x, q, A ]);
                });
            },
            getSymbol: a.noop,
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
            drawGraph: function() {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            },
            pointAttribs: function(a, d) {
                var e = this.options, b, k = this.pointAttrToOptions || {};
                b = k.stroke || "borderColor";
                var g = k["stroke-width"] || "borderWidth", c = a && a.color || this.color, h = a && a[b] || e[b] || this.color || c, n = a && a[g] || e[g] || this[g] || 0, k = a && a.dashStyle || e.dashStyle, w = t(e.opacity, 1), u;
                a && this.zones.length && (u = a.getZone(), c = a.options.color || u && u.color || this.color, 
                u && (h = u.borderColor || h, k = u.dashStyle || k, n = u.borderWidth || n));
                d && (a = q(e.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, 
                c = a.color || void 0 !== d && H(c).brighten(a.brightness).get() || c, h = a[b] || h, 
                n = a[g] || n, k = a.dashStyle || k, w = t(a.opacity, w));
                b = {
                    fill: c,
                    stroke: h,
                    "stroke-width": n,
                    opacity: w
                };
                k && (b.dashstyle = k);
                return b;
            },
            drawPoints: function() {
                var a = this, d = this.chart, m = a.options, b = d.renderer, k = m.animationLimit || 250, h;
                a.points.forEach(function(c) {
                    var g = c.graphic, p = g && d.pointCount < k ? "animate" : "attr";
                    if (e(c.plotY) && null !== c.y) {
                        h = c.shapeArgs;
                        g && g.element.nodeName !== c.shapeType && (g = g.destroy());
                        if (g) g[p](q(h)); else c.graphic = g = b[c.shapeType](h).add(c.group || a.group);
                        if (m.borderRadius) g[p]({
                            r: m.borderRadius
                        });
                        d.styledMode || g[p](a.pointAttribs(c, c.selected && "select")).shadow(!1 !== c.allowShadow && m.shadow, null, m.stacking && !m.borderRadius);
                        g.addClass(c.getClassName(), !0);
                    } else g && (c.graphic = g.destroy());
                });
            },
            animate: function(a) {
                var d = this, e = this.yAxis, b = d.options, g = this.chart.inverted, h = {}, c = g ? "translateX" : "translateY", q;
                n && (a ? (h.scaleY = .001, a = Math.min(e.pos + e.len, Math.max(e.pos, e.toPixels(b.threshold))), 
                g ? h.translateX = a - e.len : h.translateY = a, d.clipBox && d.setClip(), d.group.attr(h)) : (q = d.group.attr(c), 
                d.group.animate({
                    scaleY: 1
                }, B(E(d.options.animation), {
                    step: function(a, b) {
                        h[c] = q + b.pos * (e.pos - q);
                        d.group.attr(h);
                    }
                })), d.animate = null));
            },
            remove: function() {
                var a = this, d = a.chart;
                d.hasRendered && d.series.forEach(function(d) {
                    d.type === a.type && (d.isDirty = !0);
                });
                u.prototype.remove.apply(a, arguments);
            }
        });
    });
    J(G, "parts/BarSeries.js", [ G["parts/Globals.js"] ], function(a) {
        a = a.seriesType;
        a("bar", "column", null, {
            inverted: !0
        });
    });
    J(G, "parts/ScatterSeries.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.Series, H = a.seriesType;
        H("scatter", "line", {
            lineWidth: 0,
            findNearestPointBy: "xy",
            jitter: {
                x: 0,
                y: 0
            },
            marker: {
                enabled: !0
            },
            tooltip: {
                headerFormat: '<span style="color:{point.color}"></span> <span style="font-size: 10px"> {series.name}</span><br/>',
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
            }
        }, {
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: [ "group", "markerGroup", "dataLabelsGroup" ],
            takeOrdinalPosition: !1,
            drawGraph: function() {
                this.options.lineWidth && E.prototype.drawGraph.call(this);
            },
            applyJitter: function() {
                var a = this, h = this.options.jitter, e = this.points.length;
                h && this.points.forEach(function(q, t) {
                    [ "x", "y" ].forEach(function(u, v) {
                        var n, g = "plot" + u.toUpperCase(), d, m;
                        h[u] && !q.isNull && (n = a[u + "Axis"], m = h[u] * n.transA, n && !n.isLog && (d = Math.max(0, q[g] - m), 
                        n = Math.min(n.len, q[g] + m), v = 1e4 * Math.sin(t + v * e), q[g] = d + (n - d) * (v - Math.floor(v)), 
                        "x" === u && (q.clientX = q.plotX)));
                    });
                });
            }
        });
        a.addEvent(E, "afterTranslate", function() {
            this.applyJitter && this.applyJitter();
        });
    });
    J(G, "mixins/centered-series.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.deg2rad, H = a.isNumber, B = a.pick, h = a.relativeLength;
        a.CenteredSeriesMixin = {
            getCenter: function() {
                var a = this.options, q = this.chart, t = 2 * (a.slicedOffset || 0), u = q.plotWidth - 2 * t, q = q.plotHeight - 2 * t, v = a.center, v = [ B(v[0], "50%"), B(v[1], "50%"), a.size || "100%", a.innerSize || 0 ], n = Math.min(u, q), g, d;
                for (g = 0; 4 > g; ++g) d = v[g], a = 2 > g || 2 === g && /%$/.test(d), v[g] = h(d, [ u, q, n, v[2] ][g]) + (a ? t : 0);
                v[3] > v[2] && (v[3] = v[2]);
                return v;
            },
            getStartAndEndRadians: function(a, h) {
                a = H(a) ? a : 0;
                h = H(h) && h > a && 360 > h - a ? h : a + 360;
                return {
                    start: E * (a + -90),
                    end: E * (h + -90)
                };
            }
        };
    });
    J(G, "parts/PieSeries.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, H = a.CenteredSeriesMixin, B = a.defined, h = H.getStartAndEndRadians, e = a.merge, q = a.noop, t = a.pick, u = a.Point, v = a.Series, n = a.seriesType, g = a.setAnimation;
        n("pie", "line", {
            center: [ null, null ],
            clip: !1,
            colorByPoint: !0,
            dataLabels: {
                allowOverlap: !0,
                connectorPadding: 5,
                distance: 30,
                enabled: !0,
                formatter: function() {
                    return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: !0,
                x: 0,
                connectorShape: "fixedOffset",
                crookDistance: "70%"
            },
            ignoreHiddenPoint: !0,
            inactiveOtherPoints: !0,
            legendType: "point",
            marker: null,
            size: null,
            showInLegend: !1,
            slicedOffset: 10,
            stickyTracking: !1,
            tooltip: {
                followPointer: !0
            },
            borderColor: "#ffffff",
            borderWidth: 1,
            states: {
                hover: {
                    brightness: .1
                }
            }
        }, {
            isCartesian: !1,
            requireSorting: !1,
            directTouch: !0,
            noSharedTooltip: !0,
            trackerGroups: [ "group", "dataLabelsGroup" ],
            axisTypes: [],
            pointAttribs: a.seriesTypes.column.prototype.pointAttribs,
            animate: function(a) {
                var d = this, b = d.points, e = d.startAngleRad;
                a || (b.forEach(function(a) {
                    var b = a.graphic, g = a.shapeArgs;
                    b && (b.attr({
                        r: a.startR || d.center[3] / 2,
                        start: e,
                        end: e
                    }), b.animate({
                        r: g.r,
                        start: g.start,
                        end: g.end
                    }, d.options.animation));
                }), d.animate = null);
            },
            hasData: function() {
                return !!this.processedXData.length;
            },
            updateTotals: function() {
                var a, e = 0, b = this.points, g = b.length, h, c = this.options.ignoreHiddenPoint;
                for (a = 0; a < g; a++) h = b[a], e += c && !h.visible ? 0 : h.isNull ? 0 : h.y;
                this.total = e;
                for (a = 0; a < g; a++) h = b[a], h.percentage = 0 < e && (h.visible || !c) ? h.y / e * 100 : 0, 
                h.total = e;
            },
            generatePoints: function() {
                v.prototype.generatePoints.call(this);
                this.updateTotals();
            },
            getX: function(a, e, b) {
                var d = this.center, g = this.radii ? this.radii[b.index] : d[2] / 2;
                return d[0] + (e ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((a - d[1]) / (g + b.labelDistance), 1), -1))) * (g + b.labelDistance) + (0 < b.labelDistance ? (e ? -1 : 1) * this.options.dataLabels.padding : 0);
            },
            translate: function(d) {
                this.generatePoints();
                var e = 0, b = this.options, g = b.slicedOffset, p = g + (b.borderWidth || 0), c, n, q = h(b.startAngle, b.endAngle), w = this.startAngleRad = q.start, q = (this.endAngleRad = q.end) - w, u = this.points, C, l, v = b.dataLabels.distance, b = b.ignoreHiddenPoint, A, z = u.length, B;
                d || (this.center = d = this.getCenter());
                for (A = 0; A < z; A++) {
                    B = u[A];
                    c = w + e * q;
                    if (!b || B.visible) e += B.percentage / 100;
                    n = w + e * q;
                    B.shapeType = "arc";
                    B.shapeArgs = {
                        x: d[0],
                        y: d[1],
                        r: d[2] / 2,
                        innerR: d[3] / 2,
                        start: Math.round(1e3 * c) / 1e3,
                        end: Math.round(1e3 * n) / 1e3
                    };
                    B.labelDistance = t(B.options.dataLabels && B.options.dataLabels.distance, v);
                    B.labelDistance = a.relativeLength(B.labelDistance, B.shapeArgs.r);
                    this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, B.labelDistance);
                    n = (n + c) / 2;
                    n > 1.5 * Math.PI ? n -= 2 * Math.PI : n < -Math.PI / 2 && (n += 2 * Math.PI);
                    B.slicedTranslation = {
                        translateX: Math.round(Math.cos(n) * g),
                        translateY: Math.round(Math.sin(n) * g)
                    };
                    C = Math.cos(n) * d[2] / 2;
                    l = Math.sin(n) * d[2] / 2;
                    B.tooltipPos = [ d[0] + .7 * C, d[1] + .7 * l ];
                    B.half = n < -Math.PI / 2 || n > Math.PI / 2 ? 1 : 0;
                    B.angle = n;
                    c = Math.min(p, B.labelDistance / 5);
                    B.labelPosition = {
                        natural: {
                            x: d[0] + C + Math.cos(n) * B.labelDistance,
                            y: d[1] + l + Math.sin(n) * B.labelDistance
                        },
                        final: {},
                        alignment: 0 > B.labelDistance ? "center" : B.half ? "right" : "left",
                        connectorPosition: {
                            breakAt: {
                                x: d[0] + C + Math.cos(n) * c,
                                y: d[1] + l + Math.sin(n) * c
                            },
                            touchingSliceAt: {
                                x: d[0] + C,
                                y: d[1] + l
                            }
                        }
                    };
                }
            },
            drawGraph: null,
            redrawPoints: function() {
                var a = this, g = a.chart, b = g.renderer, k, h, c, n, q = a.options.shadow;
                !q || a.shadowGroup || g.styledMode || (a.shadowGroup = b.g("shadow").attr({
                    zIndex: -1
                }).add(a.group));
                a.points.forEach(function(d) {
                    var m = {};
                    h = d.graphic;
                    if (!d.isNull && h) {
                        n = d.shapeArgs;
                        k = d.getTranslate();
                        if (!g.styledMode) {
                            var p = d.shadowGroup;
                            q && !p && (p = d.shadowGroup = b.g("shadow").add(a.shadowGroup));
                            p && p.attr(k);
                            c = a.pointAttribs(d, d.selected && "select");
                        }
                        d.delayedRendering ? (h.setRadialReference(a.center).attr(n).attr(k), g.styledMode || h.attr(c).attr({
                            "stroke-linejoin": "round"
                        }).shadow(q, p), d.delayedRendering = !1) : (h.setRadialReference(a.center), g.styledMode || e(!0, m, c), 
                        e(!0, m, n, k), h.animate(m));
                        h.attr({
                            visibility: d.visible ? "inherit" : "hidden"
                        });
                        h.addClass(d.getClassName());
                    } else h && (d.graphic = h.destroy());
                });
            },
            drawPoints: function() {
                var a = this.chart.renderer;
                this.points.forEach(function(d) {
                    d.graphic || (d.graphic = a[d.shapeType](d.shapeArgs).add(d.series.group), d.delayedRendering = !0);
                });
            },
            searchPoint: q,
            sortByAngle: function(a, e) {
                a.sort(function(a, d) {
                    return void 0 !== a.angle && (d.angle - a.angle) * e;
                });
            },
            drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
            getCenter: H.getCenter,
            getSymbol: q
        }, {
            init: function() {
                u.prototype.init.apply(this, arguments);
                var a = this, e;
                a.name = t(a.name, "Slice");
                e = function(b) {
                    a.slice("select" === b.type);
                };
                E(a, "select", e);
                E(a, "unselect", e);
                return a;
            },
            isValid: function() {
                return a.isNumber(this.y, !0) && 0 <= this.y;
            },
            setVisible: function(a, e) {
                var b = this, d = b.series, g = d.chart, c = d.options.ignoreHiddenPoint;
                e = t(e, c);
                a !== b.visible && (b.visible = b.options.visible = a = void 0 === a ? !b.visible : a, 
                d.options.data[d.data.indexOf(b)] = b.options, [ "graphic", "dataLabel", "connector", "shadowGroup" ].forEach(function(c) {
                    if (b[c]) b[c][a ? "show" : "hide"](!0);
                }), b.legendItem && g.legend.colorizeItem(b, a), a || "hover" !== b.state || b.setState(""), 
                c && (d.isDirty = !0), e && g.redraw());
            },
            slice: function(a, e, b) {
                var d = this.series;
                g(b, d.chart);
                t(e, !0);
                this.sliced = this.options.sliced = B(a) ? a : !this.sliced;
                d.options.data[d.data.indexOf(this)] = this.options;
                this.graphic.animate(this.getTranslate());
                this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
            },
            getTranslate: function() {
                return this.sliced ? this.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };
            },
            haloPath: function(a) {
                var d = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + a, d.r + a, {
                    innerR: this.shapeArgs.r - 1,
                    start: d.start,
                    end: d.end
                });
            },
            connectorShapes: {
                fixedOffset: function(a, e, b) {
                    var d = e.breakAt;
                    e = e.touchingSliceAt;
                    return [ "M", a.x, a.y ].concat(b.softConnector ? [ "C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * d.x - e.x, 2 * d.y - e.y, d.x, d.y ] : [ "L", d.x, d.y ]).concat([ "L", e.x, e.y ]);
                },
                straight: function(a, e) {
                    e = e.touchingSliceAt;
                    return [ "M", a.x, a.y, "L", e.x, e.y ];
                },
                crookedLine: function(d, e, b) {
                    e = e.touchingSliceAt;
                    var g = this.series, h = g.center[0], c = g.chart.plotWidth, m = g.chart.plotLeft, g = d.alignment, n = this.shapeArgs.r;
                    b = a.relativeLength(b.crookDistance, 1);
                    b = "left" === g ? h + n + (c + m - h - n) * (1 - b) : m + (h - n) * b;
                    h = [ "L", b, d.y ];
                    if ("left" === g ? b > d.x || b < e.x : b < d.x || b > e.x) h = [];
                    return [ "M", d.x, d.y ].concat(h).concat([ "L", e.x, e.y ]);
                }
            },
            getConnectorPath: function() {
                var a = this.labelPosition, e = this.series.options.dataLabels, b = e.connectorShape, g = this.connectorShapes;
                g[b] && (b = g[b]);
                return b.call(this, {
                    x: a.final.x,
                    y: a.final.y,
                    alignment: a.alignment
                }, a.connectorPosition, e);
            }
        });
    });
    J(G, "parts/DataLabels.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.arrayMax, H = a.defined, B = a.extend, h = a.format, e = a.merge, q = a.noop, t = a.pick, u = a.relativeLength, v = a.Series, n = a.seriesTypes, g = a.stableSort, d = a.isArray, m = a.splat;
        a.distribute = function(b, d, e) {
            function c(a, b) {
                return a.target - b.target;
            }
            var k, h = !0, m = b, p = [], n;
            n = 0;
            var l = m.reducedLen || d;
            for (k = b.length; k--; ) n += b[k].size;
            if (n > l) {
                g(b, function(a, b) {
                    return (b.rank || 0) - (a.rank || 0);
                });
                for (n = k = 0; n <= l; ) n += b[k].size, k++;
                p = b.splice(k - 1, b.length);
            }
            g(b, c);
            for (b = b.map(function(a) {
                return {
                    size: a.size,
                    targets: [ a.target ],
                    align: t(a.align, .5)
                };
            }); h; ) {
                for (k = b.length; k--; ) h = b[k], n = (Math.min.apply(0, h.targets) + Math.max.apply(0, h.targets)) / 2, 
                h.pos = Math.min(Math.max(0, n - h.size * h.align), d - h.size);
                k = b.length;
                for (h = !1; k--; ) 0 < k && b[k - 1].pos + b[k - 1].size > b[k].pos && (b[k - 1].size += b[k].size, 
                b[k - 1].targets = b[k - 1].targets.concat(b[k].targets), b[k - 1].align = .5, b[k - 1].pos + b[k - 1].size > d && (b[k - 1].pos = d - b[k - 1].size), 
                b.splice(k, 1), h = !0);
            }
            m.push.apply(m, p);
            k = 0;
            b.some(function(b) {
                var c = 0;
                if (b.targets.some(function() {
                    m[k].pos = b.pos + c;
                    if (Math.abs(m[k].pos - m[k].target) > e) return m.slice(0, k + 1).forEach(function(a) {
                        delete a.pos;
                    }), m.reducedLen = (m.reducedLen || d) - .1 * d, m.reducedLen > .1 * d && a.distribute(m, d, e), 
                    !0;
                    c += m[k].size;
                    k++;
                })) return !0;
            });
            g(m, c);
        };
        v.prototype.drawDataLabels = function() {
            function b(a, b) {
                var c = b.filter;
                return c ? (b = c.operator, a = a[c.property], c = c.value, ">" === b && a > c || "<" === b && a < c || ">=" === b && a >= c || "<=" === b && a <= c || "==" === b && a == c || "===" === b && a === c ? !0 : !1) : !0;
            }
            function g(a, b) {
                var c = [], f;
                if (d(a) && !d(b)) c = a.map(function(a) {
                    return e(a, b);
                }); else if (d(b) && !d(a)) c = b.map(function(b) {
                    return e(a, b);
                }); else if (d(a) || d(b)) for (f = Math.max(a.length, b.length); f--; ) c[f] = e(a[f], b[f]); else c = e(a, b);
                return c;
            }
            var p = this, c = p.chart, n = p.options, q = n.dataLabels, w = p.points, u, C = p.hasRendered || 0, l, v = a.animObject(n.animation).duration, A = Math.min(v, 200), z = !c.renderer.forExport && t(q.defer, 0 < A), B = c.renderer, q = g(g(c.options.plotOptions && c.options.plotOptions.series && c.options.plotOptions.series.dataLabels, c.options.plotOptions && c.options.plotOptions[p.type] && c.options.plotOptions[p.type].dataLabels), q);
            a.fireEvent(this, "drawDataLabels");
            if (d(q) || q.enabled || p._hasPointLabels) l = p.plotGroup("dataLabelsGroup", "data-labels", z && !C ? "hidden" : "inherit", q.zIndex || 6), 
            z && (l.attr({
                opacity: +C
            }), C || setTimeout(function() {
                var a = p.dataLabelsGroup;
                a && (p.visible && l.show(!0), a[n.animation ? "animate" : "attr"]({
                    opacity: 1
                }, {
                    duration: A
                }));
            }, v - A)), w.forEach(function(d) {
                u = m(g(q, d.dlOptions || d.options && d.options.dataLabels));
                u.forEach(function(e, f) {
                    var g = e.enabled && (!d.isNull || d.dataLabelOnNull) && b(d, e), k, m, q, w, r = d.dataLabels ? d.dataLabels[f] : d.dataLabel, u = d.connectors ? d.connectors[f] : d.connector, x = !r;
                    g && (k = d.getLabelConfig(), m = t(e[d.formatPrefix + "Format"], e.format), k = H(m) ? h(m, k, c.time) : (e[d.formatPrefix + "Formatter"] || e.formatter).call(k, e), 
                    m = e.style, q = e.rotation, c.styledMode || (m.color = t(e.color, m.color, p.color, "#000000"), 
                    "contrast" === m.color && (d.contrastColor = B.getContrast(d.color || p.color), 
                    m.color = e.inside || 0 > t(e.distance, d.labelDistance) || n.stacking ? d.contrastColor : "#000000"), 
                    n.cursor && (m.cursor = n.cursor)), w = {
                        r: e.borderRadius || 0,
                        rotation: q,
                        padding: e.padding,
                        zIndex: 1
                    }, c.styledMode || (w.fill = e.backgroundColor, w.stroke = e.borderColor, w["stroke-width"] = e.borderWidth), 
                    a.objectEach(w, function(a, b) {
                        void 0 === a && delete w[b];
                    }));
                    !r || g && H(k) ? g && H(k) && (r ? w.text = k : (d.dataLabels = d.dataLabels || [], 
                    r = d.dataLabels[f] = q ? B.text(k, 0, -9999).addClass("highcharts-data-label") : B.label(k, 0, -9999, e.shape, null, null, e.useHTML, null, "data-label"), 
                    f || (d.dataLabel = r), r.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (e.className || "") + (e.useHTML ? " highcharts-tracker" : ""))), 
                    r.options = e, r.attr(w), c.styledMode || r.css(m).shadow(e.shadow), r.added || r.add(l), 
                    e.textPath && !e.useHTML && r.setTextPath(d.getDataLabelPath && d.getDataLabelPath(r) || d.graphic, e.textPath), 
                    p.alignDataLabel(d, r, e, null, x)) : (d.dataLabel = d.dataLabel && d.dataLabel.destroy(), 
                    d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[f]), 
                    f || delete d.dataLabel, u && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[f])));
                });
            });
            a.fireEvent(this, "afterDrawDataLabels");
        };
        v.prototype.alignDataLabel = function(a, d, e, c, g) {
            var b = this.chart, k = this.isCartesian && b.inverted, h = t(a.dlBox && a.dlBox.centerX, a.plotX, -9999), m = t(a.plotY, -9999), l = d.getBBox(), p, n = e.rotation, q = e.align, u = this.visible && (a.series.forceDL || b.isInsidePlot(h, Math.round(m), k) || c && b.isInsidePlot(h, k ? c.x + 1 : c.y + c.height - 1, k)), f = "justify" === t(e.overflow, "justify");
            if (u && (p = b.renderer.fontMetrics(b.styledMode ? void 0 : e.style.fontSize, d).b, 
            c = B({
                x: k ? this.yAxis.len - m : h,
                y: Math.round(k ? this.xAxis.len - h : m),
                width: 0,
                height: 0
            }, c), B(e, {
                width: l.width,
                height: l.height
            }), n ? (f = !1, h = b.renderer.rotCorr(p, n), h = {
                x: c.x + e.x + c.width / 2 + h.x,
                y: c.y + e.y + {
                    top: 0,
                    middle: .5,
                    bottom: 1
                }[e.verticalAlign] * c.height
            }, d[g ? "attr" : "animate"](h).attr({
                align: q
            }), m = (n + 720) % 360, m = 180 < m && 360 > m, "left" === q ? h.y -= m ? l.height : 0 : "center" === q ? (h.x -= l.width / 2, 
            h.y -= l.height / 2) : "right" === q && (h.x -= l.width, h.y -= m ? 0 : l.height), 
            d.placed = !0, d.alignAttr = h) : (d.align(e, null, c), h = d.alignAttr), f && 0 <= c.height ? a.isLabelJustified = this.justifyDataLabel(d, e, h, l, c, g) : t(e.crop, !0) && (u = b.isInsidePlot(h.x, h.y) && b.isInsidePlot(h.x + l.width, h.y + l.height)), 
            e.shape && !n)) d[g ? "attr" : "animate"]({
                anchorX: k ? b.plotWidth - a.plotY : a.plotX,
                anchorY: k ? b.plotHeight - a.plotX : a.plotY
            });
            u || (d.attr({
                y: -9999
            }), d.placed = !1);
        };
        v.prototype.justifyDataLabel = function(a, d, e, c, g, h) {
            var b = this.chart, k = d.align, m = d.verticalAlign, l, p, n = a.box ? 0 : a.padding || 0;
            l = e.x + n;
            0 > l && ("right" === k ? d.align = "left" : d.x = -l, p = !0);
            l = e.x + c.width - n;
            l > b.plotWidth && ("left" === k ? d.align = "right" : d.x = b.plotWidth - l, p = !0);
            l = e.y + n;
            0 > l && ("bottom" === m ? d.verticalAlign = "top" : d.y = -l, p = !0);
            l = e.y + c.height - n;
            l > b.plotHeight && ("top" === m ? d.verticalAlign = "bottom" : d.y = b.plotHeight - l, 
            p = !0);
            p && (a.placed = !h, a.align(d, null, g));
            return p;
        };
        n.pie && (n.pie.prototype.dataLabelPositioners = {
            radialDistributionY: function(a) {
                return a.top + a.distributeBox.pos;
            },
            radialDistributionX: function(a, d, e, c) {
                return a.getX(e < d.top + 2 || e > d.bottom - 2 ? c : e, d.half, d);
            },
            justify: function(a, d, e) {
                return e[0] + (a.half ? -1 : 1) * (d + a.labelDistance);
            },
            alignToPlotEdges: function(a, d, e, c) {
                a = a.getBBox().width;
                return d ? a + c : e - a - c;
            },
            alignToConnectors: function(a, d, e, c) {
                var b = 0, g;
                a.forEach(function(a) {
                    g = a.dataLabel.getBBox().width;
                    g > b && (b = g);
                });
                return d ? b + c : e - b - c;
            }
        }, n.pie.prototype.drawDataLabels = function() {
            var b = this, d = b.data, g, c = b.chart, h = b.options.dataLabels, m = h.connectorPadding, n, q = c.plotWidth, u = c.plotHeight, l = c.plotLeft, D = Math.round(c.chartWidth / 3), A, z = b.center, B = z[2] / 2, f = z[1], r, G, N, L, M = [ [], [] ], J, y, S, U, P = [ 0, 0, 0, 0 ], T = b.dataLabelPositioners, O;
            b.visible && (h.enabled || b._hasPointLabels) && (d.forEach(function(a) {
                a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
                    width: "auto"
                }).css({
                    width: "auto",
                    textOverflow: "clip"
                }), a.dataLabel.shortened = !1);
            }), v.prototype.drawDataLabels.apply(b), d.forEach(function(a) {
                a.dataLabel && (a.visible ? (M[a.half].push(a), a.dataLabel._pos = null, !H(h.style.width) && !H(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > D && (a.dataLabel.css({
                    width: .7 * D
                }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
            }), M.forEach(function(d, e) {
                var k, p, n = d.length, w = [], v;
                if (n) for (b.sortByAngle(d, e - .5), 0 < b.maxLabelDistance && (k = Math.max(0, f - B - b.maxLabelDistance), 
                p = Math.min(f + B + b.maxLabelDistance, c.plotHeight), d.forEach(function(a) {
                    0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, f - B - a.labelDistance), 
                    a.bottom = Math.min(f + B + a.labelDistance, c.plotHeight), v = a.dataLabel.getBBox().height || 21, 
                    a.distributeBox = {
                        target: a.labelPosition.natural.y - a.top + v / 2,
                        size: v,
                        rank: a.y
                    }, w.push(a.distributeBox));
                }), k = p + v - k, a.distribute(w, k, k / 5)), U = 0; U < n; U++) {
                    g = d[U];
                    N = g.labelPosition;
                    r = g.dataLabel;
                    S = !1 === g.visible ? "hidden" : "inherit";
                    y = k = N.natural.y;
                    w && H(g.distributeBox) && (void 0 === g.distributeBox.pos ? S = "hidden" : (L = g.distributeBox.size, 
                    y = T.radialDistributionY(g)));
                    delete g.positionIndex;
                    if (h.justify) J = T.justify(g, B, z); else switch (h.alignTo) {
                      case "connectors":
                        J = T.alignToConnectors(d, e, q, l);
                        break;

                      case "plotEdges":
                        J = T.alignToPlotEdges(r, e, q, l);
                        break;

                      default:
                        J = T.radialDistributionX(b, g, y, k);
                    }
                    r._attr = {
                        visibility: S,
                        align: N.alignment
                    };
                    r._pos = {
                        x: J + h.x + ({
                            left: m,
                            right: -m
                        }[N.alignment] || 0),
                        y: y + h.y - 10
                    };
                    N.final.x = J;
                    N.final.y = y;
                    t(h.crop, !0) && (G = r.getBBox().width, k = null, J - G < m && 1 === e ? (k = Math.round(G - J + m), 
                    P[3] = Math.max(k, P[3])) : J + G > q - m && 0 === e && (k = Math.round(J + G - q + m), 
                    P[1] = Math.max(k, P[1])), 0 > y - L / 2 ? P[0] = Math.max(Math.round(-y + L / 2), P[0]) : y + L / 2 > u && (P[2] = Math.max(Math.round(y + L / 2 - u), P[2])), 
                    r.sideOverflow = k);
                }
            }), 0 === E(P) || this.verifyDataLabelOverflow(P)) && (this.placeDataLabels(), this.points.forEach(function(a) {
                O = e(h, a.options.dataLabels);
                if (n = t(O.connectorWidth, 1)) {
                    var d;
                    A = a.connector;
                    if ((r = a.dataLabel) && r._pos && a.visible && 0 < a.labelDistance) {
                        S = r._attr.visibility;
                        if (d = !A) a.connector = A = c.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(b.dataLabelsGroup), 
                        c.styledMode || A.attr({
                            "stroke-width": n,
                            stroke: O.connectorColor || a.color || "#666666"
                        });
                        A[d ? "attr" : "animate"]({
                            d: a.getConnectorPath()
                        });
                        A.attr("visibility", S);
                    } else A && (a.connector = A.destroy());
                }
            }));
        }, n.pie.prototype.placeDataLabels = function() {
            this.points.forEach(function(a) {
                var b = a.dataLabel, d;
                b && a.visible && ((d = b._pos) ? (b.sideOverflow && (b._attr.width = Math.max(b.getBBox().width - b.sideOverflow, 0), 
                b.css({
                    width: b._attr.width + "px",
                    textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                }), b.shortened = !0), b.attr(b._attr), b[b.moved ? "animate" : "attr"](d), b.moved = !0) : b && b.attr({
                    y: -9999
                }));
                delete a.distributeBox;
            }, this);
        }, n.pie.prototype.alignDataLabel = q, n.pie.prototype.verifyDataLabelOverflow = function(a) {
            var b = this.center, d = this.options, c = d.center, e = d.minSize || 80, g, h = null !== d.size;
            h || (null !== c[0] ? g = Math.max(b[2] - Math.max(a[1], a[3]), e) : (g = Math.max(b[2] - a[1] - a[3], e), 
            b[0] += (a[3] - a[1]) / 2), null !== c[1] ? g = Math.max(Math.min(g, b[2] - Math.max(a[0], a[2])), e) : (g = Math.max(Math.min(g, b[2] - a[0] - a[2]), e), 
            b[1] += (a[0] - a[2]) / 2), g < b[2] ? (b[2] = g, b[3] = Math.min(u(d.innerSize || 0, g), g), 
            this.translate(b), this.drawDataLabels && this.drawDataLabels()) : h = !0);
            return h;
        });
        n.column && (n.column.prototype.alignDataLabel = function(a, d, g, c, h) {
            var b = this.chart.inverted, k = a.series, m = a.dlBox || a.shapeArgs, n = t(a.below, a.plotY > t(this.translatedThreshold, k.yAxis.len)), l = t(g.inside, !!this.options.stacking);
            m && (c = e(m), 0 > c.y && (c.height += c.y, c.y = 0), m = c.y + c.height - k.yAxis.len, 
            0 < m && (c.height -= m), b && (c = {
                x: k.yAxis.len - c.y - c.height,
                y: k.xAxis.len - c.x - c.width,
                width: c.height,
                height: c.width
            }), l || (b ? (c.x += n ? 0 : c.width, c.width = 0) : (c.y += n ? c.height : 0, 
            c.height = 0)));
            g.align = t(g.align, !b || l ? "center" : n ? "right" : "left");
            g.verticalAlign = t(g.verticalAlign, b || l ? "middle" : n ? "top" : "bottom");
            v.prototype.alignDataLabel.call(this, a, d, g, c, h);
            a.isLabelJustified && a.contrastColor && d.css({
                color: a.contrastColor
            });
        });
    });
    J(G, "modules/overlapping-datalabels.src.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.Chart, G = a.isArray, B = a.objectEach, h = a.pick, e = a.addEvent, q = a.fireEvent;
        e(E, "render", function() {
            var a = [];
            (this.labelCollectors || []).forEach(function(e) {
                a = a.concat(e());
            });
            (this.yAxis || []).forEach(function(e) {
                e.options.stackLabels && !e.options.stackLabels.allowOverlap && B(e.stacks, function(e) {
                    B(e, function(e) {
                        a.push(e.label);
                    });
                });
            });
            (this.series || []).forEach(function(e) {
                var q = e.options.dataLabels;
                e.visible && (!1 !== q.enabled || e._hasPointLabels) && e.points.forEach(function(e) {
                    e.visible && (G(e.dataLabels) ? e.dataLabels : e.dataLabel ? [ e.dataLabel ] : []).forEach(function(g) {
                        var d = g.options;
                        g.labelrank = h(d.labelrank, e.labelrank, e.shapeArgs && e.shapeArgs.height);
                        d.allowOverlap || a.push(g);
                    });
                });
            });
            this.hideOverlappingLabels(a);
        });
        E.prototype.hideOverlappingLabels = function(a) {
            var e = this, h = a.length, n = e.renderer, g, d, m, b, k, p, c = function(a, b, c, d, e, g, k, h) {
                return !(e > a + c || e + k < a || g > b + d || g + h < b);
            };
            m = function(a) {
                var b, c, d, e = a.box ? 0 : a.padding || 0;
                d = 0;
                if (a && (!a.alignAttr || a.placed)) return b = a.alignAttr || {
                    x: a.attr("x"),
                    y: a.attr("y")
                }, c = a.parentGroup, a.width || (d = a.getBBox(), a.width = d.width, a.height = d.height, 
                d = n.fontMetrics(null, a.element).h), {
                    x: b.x + (c.translateX || 0) + e,
                    y: b.y + (c.translateY || 0) + e - d,
                    width: a.width - 2 * e,
                    height: a.height - 2 * e
                };
            };
            for (d = 0; d < h; d++) if (g = a[d]) g.oldOpacity = g.opacity, g.newOpacity = 1, 
            g.absoluteBox = m(g);
            a.sort(function(a, b) {
                return (b.labelrank || 0) - (a.labelrank || 0);
            });
            for (d = 0; d < h; d++) for (p = (m = a[d]) && m.absoluteBox, g = d + 1; g < h; ++g) if (k = (b = a[g]) && b.absoluteBox, 
            p && k && m !== b && 0 !== m.newOpacity && 0 !== b.newOpacity && (k = c(p.x, p.y, p.width, p.height, k.x, k.y, k.width, k.height))) (m.labelrank < b.labelrank ? m : b).newOpacity = 0;
            a.forEach(function(a) {
                var b, c;
                a && (c = a.newOpacity, a.oldOpacity !== c && (a.alignAttr && a.placed ? (c ? a.show(!0) : b = function() {
                    a.hide();
                }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b), 
                q(e, "afterHideOverlappingLabels")) : a.attr({
                    opacity: c
                })), a.isOld = !0);
            });
        };
    });
    J(G, "parts/Interaction.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.addEvent, G = a.Chart, B = a.createElement, h = a.css, e = a.defaultOptions, q = a.defaultPlotOptions, t = a.extend, u = a.fireEvent, v = a.hasTouch, n = a.isObject, g = a.isArray, d = a.Legend, m = a.merge, b = a.pick, k = a.Point, p = a.Series, c = a.seriesTypes, x = a.svg, J;
        J = a.TrackerMixin = {
            drawTrackerPoint: function() {
                var a = this, b = a.chart, c = b.pointer, d = function(a) {
                    var b = c.getPointFromEvent(a);
                    void 0 !== b && (c.isDirectTouch = !0, b.onMouseOver(a));
                }, e;
                a.points.forEach(function(a) {
                    e = g(a.dataLabels) ? a.dataLabels : a.dataLabel ? [ a.dataLabel ] : [];
                    a.graphic && (a.graphic.element.point = a);
                    e.forEach(function(b) {
                        b.div ? b.div.point = a : b.element.point = a;
                    });
                });
                a._hasTracking || (a.trackerGroups.forEach(function(e) {
                    if (a[e]) {
                        a[e].addClass("highcharts-tracker").on("mouseover", d).on("mouseout", function(a) {
                            c.onTrackerMouseOut(a);
                        });
                        if (v) a[e].on("touchstart", d);
                        !b.styledMode && a.options.cursor && a[e].css(h).css({
                            cursor: a.options.cursor
                        });
                    }
                }), a._hasTracking = !0);
                u(this, "afterDrawTracker");
            },
            drawTrackerGraph: function() {
                var a = this, b = a.options, c = b.trackByArea, d = [].concat(c ? a.areaPath : a.graphPath), e = d.length, g = a.chart, k = g.pointer, h = g.renderer, f = g.options.tooltip.snap, m = a.tracker, n, p = function() {
                    if (g.hoverSeries !== a) a.onMouseOver();
                }, q = "rgba(192,192,192," + (x ? 1e-4 : .002) + ")";
                if (e && !c) for (n = e + 1; n--; ) "M" === d[n] && d.splice(n + 1, 0, d[n + 1] - f, d[n + 2], "L"), 
                (n && "M" === d[n] || n === e) && d.splice(n, 0, "L", d[n - 2] + f, d[n - 1]);
                m ? m.attr({
                    d: d
                }) : a.graph && (a.tracker = h.path(d).attr({
                    visibility: a.visible ? "visible" : "hidden",
                    zIndex: 2
                }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), 
                g.styledMode || a.tracker.attr({
                    "stroke-linejoin": "round",
                    stroke: q,
                    fill: c ? q : "none",
                    "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * f)
                }), [ a.tracker, a.markerGroup ].forEach(function(a) {
                    a.addClass("highcharts-tracker").on("mouseover", p).on("mouseout", function(a) {
                        k.onTrackerMouseOut(a);
                    });
                    b.cursor && !g.styledMode && a.css({
                        cursor: b.cursor
                    });
                    if (v) a.on("touchstart", p);
                }));
                u(this, "afterDrawTracker");
            }
        };
        c.column && (c.column.prototype.drawTracker = J.drawTrackerPoint);
        c.pie && (c.pie.prototype.drawTracker = J.drawTrackerPoint);
        c.scatter && (c.scatter.prototype.drawTracker = J.drawTrackerPoint);
        t(d.prototype, {
            setItemEvents: function(a, b, c) {
                var d = this, e = d.chart.renderer.boxWrapper, g = a instanceof k, h = "highcharts-legend-" + (g ? "point" : "series") + "-active", n = d.chart.styledMode;
                (c ? b : a.legendGroup).on("mouseover", function() {
                    d.allItems.forEach(function(b) {
                        a !== b && b.setState("inactive", !g);
                    });
                    a.setState("hover");
                    a.visible && e.addClass(h);
                    n || b.css(d.options.itemHoverStyle);
                }).on("mouseout", function() {
                    d.styledMode || b.css(m(a.visible ? d.itemStyle : d.itemHiddenStyle));
                    d.allItems.forEach(function(b) {
                        a !== b && b.setState("", !g);
                    });
                    e.removeClass(h);
                    a.setState();
                }).on("click", function(b) {
                    var c = function() {
                        a.setVisible && a.setVisible();
                    };
                    e.removeClass(h);
                    b = {
                        browserEvent: b
                    };
                    a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : u(a, "legendItemClick", b, c);
                });
            },
            createCheckboxForItem: function(a) {
                a.checkbox = B("input", {
                    type: "checkbox",
                    className: "highcharts-legend-checkbox",
                    checked: a.selected,
                    defaultChecked: a.selected
                }, this.options.itemCheckboxStyle, this.chart.container);
                E(a.checkbox, "click", function(b) {
                    u(a.series || a, "checkboxClick", {
                        checked: b.target.checked,
                        item: a
                    }, function() {
                        a.select();
                    });
                });
            }
        });
        t(G.prototype, {
            showResetZoom: function() {
                function a() {
                    b.zoomOut();
                }
                var b = this, c = e.lang, d = b.options.chart.resetZoomButton, g = d.theme, k = g.states, h = "chart" === d.relativeTo || "spaceBox" === d.relativeTo ? null : "plotBox";
                u(this, "beforeShowResetZoom", null, function() {
                    b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, g, k && k.hover).attr({
                        align: d.position.align,
                        title: c.resetZoomTitle
                    }).addClass("highcharts-reset-zoom").add().align(d.position, !1, h);
                });
                u(this, "afterShowResetZoom");
            },
            zoomOut: function() {
                u(this, "selection", {
                    resetSelection: !0
                }, this.zoom);
            },
            zoom: function(c) {
                var d = this, e, g = d.pointer, k = !1, h = d.inverted ? g.mouseDownX : g.mouseDownY, m;
                !c || c.resetSelection ? (d.axes.forEach(function(a) {
                    e = a.zoom();
                }), g.initiated = !1) : c.xAxis.concat(c.yAxis).forEach(function(b) {
                    var c = b.axis, l = d.inverted ? c.left : c.top, m = d.inverted ? l + c.width : l + c.height, n = c.isXAxis, p = !1;
                    if (!n && h >= l && h <= m || n || !a.defined(h)) p = !0;
                    g[n ? "zoomX" : "zoomY"] && p && (e = c.zoom(b.min, b.max), c.displayBtn && (k = !0));
                });
                m = d.resetZoomButton;
                k && !m ? d.showResetZoom() : !k && n(m) && (d.resetZoomButton = m.destroy());
                e && d.redraw(b(d.options.chart.animation, c && c.animation, 100 > d.pointCount));
            },
            pan: function(a, b) {
                var c = this, d = c.hoverPoints, e;
                u(this, "pan", {
                    originalEvent: a
                }, function() {
                    d && d.forEach(function(a) {
                        a.setState();
                    });
                    ("xy" === b ? [ 1, 0 ] : [ 1 ]).forEach(function(b) {
                        b = c[b ? "xAxis" : "yAxis"][0];
                        var d = b.horiz, g = a[d ? "chartX" : "chartY"], d = d ? "mouseDownX" : "mouseDownY", f = c[d], l = (b.pointRange || 0) / 2, k = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1, h = b.getExtremes(), m = b.toValue(f - g, !0) + l * k, k = b.toValue(f + b.len - g, !0) - l * k, n = k < m, f = n ? k : m, m = n ? m : k, k = Math.min(h.dataMin, l ? h.min : b.toValue(b.toPixels(h.min) - b.minPixelPadding)), l = Math.max(h.dataMax, l ? h.max : b.toValue(b.toPixels(h.max) + b.minPixelPadding)), n = k - f;
                        0 < n && (m += n, f = k);
                        n = m - l;
                        0 < n && (m = l, f -= n);
                        b.series.length && f !== h.min && m !== h.max && (b.setExtremes(f, m, !1, !1, {
                            trigger: "pan"
                        }), e = !0);
                        c[d] = g;
                    });
                    e && c.redraw(!1);
                    h(c.container, {
                        cursor: "move"
                    });
                });
            }
        });
        t(k.prototype, {
            select: function(a, c) {
                var d = this, e = d.series, g = e.chart;
                a = b(a, !d.selected);
                d.firePointEvent(a ? "select" : "unselect", {
                    accumulate: c
                }, function() {
                    d.selected = d.options.selected = a;
                    e.options.data[e.data.indexOf(d)] = d.options;
                    d.setState(a && "select");
                    c || g.getSelectedPoints().forEach(function(a) {
                        var b = a.series;
                        a.selected && a !== d && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options, 
                        a.setState(g.hoverPoints && b.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
                    });
                });
            },
            onMouseOver: function(a) {
                var b = this.series.chart, c = b.pointer;
                a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);
                c.runPointActions(a, this);
            },
            onMouseOut: function() {
                var a = this.series.chart;
                this.firePointEvent("mouseOut");
                this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function(a) {
                    a.setState();
                });
                a.hoverPoints = a.hoverPoint = null;
            },
            importEvents: function() {
                if (!this.hasImportedEvents) {
                    var b = this, c = m(b.series.options.point, b.options).events;
                    b.events = c;
                    a.objectEach(c, function(c, d) {
                        a.isFunction(c) && E(b, d, c);
                    });
                    this.hasImportedEvents = !0;
                }
            },
            setState: function(a, c) {
                var d = Math.floor(this.plotX), e = this.plotY, g = this.series, k = this.state, h = g.options.states[a || "normal"] || {}, m = q[g.type].marker && g.options.marker, f = m && !1 === m.enabled, n = m && m.states && m.states[a || "normal"] || {}, p = !1 === n.enabled, w = g.stateMarkerGraphic, v = this.marker || {}, x = g.chart, B = g.halo, y, E, F, G = m && g.markerAttribs;
                a = a || "";
                if (!(a === this.state && !c || this.selected && "select" !== a || !1 === h.enabled || a && (p || f && !1 === n.enabled) || a && v.states && v.states[a] && !1 === v.states[a].enabled)) {
                    this.state = a;
                    G && (y = g.markerAttribs(this, a));
                    if (this.graphic) k && this.graphic.removeClass("highcharts-point-" + k), a && this.graphic.addClass("highcharts-point-" + a), 
                    x.styledMode || (E = g.pointAttribs(this, a), F = b(x.options.chart.animation, h.animation), 
                    g.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function(a) {
                        a && a.animate({
                            opacity: E.opacity
                        }, F);
                    }), this.connector && this.connector.animate({
                        opacity: E.opacity
                    }, F)), this.graphic.animate(E, F)), y && this.graphic.animate(y, b(x.options.chart.animation, n.animation, m.animation)), 
                    w && w.hide(); else {
                        if (a && n) {
                            k = v.symbol || g.symbol;
                            w && w.currentSymbol !== k && (w = w.destroy());
                            if (w) w[c ? "animate" : "attr"]({
                                x: y.x,
                                y: y.y
                            }); else k && (g.stateMarkerGraphic = w = x.renderer.symbol(k, y.x, y.y, y.width, y.height).add(g.markerGroup), 
                            w.currentSymbol = k);
                            !x.styledMode && w && w.attr(g.pointAttribs(this, a));
                        }
                        w && (w[a && x.isInsidePlot(d, e, x.inverted) ? "show" : "hide"](), w.element.point = this);
                    }
                    (a = h.halo) && a.size ? (B || (g.halo = B = x.renderer.path().add((this.graphic || w).parentGroup)), 
                    B.show()[c ? "animate" : "attr"]({
                        d: this.haloPath(a.size)
                    }), B.attr({
                        class: "highcharts-halo highcharts-color-" + b(this.colorIndex, g.colorIndex) + (this.className ? " " + this.className : ""),
                        zIndex: -1
                    }), B.point = this, x.styledMode || B.attr(t({
                        fill: this.color || g.color,
                        "fill-opacity": a.opacity
                    }, a.attributes))) : B && B.point && B.point.haloPath && B.animate({
                        d: B.point.haloPath(0)
                    }, null, B.hide);
                    u(this, "afterSetState");
                }
            },
            haloPath: function(a) {
                return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
            }
        });
        t(p.prototype, {
            onMouseOver: function() {
                var a = this.chart, b = a.hoverSeries;
                if (b && b !== this) b.onMouseOut();
                this.options.events.mouseOver && u(this, "mouseOver");
                this.setState("hover");
                a.hoverSeries = this;
            },
            onMouseOut: function() {
                var a = this.options, b = this.chart, c = b.tooltip, d = b.hoverPoint;
                b.hoverSeries = null;
                if (d) d.onMouseOut();
                this && a.events.mouseOut && u(this, "mouseOut");
                !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
                b.series.forEach(function(a) {
                    a.setState("", !0);
                });
            },
            setState: function(a, c) {
                var d = this, e = d.options, g = d.graph, k = e.inactiveOtherPoints, h = e.states, m = e.lineWidth, f = e.opacity, n = b(h[a || "normal"] && h[a || "normal"].animation, d.chart.options.chart.animation), e = 0;
                a = a || "";
                if (d.state !== a && ([ d.group, d.markerGroup, d.dataLabelsGroup ].forEach(function(b) {
                    b && (d.state && b.removeClass("highcharts-series-" + d.state), a && b.addClass("highcharts-series-" + a));
                }), d.state = a, !d.chart.styledMode)) {
                    if (h[a] && !1 === h[a].enabled) return;
                    a && (m = h[a].lineWidth || m + (h[a].lineWidthPlus || 0), f = b(h[a].opacity, f));
                    if (g && !g.dashstyle) for (h = {
                        "stroke-width": m
                    }, g.animate(h, n); d["zone-graph-" + e]; ) d["zone-graph-" + e].attr(h), e += 1;
                    k || [ d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries ].forEach(function(a) {
                        a && a.animate({
                            opacity: f
                        }, n);
                    });
                }
                c && k && d.points && d.points.forEach(function(b) {
                    b.setState && b.setState(a);
                });
            },
            setVisible: function(a, b) {
                var c = this, d = c.chart, e = c.legendItem, g, k = d.options.chart.ignoreHiddenSeries, h = c.visible;
                g = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !h : a) ? "show" : "hide";
                [ "group", "dataLabelsGroup", "markerGroup", "tracker", "tt" ].forEach(function(a) {
                    if (c[a]) c[a][g]();
                });
                if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
                e && d.legend.colorizeItem(c, a);
                c.isDirty = !0;
                c.options.stacking && d.series.forEach(function(a) {
                    a.options.stacking && a.visible && (a.isDirty = !0);
                });
                c.linkedSeries.forEach(function(b) {
                    b.setVisible(a, !1);
                });
                k && (d.isDirtyBox = !0);
                u(c, g);
                !1 !== b && d.redraw();
            },
            show: function() {
                this.setVisible(!0);
            },
            hide: function() {
                this.setVisible(!1);
            },
            select: function(a) {
                this.selected = a = this.options.selected = void 0 === a ? !this.selected : a;
                this.checkbox && (this.checkbox.checked = a);
                u(this, a ? "select" : "unselect");
            },
            drawTracker: J.drawTrackerGraph
        });
    });
    J(G, "parts/Responsive.js", [ G["parts/Globals.js"] ], function(a) {
        var E = a.Chart, G = a.isArray, B = a.isObject, h = a.pick, e = a.splat;
        E.prototype.setResponsive = function(e, h) {
            var q = this.options.responsive, t = [], n = this.currentResponsive;
            !h && q && q.rules && q.rules.forEach(function(g) {
                void 0 === g._id && (g._id = a.uniqueKey());
                this.matchResponsiveRule(g, t, e);
            }, this);
            h = a.merge.apply(0, t.map(function(e) {
                return a.find(q.rules, function(a) {
                    return a._id === e;
                }).chartOptions;
            }));
            h.isResponsiveOptions = !0;
            t = t.toString() || void 0;
            t !== (n && n.ruleIds) && (n && this.update(n.undoOptions, e, !0), t ? (n = this.currentOptions(h), 
            n.isResponsiveOptions = !0, this.currentResponsive = {
                ruleIds: t,
                mergedOptions: h,
                undoOptions: n
            }, this.update(h, e, !0)) : this.currentResponsive = void 0);
        };
        E.prototype.matchResponsiveRule = function(a, e) {
            var q = a.condition;
            (q.callback || function() {
                return this.chartWidth <= h(q.maxWidth, Number.MAX_VALUE) && this.chartHeight <= h(q.maxHeight, Number.MAX_VALUE) && this.chartWidth >= h(q.minWidth, 0) && this.chartHeight >= h(q.minHeight, 0);
            }).call(this) && e.push(a._id);
        };
        E.prototype.currentOptions = function(q) {
            function t(n, g, d, m) {
                var b;
                a.objectEach(n, function(a, n) {
                    if (!m && -1 < u.collectionsWithUpdate.indexOf(n)) for (a = e(a), d[n] = [], b = 0; b < a.length; b++) g[n][b] && (d[n][b] = {}, 
                    t(a[b], g[n][b], d[n][b], m + 1)); else B(a) ? (d[n] = G(a) ? [] : {}, t(a, g[n] || {}, d[n], m + 1)) : d[n] = h(g[n], null);
                });
            }
            var u = this, v = {};
            t(q, this.options, v, 0);
            return v;
        };
    });
    J(G, "masters/highcharts.src.js", [ G["parts/Globals.js"] ], function(a) {
        return a;
    });
    G["masters/highcharts.src.js"]._modules = G;
    return G["masters/highcharts.src.js"];
});

(function(f) {
    "object" === typeof module && module.exports ? (f["default"] = f, module.exports = f) : "function" === typeof define && define.amd ? define("highcharts/modules/exporting", [ "highcharts" ], function(h) {
        f(h);
        f.Highcharts = h;
        return f;
    }) : f("undefined" !== typeof Highcharts ? Highcharts : void 0);
})(function(f) {
    function h(c, C, f, p) {
        c.hasOwnProperty(C) || (c[C] = p.apply(null, f));
    }
    f = f ? f._modules : {};
    h(f, "modules/full-screen.src.js", [ f["parts/Globals.js"] ], function(c) {
        c.FullScreen = function(c) {
            this.init(c.parentNode);
        };
        c.FullScreen.prototype = {
            init: function(c) {
                c.requestFullscreen ? c.requestFullscreen() : c.mozRequestFullScreen ? c.mozRequestFullScreen() : c.webkitRequestFullscreen ? c.webkitRequestFullscreen() : c.msRequestFullscreen && c.msRequestFullscreen();
            }
        };
    });
    h(f, "mixins/navigation.js", [], function() {
        return {
            initUpdate: function(c) {
                c.navigation || (c.navigation = {
                    updates: [],
                    update: function(c, f) {
                        this.updates.forEach(function(p) {
                            p.update.call(p.context, c, f);
                        });
                    }
                });
            },
            addUpdate: function(c, f) {
                f.navigation || this.initUpdate(f);
                f.navigation.updates.push({
                    update: c,
                    context: f
                });
            }
        };
    });
    h(f, "modules/exporting.src.js", [ f["parts/Globals.js"], f["mixins/navigation.js"] ], function(c, f) {
        var h = c.defaultOptions, p = c.doc, A = c.Chart, r = c.addEvent, C = c.removeEvent, D = c.fireEvent, w = c.createElement, E = c.discardElement, t = c.css, n = c.merge, q = c.pick, F = c.objectEach, y = c.extend, J = c.isTouchDevice, z = c.win, H = z.navigator.userAgent, G = c.SVGRenderer, I = c.Renderer.prototype.symbols, K = /Edge\/|Trident\/|MSIE /.test(H), L = /firefox/i.test(H);
        y(h.lang, {
            viewFullscreen: "View in full screen",
            printChart: "Print chart",
            downloadPNG: "Download PNG image",
            downloadJPEG: "Download JPEG image",
            downloadPDF: "Download PDF document",
            downloadSVG: "Download SVG vector image",
            contextButtonTitle: "Chart context menu"
        });
        h.navigation || (h.navigation = {});
        n(!0, h.navigation, {
            buttonOptions: {
                theme: {},
                symbolSize: 14,
                symbolX: 12.5,
                symbolY: 10.5,
                align: "right",
                buttonSpacing: 3,
                height: 22,
                verticalAlign: "top",
                width: 24
            }
        });
        n(!0, h.navigation, {
            menuStyle: {
                border: "1px solid #999999",
                background: "#ffffff",
                padding: "5px 0"
            },
            menuItemStyle: {
                padding: "0.5em 1em",
                color: "#333333",
                background: "none",
                fontSize: J ? "14px" : "11px",
                transition: "background 250ms, color 250ms"
            },
            menuItemHoverStyle: {
                background: "#335cad",
                color: "#ffffff"
            },
            buttonOptions: {
                symbolFill: "#666666",
                symbolStroke: "#666666",
                symbolStrokeWidth: 3,
                theme: {
                    padding: 5
                }
            }
        });
        h.exporting = {
            type: "image/png",
            url: "https://export.highcharts.com/",
            printMaxWidth: 780,
            scale: 2,
            buttons: {
                contextButton: {
                    className: "highcharts-contextbutton",
                    menuClassName: "highcharts-contextmenu",
                    symbol: "menu",
                    titleKey: "contextButtonTitle",
                    menuItems: "viewFullscreen printChart separator downloadPNG downloadJPEG downloadPDF downloadSVG".split(" ")
                }
            },
            menuItemDefinitions: {
                viewFullscreen: {
                    textKey: "viewFullscreen",
                    onclick: function() {
                        this.fullscreen = new c.FullScreen(this.container);
                    }
                },
                printChart: {
                    textKey: "printChart",
                    onclick: function() {
                        this.print();
                    }
                },
                separator: {
                    separator: !0
                },
                downloadPNG: {
                    textKey: "downloadPNG",
                    onclick: function() {
                        this.exportChart();
                    }
                },
                downloadJPEG: {
                    textKey: "downloadJPEG",
                    onclick: function() {
                        this.exportChart({
                            type: "image/jpeg"
                        });
                    }
                },
                downloadPDF: {
                    textKey: "downloadPDF",
                    onclick: function() {
                        this.exportChart({
                            type: "application/pdf"
                        });
                    }
                },
                downloadSVG: {
                    textKey: "downloadSVG",
                    onclick: function() {
                        this.exportChart({
                            type: "image/svg+xml"
                        });
                    }
                }
            }
        };
        c.post = function(b, a, c) {
            var d = w("form", n({
                method: "post",
                action: b,
                enctype: "multipart/form-data"
            }, c), {
                display: "none"
            }, p.body);
            F(a, function(a, b) {
                w("input", {
                    type: "hidden",
                    name: b,
                    value: a
                }, null, d);
            });
            d.submit();
            E(d);
        };
        y(A.prototype, {
            sanitizeSVG: function(b, a) {
                var c = b.indexOf("</svg>") + 6, d = b.substr(c);
                b = b.substr(0, c);
                a && a.exporting && a.exporting.allowHTML && d && (d = '<foreignObject x="0" y="0" width="' + a.chart.width + '" height="' + a.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + d + "</body></foreignObject>", 
                b = b.replace("</svg>", d + "</svg>"));
                b = b.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(\S+)("|&quot;)\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+\:)href=/g, " xlink:href=").replace(/\n/, " ").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, "").replace(/&shy;/g, "");
                this.ieSanitizeSVG && (b = this.ieSanitizeSVG(b));
                return b;
            },
            getChartHTML: function() {
                this.styledMode && this.inlineStyles();
                return this.container.innerHTML;
            },
            getSVG: function(b) {
                var a, u, d, f, m, k = n(this.options, b);
                k.plotOptions = n(this.userOptions.plotOptions, b && b.plotOptions);
                u = w("div", null, {
                    position: "absolute",
                    top: "-9999em",
                    width: this.chartWidth + "px",
                    height: this.chartHeight + "px"
                }, p.body);
                d = this.renderTo.style.width;
                m = this.renderTo.style.height;
                d = k.exporting.sourceWidth || k.chart.width || /px$/.test(d) && parseInt(d, 10) || (k.isGantt ? 800 : 600);
                m = k.exporting.sourceHeight || k.chart.height || /px$/.test(m) && parseInt(m, 10) || 400;
                y(k.chart, {
                    animation: !1,
                    renderTo: u,
                    forExport: !0,
                    renderer: "SVGRenderer",
                    width: d,
                    height: m
                });
                k.exporting.enabled = !1;
                delete k.data;
                k.series = [];
                this.series.forEach(function(a) {
                    f = n(a.userOptions, {
                        animation: !1,
                        enableMouseTracking: !1,
                        showCheckbox: !1,
                        visible: a.visible
                    });
                    f.isInternal || k.series.push(f);
                });
                this.axes.forEach(function(a) {
                    a.userOptions.internalKey || (a.userOptions.internalKey = c.uniqueKey());
                });
                a = new c.Chart(k, this.callback);
                b && [ "xAxis", "yAxis", "series" ].forEach(function(d) {
                    var c = {};
                    b[d] && (c[d] = b[d], a.update(c));
                });
                this.axes.forEach(function(b) {
                    var d = c.find(a.axes, function(a) {
                        return a.options.internalKey === b.userOptions.internalKey;
                    }), e = b.getExtremes(), u = e.userMin, e = e.userMax;
                    d && (void 0 !== u && u !== d.min || void 0 !== e && e !== d.max) && d.setExtremes(u, e, !0, !1);
                });
                d = a.getChartHTML();
                D(this, "getSVG", {
                    chartCopy: a
                });
                d = this.sanitizeSVG(d, k);
                k = null;
                a.destroy();
                E(u);
                return d;
            },
            getSVGForExport: function(b, a) {
                var c = this.options.exporting;
                return this.getSVG(n({
                    chart: {
                        borderRadius: 0
                    }
                }, c.chartOptions, a, {
                    exporting: {
                        sourceWidth: b && b.sourceWidth || c.sourceWidth,
                        sourceHeight: b && b.sourceHeight || c.sourceHeight
                    }
                }));
            },
            getFilename: function() {
                var b = this.userOptions.title && this.userOptions.title.text, a = this.options.exporting.filename;
                if (a) return a;
                "string" === typeof b && (a = b.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z0-9\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, ""));
                if (!a || 5 > a.length) a = "chart";
                return a;
            },
            exportChart: function(b, a) {
                a = this.getSVGForExport(b, a);
                b = n(this.options.exporting, b);
                c.post(b.url, {
                    filename: b.filename || this.getFilename(),
                    type: b.type,
                    width: b.width || 0,
                    scale: b.scale,
                    svg: a
                }, b.formAttributes);
            },
            print: function() {
                function b(b) {
                    (a.fixedDiv ? [ a.fixedDiv, a.scrollingContainer ] : [ a.container ]).forEach(function(a) {
                        b.appendChild(a);
                    });
                }
                var a = this, c = [], d = p.body, f = d.childNodes, m = a.options.exporting.printMaxWidth, k, e;
                if (!a.isPrinting) {
                    a.isPrinting = !0;
                    a.pointer.reset(null, 0);
                    D(a, "beforePrint");
                    if (e = m && a.chartWidth > m) k = [ a.options.chart.width, void 0, !1 ], a.setSize(m, void 0, !1);
                    [].forEach.call(f, function(a, b) {
                        1 === a.nodeType && (c[b] = a.style.display, a.style.display = "none");
                    });
                    b(d);
                    setTimeout(function() {
                        z.focus();
                        z.print();
                        setTimeout(function() {
                            b(a.renderTo);
                            [].forEach.call(f, function(a, b) {
                                1 === a.nodeType && (a.style.display = c[b]);
                            });
                            a.isPrinting = !1;
                            e && a.setSize.apply(a, k);
                            D(a, "afterPrint");
                        }, 1e3);
                    }, 1);
                }
            },
            contextMenu: function(b, a, u, d, f, m, k) {
                var e = this, x = e.options.navigation, l = e.chartWidth, v = e.chartHeight, h = "cache-" + b, g = e[h], B = Math.max(f, m), n;
                g || (e.exportContextMenu = e[h] = g = w("div", {
                    className: b
                }, {
                    position: "absolute",
                    zIndex: 1e3,
                    padding: B + "px",
                    pointerEvents: "auto"
                }, e.fixedDiv || e.container), n = w("div", {
                    className: "highcharts-menu"
                }, null, g), e.styledMode || t(n, y({
                    MozBoxShadow: "3px 3px 10px #888",
                    WebkitBoxShadow: "3px 3px 10px #888",
                    boxShadow: "3px 3px 10px #888"
                }, x.menuStyle)), g.hideMenu = function() {
                    t(g, {
                        display: "none"
                    });
                    k && k.setState(0);
                    e.openMenu = !1;
                    t(e.renderTo, {
                        overflow: "hidden"
                    });
                    c.clearTimeout(g.hideTimer);
                    D(e, "exportMenuHidden");
                }, e.exportEvents.push(r(g, "mouseleave", function() {
                    g.hideTimer = setTimeout(g.hideMenu, 500);
                }), r(g, "mouseenter", function() {
                    c.clearTimeout(g.hideTimer);
                }), r(p, "mouseup", function(a) {
                    e.pointer.inClass(a.target, b) || g.hideMenu();
                }), r(g, "click", function() {
                    e.openMenu && g.hideMenu();
                })), a.forEach(function(a) {
                    "string" === typeof a && (a = e.options.exporting.menuItemDefinitions[a]);
                    if (c.isObject(a, !0)) {
                        var b;
                        a.separator ? b = w("hr", null, null, n) : (b = w("div", {
                            className: "highcharts-menu-item",
                            onclick: function(b) {
                                b && b.stopPropagation();
                                g.hideMenu();
                                a.onclick && a.onclick.apply(e, arguments);
                            },
                            innerHTML: a.text || e.options.lang[a.textKey]
                        }, null, n), e.styledMode || (b.onmouseover = function() {
                            t(this, x.menuItemHoverStyle);
                        }, b.onmouseout = function() {
                            t(this, x.menuItemStyle);
                        }, t(b, y({
                            cursor: "pointer"
                        }, x.menuItemStyle))));
                        e.exportDivElements.push(b);
                    }
                }), e.exportDivElements.push(n, g), e.exportMenuWidth = g.offsetWidth, e.exportMenuHeight = g.offsetHeight);
                a = {
                    display: "block"
                };
                u + e.exportMenuWidth > l ? a.right = l - u - f - B + "px" : a.left = u - B + "px";
                d + m + e.exportMenuHeight > v && "top" !== k.alignOptions.verticalAlign ? a.bottom = v - d - B + "px" : a.top = d + m - B + "px";
                t(g, a);
                t(e.renderTo, {
                    overflow: ""
                });
                e.openMenu = !0;
            },
            addButton: function(b) {
                var a = this, c = a.renderer, d = n(a.options.navigation.buttonOptions, b), f = d.onclick, m = d.menuItems, k, e, h = d.symbolSize || 12;
                a.btnCount || (a.btnCount = 0);
                a.exportDivElements || (a.exportDivElements = [], a.exportSVGElements = []);
                if (!1 !== d.enabled) {
                    var l = d.theme, v = l.states, p = v && v.hover, v = v && v.select, g;
                    a.styledMode || (l.fill = q(l.fill, "#ffffff"), l.stroke = q(l.stroke, "none"));
                    delete l.states;
                    f ? g = function(b) {
                        b && b.stopPropagation();
                        f.call(a, b);
                    } : m && (g = function(b) {
                        b && b.stopPropagation();
                        a.contextMenu(e.menuClassName, m, e.translateX, e.translateY, e.width, e.height, e);
                        e.setState(2);
                    });
                    d.text && d.symbol ? l.paddingLeft = q(l.paddingLeft, 25) : d.text || y(l, {
                        width: d.width,
                        height: d.height,
                        padding: 0
                    });
                    a.styledMode || (l["stroke-linecap"] = "round", l.fill = q(l.fill, "#ffffff"), l.stroke = q(l.stroke, "none"));
                    e = c.button(d.text, 0, 0, g, l, p, v).addClass(b.className).attr({
                        title: q(a.options.lang[d._titleKey || d.titleKey], "")
                    });
                    e.menuClassName = b.menuClassName || "highcharts-menu-" + a.btnCount++;
                    d.symbol && (k = c.symbol(d.symbol, d.symbolX - h / 2, d.symbolY - h / 2, h, h, {
                        width: h,
                        height: h
                    }).addClass("highcharts-button-symbol").attr({
                        zIndex: 1
                    }).add(e), a.styledMode || k.attr({
                        stroke: d.symbolStroke,
                        fill: d.symbolFill,
                        "stroke-width": d.symbolStrokeWidth || 1
                    }));
                    e.add(a.exportingGroup).align(y(d, {
                        width: e.width,
                        x: q(d.x, a.buttonOffset)
                    }), !0, "spacingBox");
                    a.buttonOffset += (e.width + d.buttonSpacing) * ("right" === d.align ? -1 : 1);
                    a.exportSVGElements.push(e, k);
                }
            },
            destroyExport: function(b) {
                var a = b ? b.target : this;
                b = a.exportSVGElements;
                var f = a.exportDivElements, d = a.exportEvents, h;
                b && (b.forEach(function(b, d) {
                    b && (b.onclick = b.ontouchstart = null, h = "cache-" + b.menuClassName, a[h] && delete a[h], 
                    a.exportSVGElements[d] = b.destroy());
                }), b.length = 0);
                a.exportingGroup && (a.exportingGroup.destroy(), delete a.exportingGroup);
                f && (f.forEach(function(b, d) {
                    c.clearTimeout(b.hideTimer);
                    C(b, "mouseleave");
                    a.exportDivElements[d] = b.onmouseout = b.onmouseover = b.ontouchstart = b.onclick = null;
                    E(b);
                }), f.length = 0);
                d && (d.forEach(function(b) {
                    b();
                }), d.length = 0);
            }
        });
        G.prototype.inlineToAttributes = "fill stroke strokeLinecap strokeLinejoin strokeWidth textAnchor x y".split(" ");
        G.prototype.inlineBlacklist = [ /-/, /^(clipPath|cssText|d|height|width)$/, /^font$/, /[lL]ogical(Width|Height)$/, /perspective/, /TapHighlightColor/, /^transition/, /^length$/ ];
        G.prototype.unstyledElements = [ "clipPath", "defs", "desc" ];
        A.prototype.inlineStyles = function() {
            function b(b) {
                return b.replace(/([A-Z])/g, function(b, a) {
                    return "-" + a.toLowerCase();
                });
            }
            function a(c) {
                function u(a, g) {
                    q = v = !1;
                    if (h) {
                        for (r = h.length; r-- && !v; ) v = h[r].test(g);
                        q = !v;
                    }
                    "transform" === g && "none" === a && (q = !0);
                    for (r = f.length; r-- && !q; ) q = f[r].test(g) || "function" === typeof a;
                    q || m[g] === a && "svg" !== c.nodeName || e[c.nodeName][g] === a || (-1 !== d.indexOf(g) ? c.setAttribute(b(g), a) : p += b(g) + ":" + a + ";");
                }
                var g, m, p = "", t, q, v, r;
                if (1 === c.nodeType && -1 === k.indexOf(c.nodeName)) {
                    g = z.getComputedStyle(c, null);
                    m = "svg" === c.nodeName ? {} : z.getComputedStyle(c.parentNode, null);
                    e[c.nodeName] || (x = l.getElementsByTagName("svg")[0], t = l.createElementNS(c.namespaceURI, c.nodeName), 
                    x.appendChild(t), e[c.nodeName] = n(z.getComputedStyle(t, null)), "text" === c.nodeName && delete e.text.fill, 
                    x.removeChild(t));
                    if (L || K) for (var w in g) u(g[w], w); else F(g, u);
                    p && (g = c.getAttribute("style"), c.setAttribute("style", (g ? g + ";" : "") + p));
                    "svg" === c.nodeName && c.setAttribute("stroke-width", "1px");
                    "text" !== c.nodeName && [].forEach.call(c.children || c.childNodes, a);
                }
            }
            var c = this.renderer, d = c.inlineToAttributes, f = c.inlineBlacklist, h = c.inlineWhitelist, k = c.unstyledElements, e = {}, x, l, c = p.createElement("iframe");
            t(c, {
                width: "1px",
                height: "1px",
                visibility: "hidden"
            });
            p.body.appendChild(c);
            l = c.contentWindow.document;
            l.open();
            l.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
            l.close();
            a(this.container.querySelector("svg"));
            x.parentNode.removeChild(x);
        };
        I.menu = function(b, a, c, d) {
            return [ "M", b, a + 2.5, "L", b + c, a + 2.5, "M", b, a + d / 2 + .5, "L", b + c, a + d / 2 + .5, "M", b, a + d - 1.5, "L", b + c, a + d - 1.5 ];
        };
        I.menuball = function(b, a, c, d) {
            b = [];
            d = d / 3 - 2;
            return b = b.concat(this.circle(c - d, a, d, d), this.circle(c - d, a + d + 4, d, d), this.circle(c - d, a + 2 * (d + 4), d, d));
        };
        A.prototype.renderExporting = function() {
            var b = this, a = b.options.exporting, c = a.buttons, d = b.isDirtyExporting || !b.exportSVGElements;
            b.buttonOffset = 0;
            b.isDirtyExporting && b.destroyExport();
            d && !1 !== a.enabled && (b.exportEvents = [], b.exportingGroup = b.exportingGroup || b.renderer.g("exporting-group").attr({
                zIndex: 3
            }).add(), F(c, function(a) {
                b.addButton(a);
            }), b.isDirtyExporting = !1);
            r(b, "destroy", b.destroyExport);
        };
        r(A, "init", function() {
            var b = this;
            b.exporting = {
                update: function(a, c) {
                    b.isDirtyExporting = !0;
                    n(!0, b.options.exporting, a);
                    q(c, !0) && b.redraw();
                }
            };
            f.addUpdate(function(a, c) {
                b.isDirtyExporting = !0;
                n(!0, b.options.navigation, a);
                q(c, !0) && b.redraw();
            }, b);
        });
        A.prototype.callbacks.push(function(b) {
            b.renderExporting();
            r(b, "redraw", b.renderExporting);
        });
    });
    h(f, "masters/modules/exporting.src.js", [], function() {});
});

(function(window) {
    "use strict";
    var minErrConfig = {
        objectMaxDepth: 5,
        urlErrorParamsEnabled: true
    };
    function errorHandlingConfig(config) {
        if (isObject(config)) {
            if (isDefined(config.objectMaxDepth)) {
                minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN;
            }
            if (isDefined(config.urlErrorParamsEnabled) && isBoolean(config.urlErrorParamsEnabled)) {
                minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled;
            }
        } else {
            return minErrConfig;
        }
    }
    function isValidObjectMaxDepth(maxDepth) {
        return isNumber(maxDepth) && maxDepth > 0;
    }
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        var url = "https://errors.angularjs.org/1.7.9/";
        var regex = url.replace(".", "\\.") + "[\\s\\S]*";
        var errRegExp = new RegExp(regex, "g");
        return function() {
            var code = arguments[0], template = arguments[1], message = "[" + (module ? module + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map(function(arg) {
                return toDebugString(arg, minErrConfig.objectMaxDepth);
            }), paramPrefix, i;
            message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1);
                if (index < templateArgs.length) {
                    return templateArgs[index].replace(errRegExp, "");
                }
                return match;
            });
            message += "\n" + url + (module ? module + "/" : "") + code;
            if (minErrConfig.urlErrorParamsEnabled) {
                for (i = 0, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") {
                    message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
                }
            }
            return new ErrorConstructor(message);
        };
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = "validity";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    };
    var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    };
    var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
    msie = window.document.documentMode;
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) return false;
        if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && length - 1 in obj || typeof obj.item === "function");
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key !== "prototype" && key !== "length" && key !== "name" && obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = typeof obj !== "object";
                for (key = 0, length = obj.length; key < length; key++) {
                    if (isPrimitive || key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context, obj);
            } else if (isBlankObject(obj)) {
                for (key in obj) {
                    iterator.call(context, obj[key], key, obj);
                }
            } else if (typeof obj.hasOwnProperty === "function") {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            } else {
                for (key in obj) {
                    if (hasOwnProperty.call(obj, key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        }
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h;
        } else {
            delete obj.$$hashKey;
        }
    }
    function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!isObject(obj) && !isFunction(obj)) continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j];
                var src = obj[key];
                if (deep && isObject(src)) {
                    if (isDate(src)) {
                        dst[key] = new Date(src.valueOf());
                    } else if (isRegExp(src)) {
                        dst[key] = new RegExp(src);
                    } else if (src.nodeName) {
                        dst[key] = src.cloneNode(true);
                    } else if (isElement(src)) {
                        dst[key] = src.clone();
                    } else {
                        if (key !== "__proto__") {
                            if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                            baseExtend(dst[key], [ src ], true);
                        }
                    }
                } else {
                    dst[key] = src;
                }
            }
        }
        setHashKey(dst, h);
        return dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    var isNumberNaN = Number.isNaN || function isNumberNaN(num) {
        return num !== num;
    };
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
        return $;
    }
    identity.$inject = [];
    function valueFn(value) {
        return function valueRef() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
    }
    function isUndefined(value) {
        return typeof value === "undefined";
    }
    function isDefined(value) {
        return typeof value !== "undefined";
    }
    function isObject(value) {
        return value !== null && typeof value === "object";
    }
    function isBlankObject(value) {
        return value !== null && typeof value === "object" && !getPrototypeOf(value);
    }
    function isString(value) {
        return typeof value === "string";
    }
    function isNumber(value) {
        return typeof value === "number";
    }
    function isDate(value) {
        return toString.call(value) === "[object Date]";
    }
    function isArray(arr) {
        return Array.isArray(arr) || arr instanceof Array;
    }
    function isError(value) {
        var tag = toString.call(value);
        switch (tag) {
          case "[object Error]":
            return true;

          case "[object Exception]":
            return true;

          case "[object DOMException]":
            return true;

          default:
            return value instanceof Error;
        }
    }
    function isFunction(value) {
        return typeof value === "function";
    }
    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return toString.call(obj) === "[object File]";
    }
    function isFormData(obj) {
        return toString.call(obj) === "[object FormData]";
    }
    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
    function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    function isArrayBuffer(obj) {
        return toString.call(obj) === "[object ArrayBuffer]";
    }
    var trim = function(value) {
        return isString(value) ? value.trim() : value;
    };
    var escapeForRegexp = function(s) {
        return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var obj = {}, items = str.split(","), i;
        for (i = 0; i < items.length; i++) {
            obj[items[i]] = true;
        }
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) !== -1;
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
            array.splice(index, 1);
        }
        return index;
    }
    function copy(source, destination, maxDepth) {
        var stackSource = [];
        var stackDest = [];
        maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN;
        if (destination) {
            if (isTypedArray(destination) || isArrayBuffer(destination)) {
                throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
            }
            if (source === destination) {
                throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            }
            if (isArray(destination)) {
                destination.length = 0;
            } else {
                forEach(destination, function(value, key) {
                    if (key !== "$$hashKey") {
                        delete destination[key];
                    }
                });
            }
            stackSource.push(source);
            stackDest.push(destination);
            return copyRecurse(source, destination, maxDepth);
        }
        return copyElement(source, maxDepth);
        function copyRecurse(source, destination, maxDepth) {
            maxDepth--;
            if (maxDepth < 0) {
                return "...";
            }
            var h = destination.$$hashKey;
            var key;
            if (isArray(source)) {
                for (var i = 0, ii = source.length; i < ii; i++) {
                    destination.push(copyElement(source[i], maxDepth));
                }
            } else if (isBlankObject(source)) {
                for (key in source) {
                    destination[key] = copyElement(source[key], maxDepth);
                }
            } else if (source && typeof source.hasOwnProperty === "function") {
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        destination[key] = copyElement(source[key], maxDepth);
                    }
                }
            } else {
                for (key in source) {
                    if (hasOwnProperty.call(source, key)) {
                        destination[key] = copyElement(source[key], maxDepth);
                    }
                }
            }
            setHashKey(destination, h);
            return destination;
        }
        function copyElement(source, maxDepth) {
            if (!isObject(source)) {
                return source;
            }
            var index = stackSource.indexOf(source);
            if (index !== -1) {
                return stackDest[index];
            }
            if (isWindow(source) || isScope(source)) {
                throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            }
            var needsRecurse = false;
            var destination = copyType(source);
            if (destination === undefined) {
                destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
                needsRecurse = true;
            }
            stackSource.push(source);
            stackDest.push(destination);
            return needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
        }
        function copyType(source) {
            switch (toString.call(source)) {
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

              case "[object ArrayBuffer]":
                if (!source.slice) {
                    var copied = new ArrayBuffer(source.byteLength);
                    new Uint8Array(copied).set(new Uint8Array(source));
                    return copied;
                }
                return source.slice(0);

              case "[object Boolean]":
              case "[object Number]":
              case "[object String]":
              case "[object Date]":
                return new source.constructor(source.valueOf());

              case "[object RegExp]":
                var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                re.lastIndex = source.lastIndex;
                return re;

              case "[object Blob]":
                return new source.constructor([ source ], {
                    type: source.type
                });
            }
            if (isFunction(source.cloneNode)) {
                return source.cloneNode(true);
            }
        }
    }
    function simpleCompare(a, b) {
        return a === b || a !== a && b !== b;
    }
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 === t2 && t1 === "object") {
            if (isArray(o1)) {
                if (!isArray(o2)) return false;
                if ((length = o1.length) === o2.length) {
                    for (key = 0; key < length; key++) {
                        if (!equals(o1[key], o2[key])) return false;
                    }
                    return true;
                }
            } else if (isDate(o1)) {
                if (!isDate(o2)) return false;
                return simpleCompare(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
                if (!isRegExp(o2)) return false;
                return o1.toString() === o2.toString();
            } else {
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
                keySet = createMap();
                for (key in o1) {
                    if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                    if (!equals(o1[key], o2[key])) return false;
                    keySet[key] = true;
                }
                for (key in o2) {
                    if (!(key in keySet) && key.charAt(0) !== "$" && isDefined(o2[key]) && !isFunction(o2[key])) return false;
                }
                return true;
            }
        }
        return false;
    }
    var csp = function() {
        if (!isDefined(csp.rules)) {
            var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
            if (ngCspElement) {
                var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                csp.rules = {
                    noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
                    noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1
                };
            } else {
                csp.rules = {
                    noUnsafeEval: noUnsafeEval(),
                    noInlineStyle: false
                };
            }
        }
        return csp.rules;
        function noUnsafeEval() {
            try {
                new Function("");
                return false;
            } catch (e) {
                return true;
            }
        }
    };
    var jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el;
        var i, ii = ngAttrPrefixes.length, prefix, name;
        for (i = 0; i < ii; ++i) {
            prefix = ngAttrPrefixes[i];
            el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]");
            if (el) {
                name = el.getAttribute(prefix + "jq");
                break;
            }
        }
        return jq.name_ = name;
    };
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self);
            };
        } else {
            return fn;
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
            val = undefined;
        } else if (isWindow(value)) {
            val = "$WINDOW";
        } else if (value && window.document === value) {
            val = "$DOCUMENT";
        } else if (isScope(value)) {
            val = "$SCOPE";
        }
        return val;
    }
    function toJson(obj, pretty) {
        if (isUndefined(obj)) return undefined;
        if (!isNumber(pretty)) {
            pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    var ALL_COLONS = /:/g;
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
    }
    function startingTag(element) {
        element = jqLite(element).clone().empty();
        var elemHtml = jqLite("<div></div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split("&"), function(keyValue) {
            var splitPoint, key, val;
            if (keyValue) {
                key = keyValue = keyValue.replace(/\+/g, "%20");
                splitPoint = keyValue.indexOf("=");
                if (splitPoint !== -1) {
                    key = keyValue.substring(0, splitPoint);
                    val = keyValue.substring(splitPoint + 1);
                }
                key = tryDecodeURIComponent(key);
                if (isDefined(key)) {
                    val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val;
                    } else if (isArray(obj[key])) {
                        obj[key].push(val);
                    } else {
                        obj[key] = [ obj[key], val ];
                    }
                }
            }
        });
        return obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            if (isArray(value)) {
                forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                });
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
            }
        });
        return parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
            attr = ngAttrPrefixes[i] + ngAttr;
            if (isString(attr = element.getAttribute(attr))) {
                return attr;
            }
        }
        return null;
    }
    function allowAutoBootstrap(document) {
        var script = document.currentScript;
        if (!script) {
            return true;
        }
        if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) {
            return false;
        }
        var attributes = script.attributes;
        var srcs = [ attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href") ];
        return srcs.every(function(src) {
            if (!src) {
                return true;
            }
            if (!src.value) {
                return false;
            }
            var link = document.createElement("a");
            link.href = src.value;
            if (document.location.origin === link.origin) {
                return true;
            }
            switch (link.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "blob:":
              case "file:":
              case "data:":
                return true;

              default:
                return false;
            }
        });
    }
    var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                appElement = element;
                module = element.getAttribute(name);
            }
        });
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            var candidate;
            if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                appElement = candidate;
                module = candidate.getAttribute(name);
            }
        });
        if (appElement) {
            if (!isAutoBootstrapAllowed) {
                window.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates " + "an extension, document.location.href does not match.");
                return;
            }
            config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        if (!isObject(config)) config = {};
        var defaultConfig = {
            strictDi: false
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            element = jqLite(element);
            if (element.injector()) {
                var tag = element[0] === window.document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [];
            modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]);
            if (config.debugInfoEnabled) {
                modules.push([ "$compileProvider", function($compileProvider) {
                    $compileProvider.debugInfoEnabled(true);
                } ]);
            }
            modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function bootstrapApply(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector);
                    compile(element)(scope);
                });
            } ]);
            return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
            config.debugInfoEnabled = true;
            window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
        angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            });
            return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
            angular.resumeDeferredBootstrap();
        }
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
        window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        }
        return injector.get("$$testability");
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
        separator = separator || "_";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var bindJQueryFired = false;
    function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
            return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
        } else {
            jqLite = JQLite;
        }
        originalCleanData = jqLite.cleanData;
        jqLite.cleanData = function(elems) {
            var events;
            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                events = (jqLite._data(elem) || {}).events;
                if (events && events.$destroy) {
                    jqLite(elem).triggerHandler("$destroy");
                }
            }
            originalCleanData(elems);
        };
        angular.element = jqLite;
        bindJQueryFired = true;
    }
    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        }
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
        return arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
        }
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split(".");
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }
    function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
            if (blockNodes || nodes[i] !== node) {
                if (!blockNodes) {
                    blockNodes = jqLite(slice.call(nodes, 0, i));
                }
                blockNodes.push(node);
            }
        }
        return blockNodes || nodes;
    }
    function createMap() {
        return Object.create(null);
    }
    function stringify(value) {
        if (value == null) {
            return "";
        }
        switch (typeof value) {
          case "string":
            break;

          case "number":
            value = "" + value;
            break;

          default:
            if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
                value = value.toString();
            } else {
                value = toJson(value);
            }
        }
        return value;
    }
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_ATTRIBUTE = 2;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector");
        var ngMinErr = minErr("ng");
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, "angular", Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, "module", function() {
            var modules = {};
            return function module(name, requires, configFn) {
                var info = {};
                var assertNotHasOwnProperty = function(name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                    }
                };
                assertNotHasOwnProperty(name, "module");
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                    }
                    var invokeQueue = [];
                    var configBlocks = [];
                    var runBlocks = [];
                    var config = invokeLater("$injector", "invoke", "push", configBlocks);
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        info: function(value) {
                            if (isDefined(value)) {
                                if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                info = value;
                                return this;
                            }
                            return info;
                        },
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                        config: config,
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };
                    if (configFn) {
                        config(configFn);
                    }
                    return moduleInstance;
                    function invokeLater(provider, method, insertMethod, queue) {
                        if (!queue) queue = invokeQueue;
                        return function() {
                            queue[insertMethod || "push"]([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method, queue) {
                        if (!queue) queue = invokeQueue;
                        return function(recipeName, factoryFunction) {
                            if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
                            queue.push([ provider, method, arguments ]);
                            return moduleInstance;
                        };
                    }
                });
            };
        });
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++) {
                dst[i] = src[i];
            }
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) {
                if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key];
                }
            }
        }
        return dst || src;
    }
    function serializeObject(obj, maxDepth) {
        var seen = [];
        if (isValidObjectMaxDepth(maxDepth)) {
            obj = angular.copy(obj, null, maxDepth);
        }
        return JSON.stringify(obj, function(key, val) {
            val = toJsonReplacer(key, val);
            if (isObject(val)) {
                if (seen.indexOf(val) >= 0) return "...";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj, maxDepth) {
        if (typeof obj === "function") {
            return obj.toString().replace(/ \{[\s\S]*$/, "");
        } else if (isUndefined(obj)) {
            return "undefined";
        } else if (typeof obj !== "string") {
            return serializeObject(obj, maxDepth);
        }
        return obj;
    }
    var version = {
        full: "1.7.9",
        major: 1,
        minor: 7,
        dot: 9,
        codeName: "pollution-eradication"
    };
    function publishExternalAPI(angular) {
        extend(angular, {
            errorHandlingConfig: errorHandlingConfig,
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            callbacks: {
                $$counter: 0
            },
            getTestability: getTestability,
            reloadWithDebugInfo: reloadWithDebugInfo,
            $$minErr: minErr,
            $$csp: csp,
            $$encodeUriSegment: encodeUriSegment,
            $$encodeUriQuery: encodeUriQuery,
            $$lowercase: lowercase,
            $$stringify: stringify,
            $$uppercase: uppercase
        });
        angularModule = setupModuleLoader(window);
        angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRef: ngRefDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective,
                input: hiddenInputBrowserCacheDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $$intervalFactory: $$IntervalFactoryProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$Map: $$MapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]).info({
            angularVersion: "1.7.9"
        });
    }
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1;
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
        return ++jqId;
    }
    var DASH_LOWERCASE_REGEXP = /-([a-z])/g;
    var MS_HACK_REGEXP = /^-ms-/;
    var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    };
    var jqLiteMinErr = minErr("jqLite");
    function cssKebabToCamel(name) {
        return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
    }
    function fnCamelCaseReplace(all, letter) {
        return letter.toUpperCase();
    }
    function kebabToCamel(name) {
        return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:-]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
    var wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
            return true;
        }
        return false;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html));
        } else {
            tmp = fragment.appendChild(context.createElement("div"));
            tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
            i = wrap[0];
            while (i--) {
                tmp = tmp.lastChild;
            }
            nodes = concat(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
            fragment.appendChild(node);
        });
        return fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [ context.createElement(parsed[1]) ];
        }
        if (parsed = jqLiteBuildFragment(html, context)) {
            return parsed.childNodes;
        }
        return [];
    }
    function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
            parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
    }
    var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
    };
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        var argIsString;
        if (isString(element)) {
            element = trim(element);
            argIsString = true;
        }
        if (!(this instanceof JQLite)) {
            if (argIsString && element.charAt(0) !== "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            }
            return new JQLite(element);
        }
        if (argIsString) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else if (isFunction(element)) {
            jqLiteReady(element);
        } else {
            jqLiteAddNodes(this, element);
        }
    }
    function jqLiteClone(element) {
        return element.cloneNode(true);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants && jqLiteAcceptsData(element)) jqLite.cleanData([ element ]);
        if (element.querySelectorAll) {
            jqLite.cleanData(element.querySelectorAll("*"));
        }
    }
    function isEmptyObject(obj) {
        var name;
        for (name in obj) {
            return false;
        }
        return true;
    }
    function removeIfEmptyData(element) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        var events = expandoStore && expandoStore.events;
        var data = expandoStore && expandoStore.data;
        if ((!data || isEmptyObject(data)) && (!events || isEmptyObject(events))) {
            delete jqCache[expandoId];
            element.ng339 = undefined;
        }
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle) return;
        if (!type) {
            for (type in events) {
                if (type !== "$destroy") {
                    element.removeEventListener(type, handle);
                }
                delete events[type];
            }
        } else {
            var removeHandler = function(type) {
                var listenerFns = events[type];
                if (isDefined(fn)) {
                    arrayRemove(listenerFns || [], fn);
                }
                if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                    element.removeEventListener(type, handle);
                    delete events[type];
                }
            };
            forEach(type.split(" "), function(type) {
                removeHandler(type);
                if (MOUSE_EVENT_MAP[type]) {
                    removeHandler(MOUSE_EVENT_MAP[type]);
                }
            });
        }
        removeIfEmptyData(element);
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) {
                delete expandoStore.data[name];
            } else {
                expandoStore.data = {};
            }
            removeIfEmptyData(element);
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
            element.ng339 = expandoId = jqNextId();
            expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: undefined
            };
        }
        return expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var prop;
            var isSimpleSetter = isDefined(value);
            var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
            var massGetter = !key;
            var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
            var data = expandoStore && expandoStore.data;
            if (isSimpleSetter) {
                data[kebabToCamel(key)] = value;
            } else {
                if (massGetter) {
                    return data;
                } else {
                    if (isSimpleGetter) {
                        return data && data[kebabToCamel(key)];
                    } else {
                        for (prop in key) {
                            data[kebabToCamel(prop)] = key[prop];
                        }
                    }
                }
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute) return false;
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            var newClasses = existingClasses;
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                newClasses = newClasses.replace(" " + cssClass + " ", " ");
            });
            if (newClasses !== existingClasses) {
                element.setAttribute("class", trim(newClasses));
            }
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            var newClasses = existingClasses;
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass);
                if (newClasses.indexOf(" " + cssClass + " ") === -1) {
                    newClasses += cssClass + " ";
                }
            });
            if (newClasses !== existingClasses) {
                element.setAttribute("class", trim(newClasses));
            }
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            if (elements.nodeType) {
                root[root.length++] = elements;
            } else {
                var length = elements.length;
                if (typeof length === "number" && elements.window !== elements) {
                    if (length) {
                        for (var i = 0; i < length; i++) {
                            root[root.length++] = elements[i];
                        }
                    }
                } else {
                    root[root.length++] = elements;
                }
            }
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType === NODE_TYPE_DOCUMENT) {
            element = element.documentElement;
        }
        var names = isArray(name) ? name : [ name ];
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if (isDefined(value = jqLite.data(element, names[i]))) return value;
            }
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
    }
    function jqLiteRemove(element, keepData) {
        if (!keepData) jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent) parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === "complete") {
            win.setTimeout(action);
        } else {
            jqLite(win).on("load", action);
        }
    }
    function jqLiteReady(fn) {
        function trigger() {
            window.document.removeEventListener("DOMContentLoaded", trigger);
            window.removeEventListener("load", trigger);
            fn();
        }
        if (window.document.readyState === "complete") {
            window.setTimeout(fn);
        } else {
            window.document.addEventListener("DOMContentLoaded", trigger);
            window.addEventListener("load", trigger);
        }
    }
    var JQLitePrototype = JQLite.prototype = {
        ready: jqLiteReady,
        toString: function() {
            var value = [];
            forEach(this, function(e) {
                value.push("" + e);
            });
            return "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern",
        ngStep: "step"
    };
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
    }
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: function jqLiteCleanData(nodes) {
            for (var i = 0, ii = nodes.length; i < ii; i++) {
                jqLiteRemoveData(nodes[i]);
                jqLiteOff(nodes[i]);
            }
        }
    }, function(fn, name) {
        JQLite[name] = fn;
    });
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            name = cssKebabToCamel(name);
            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                return element.style[name];
            }
        },
        attr: function(element, name, value) {
            var ret;
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT || !element.getAttribute) {
                return;
            }
            var lowercasedName = lowercase(name);
            var isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
            if (isDefined(value)) {
                if (value === null || value === false && isBooleanAttr) {
                    element.removeAttribute(name);
                } else {
                    element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
                }
            } else {
                ret = element.getAttribute(name);
                if (isBooleanAttr && ret !== null) {
                    ret = lowercasedName;
                }
                return ret === null ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },
        text: function() {
            getText.$dv = "";
            return getText;
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && nodeName_(element) === "select") {
                    var result = [];
                    forEach(element.options, function(option) {
                        if (option.selected) {
                            result.push(option.value || option.text);
                        }
                    });
                    return result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            jqLiteDealoc(element, true);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;
            var nodeCount = this.length;
            if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1);
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key]);
                            }
                        }
                    }
                    return this;
                } else {
                    var value = fn.$dv;
                    var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue;
                    }
                    return value;
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2);
                }
                return this;
            }
        };
    });
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type];
            var eventFnsLength = eventFns ? eventFns.length : 0;
            if (!eventFnsLength) return;
            if (isUndefined(event.immediatePropagationStopped)) {
                var originalStopImmediatePropagation = event.stopImmediatePropagation;
                event.stopImmediatePropagation = function() {
                    event.immediatePropagationStopped = true;
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    if (originalStopImmediatePropagation) {
                        originalStopImmediatePropagation.call(event);
                    }
                };
            }
            event.isImmediatePropagationStopped = function() {
                return event.immediatePropagationStopped === true;
            };
            var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
            if (eventFnsLength > 1) {
                eventFns = shallowCopy(eventFns);
            }
            for (var i = 0; i < eventFnsLength; i++) {
                if (!event.isImmediatePropagationStopped()) {
                    handlerWrapper(element, event, eventFns[i]);
                }
            }
        };
        eventHandler.elem = element;
        return eventHandler;
    }
    function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
    }
    function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || related !== target && !jqLiteContains.call(target, related)) {
            handler.call(target, event);
        }
    }
    forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (!jqLiteAcceptsData(element)) {
                return;
            }
            var expandoStore = jqLiteExpandoStore(element, true);
            var events = expandoStore.events;
            var handle = expandoStore.handle;
            if (!handle) {
                handle = expandoStore.handle = createEventHandler(element, events);
            }
            var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ];
            var i = types.length;
            var addHandler = function(type, specialHandlerWrapper, noEventListener) {
                var eventFns = events[type];
                if (!eventFns) {
                    eventFns = events[type] = [];
                    eventFns.specialHandlerWrapper = specialHandlerWrapper;
                    if (type !== "$destroy" && !noEventListener) {
                        element.addEventListener(type, handle);
                    }
                }
                eventFns.push(fn);
            };
            while (i--) {
                type = types[i];
                if (MOUSE_EVENT_MAP[type]) {
                    addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                    addHandler(type, undefined, true);
                } else {
                    addHandler(type);
                }
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element);
            element.on(type, function onFn() {
                element.off(type, fn);
                element.off(type, onFn);
            });
            element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element) {
                if (element.nodeType === NODE_TYPE_ELEMENT) {
                    children.push(element);
                }
            });
            return children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
            node = new JQLite(node);
            for (var i = 0, ii = node.length; i < ii; i++) {
                var child = node[i];
                element.appendChild(child);
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            if (parent) {
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; i < ii; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling);
                    index = node;
                }
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className);
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                });
            }
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector);
            } else {
                return [];
            }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs;
            var eventName = event.type || event;
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var eventFns = events && events[eventName];
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = true;
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === true;
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = true;
                    },
                    isImmediatePropagationStopped: function() {
                        return this.immediatePropagationStopped === true;
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                };
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event);
                }
                eventFnsCopy = shallowCopy(eventFns);
                handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                forEach(eventFnsCopy, function(fn) {
                    if (!dummyEvent.isImmediatePropagationStopped()) {
                        fn.apply(element, handlerArgs);
                    }
                });
            }
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            var value;
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3);
                    if (isDefined(value)) {
                        value = jqLite(value);
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                }
            }
            return isDefined(value) ? value : this;
        };
    });
    JQLite.prototype.bind = JQLite.prototype.on;
    JQLite.prototype.unbind = JQLite.prototype.off;
    function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    if (node.attr) node = node[0];
                    return jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
            if (typeof key === "function") {
                key = obj.$$hashKey();
            }
            return key;
        }
        var objType = typeof obj;
        if (objType === "function" || objType === "object" && obj !== null) {
            key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
        } else {
            key = objType + ":" + obj;
        }
        return key;
    }
    var nanKey = Object.create(null);
    function NgMapShim() {
        this._keys = [];
        this._values = [];
        this._lastKey = NaN;
        this._lastIndex = -1;
    }
    NgMapShim.prototype = {
        _idx: function(key) {
            if (key !== this._lastKey) {
                this._lastKey = key;
                this._lastIndex = this._keys.indexOf(key);
            }
            return this._lastIndex;
        },
        _transformKey: function(key) {
            return isNumberNaN(key) ? nanKey : key;
        },
        get: function(key) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            if (idx !== -1) {
                return this._values[idx];
            }
        },
        has: function(key) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            return idx !== -1;
        },
        set: function(key, value) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            if (idx === -1) {
                idx = this._lastIndex = this._keys.length;
            }
            this._keys[idx] = key;
            this._values[idx] = value;
        },
        delete: function(key) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            if (idx === -1) {
                return false;
            }
            this._keys.splice(idx, 1);
            this._values.splice(idx, 1);
            this._lastKey = NaN;
            this._lastIndex = -1;
            return true;
        }
    };
    var NgMap = NgMapShim;
    var $$MapProvider = [ function() {
        this.$get = [ function() {
            return NgMap;
        } ];
    } ];
    var ARROW_ARG = /^([^(]+?)=>/;
    var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
    var $injectorMinErr = minErr("$injector");
    function stringifyFn(fn) {
        return Function.prototype.toString.call(fn);
    }
    function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
    }
    function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
            return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
        }
        return "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, argDecl, last;
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = [];
                if (fn.length) {
                    if (strictDi) {
                        if (!isString(name) || !name) {
                            name = fn.name || anonFn(fn);
                        }
                        throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    }
                    argDecl = extractArgs(fn);
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else if (isArray(fn)) {
            last = fn.length - 1;
            assertArgFn(fn[last], "fn");
            $inject = fn.slice(0, last);
        } else {
            assertArgFn(fn, "fn", true);
        }
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        strictDi = strictDi === true;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap(), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular.isString(caller)) {
                path.push(caller);
            }
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        }), instanceInjector = protoInstanceInjector;
        providerCache["$injector" + providerSuffix] = {
            $get: valueFn(protoInstanceInjector)
        };
        instanceInjector.modules = providerInjector.modules = createMap();
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get("$injector");
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
            if (fn) instanceInjector.invoke(fn);
        });
        instanceInjector.loadNewModules = function(mods) {
            forEach(loadModules(mods), function(fn) {
                if (fn) instanceInjector.invoke(fn);
            });
        };
        return instanceInjector;
        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            };
        }
        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service");
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            }
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function enforcedReturnValue() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) {
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                }
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant");
            providerCache[name] = value;
            instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
            var runBlocks = [], moduleFn;
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.set(module, true);
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module);
                        instanceInjector.modules[module] = moduleFn;
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                        runInvokeQueue(moduleFn._invokeQueue);
                        runInvokeQueue(moduleFn._configBlocks);
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module));
                    } else {
                        assertArgFn(module, "module");
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1];
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                        e = e.message + "\n" + e.stack;
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                }
            });
            return runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        cache[serviceName] = factory(serviceName, caller);
                        return cache[serviceName];
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName];
                        }
                        throw err;
                    } finally {
                        path.shift();
                    }
                }
            }
            function injectionArgs(fn, locals, serviceName) {
                var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                for (var i = 0, length = $inject.length; i < length; i++) {
                    var key = $inject[i];
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return args;
            }
            function isClass(func) {
                if (msie || typeof func !== "function") {
                    return false;
                }
                var result = func.$$ngIsClass;
                if (!isBoolean(result)) {
                    result = func.$$ngIsClass = /^class\b/.test(stringifyFn(func));
                }
                return result;
            }
            function invoke(fn, self, locals, serviceName) {
                if (typeof locals === "string") {
                    serviceName = locals;
                    locals = null;
                }
                var args = injectionArgs(fn, locals, serviceName);
                if (isArray(fn)) {
                    fn = fn[fn.length - 1];
                }
                if (!isClass(fn)) {
                    return fn.apply(self, args);
                } else {
                    args.unshift(null);
                    return new (Function.prototype.bind.apply(fn, args))();
                }
            }
            function instantiate(Type, locals, serviceName) {
                var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
                var args = injectionArgs(Type, locals, serviceName);
                args.unshift(null);
                return new (Function.prototype.bind.apply(ctor, args))();
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
    }
    createInjector.$$annotate = annotate;
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };
        this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            var document = $window.document;
            function getFirstAnchor(list) {
                var result = null;
                Array.prototype.some.call(list, function(element) {
                    if (nodeName_(element) === "a") {
                        result = element;
                        return true;
                    }
                });
                return result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) {
                    offset = offset();
                } else if (isElement(offset)) {
                    var elem = offset[0];
                    var style = $window.getComputedStyle(elem);
                    if (style.position !== "fixed") {
                        offset = 0;
                    } else {
                        offset = elem.getBoundingClientRect().bottom;
                    }
                } else if (!isNumber(offset)) {
                    offset = 0;
                }
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else {
                    $window.scrollTo(0, 0);
                }
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                var elm;
                if (!hash) scrollTo(null); else if (elm = document.getElementById(hash)) scrollTo(elm); else if (elm = getFirstAnchor(document.getElementsByName(hash))) scrollTo(elm); else if (hash === "top") scrollTo(null);
            }
            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash();
                }, function autoScrollWatchAction(newVal, oldVal) {
                    if (newVal === oldVal && newVal === "") return;
                    jqLiteDocumentLoaded(function() {
                        $rootScope.$evalAsync(scroll);
                    });
                });
            }
            return scroll;
        } ];
    }
    var $animateMinErr = minErr("$animate");
    var ELEMENT_NODE = 1;
    var NG_ANIMATE_CLASSNAME = "ng-animate";
    function mergeClasses(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        if (isArray(a)) a = a.join(" ");
        if (isArray(b)) b = b.join(" ");
        return a + " " + b;
    }
    function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) {
                return elm;
            }
        }
    }
    function splitClasses(classes) {
        if (isString(classes)) {
            classes = classes.split(" ");
        }
        var obj = createMap();
        forEach(classes, function(klass) {
            if (klass.length) {
                obj[klass] = true;
            }
        });
        return obj;
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
    };
    var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new NgMap();
        var postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, options, domOperation) {
                    if (domOperation) {
                        domOperation();
                    }
                    options = options || {};
                    if (options.from) {
                        element.css(options.from);
                    }
                    if (options.to) {
                        element.css(options.to);
                    }
                    if (options.addClass || options.removeClass) {
                        addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                    }
                    var runner = new $$AnimateRunner();
                    runner.complete();
                    return runner;
                }
            };
            function updateData(data, classes, value) {
                var changed = false;
                if (classes) {
                    classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [];
                    forEach(classes, function(className) {
                        if (className) {
                            changed = true;
                            data[className] = value;
                        }
                    });
                }
                return changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function(element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        var existing = splitClasses(element.attr("class"));
                        var toAdd = "";
                        var toRemove = "";
                        forEach(data, function(status, className) {
                            var hasClass = !!existing[className];
                            if (status !== hasClass) {
                                if (status) {
                                    toAdd += (toAdd.length ? " " : "") + className;
                                } else {
                                    toRemove += (toRemove.length ? " " : "") + className;
                                }
                            }
                        });
                        forEach(element, function(elm) {
                            if (toAdd) {
                                jqLiteAddClass(elm, toAdd);
                            }
                            if (toRemove) {
                                jqLiteRemoveClass(elm, toRemove);
                            }
                        });
                        postDigestQueue.delete(element);
                    }
                });
                postDigestElements.length = 0;
            }
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element) || {};
                var classesAdded = updateData(data, add, true);
                var classesRemoved = updateData(data, remove, false);
                if (classesAdded || classesRemoved) {
                    postDigestQueue.set(element, data);
                    postDigestElements.push(element);
                    if (postDigestElements.length === 1) {
                        $rootScope.$$postDigest(handleCSSClassChanges);
                    }
                }
            }
        } ];
    };
    var $AnimateProvider = [ "$provide", function($provide) {
        var provider = this;
        var classNameFilter = null;
        var customFilter = null;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
            if (name && name.charAt(0) !== ".") {
                throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            }
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key;
            $provide.factory(key, factory);
        };
        this.customFilter = function(filterFn) {
            if (arguments.length === 1) {
                customFilter = isFunction(filterFn) ? filterFn : null;
            }
            return customFilter;
        };
        this.classNameFilter = function(expression) {
            if (arguments.length === 1) {
                classNameFilter = expression instanceof RegExp ? expression : null;
                if (classNameFilter) {
                    var reservedRegex = new RegExp("[(\\s|\\/)]" + NG_ANIMATE_CLASSNAME + "[(\\s|\\/)]");
                    if (reservedRegex.test(classNameFilter.toString())) {
                        classNameFilter = null;
                        throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                    }
                }
            }
            return classNameFilter;
        };
        this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                        afterElement = null;
                    }
                }
                if (afterElement) {
                    afterElement.after(element);
                } else {
                    parentElement.prepend(element);
                }
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    if (runner.cancel) {
                        runner.cancel();
                    }
                },
                enter: function(element, parent, after, options) {
                    parent = parent && jqLite(parent);
                    after = after && jqLite(after);
                    parent = parent || after.parent();
                    domInsert(element, parent, after);
                    return $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    parent = parent && jqLite(parent);
                    after = after && jqLite(after);
                    parent = parent || after.parent();
                    domInsert(element, parent, after);
                    return $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    options = prepareAnimateOptions(options);
                    options.addClass = mergeClasses(options.addclass, className);
                    return $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    options = prepareAnimateOptions(options);
                    options.removeClass = mergeClasses(options.removeClass, className);
                    return $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    options = prepareAnimateOptions(options);
                    options.addClass = mergeClasses(options.addClass, add);
                    options.removeClass = mergeClasses(options.removeClass, remove);
                    return $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    options = prepareAnimateOptions(options);
                    options.from = options.from ? extend(options.from, from) : from;
                    options.to = options.to ? extend(options.to, to) : to;
                    className = className || "ng-inline-animate";
                    options.tempClasses = mergeClasses(options.tempClasses, className);
                    return $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ];
    var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = [ "$$rAF", function($$rAF) {
            var waitQueue = [];
            function waitForTick(fn) {
                waitQueue.push(fn);
                if (waitQueue.length > 1) return;
                $$rAF(function() {
                    for (var i = 0; i < waitQueue.length; i++) {
                        waitQueue[i]();
                    }
                    waitQueue = [];
                });
            }
            return function() {
                var passed = false;
                waitForTick(function() {
                    passed = true;
                });
                return function(callback) {
                    if (passed) {
                        callback();
                    } else {
                        waitForTick(callback);
                    }
                };
            };
        } ];
    };
    var $$AnimateRunnerFactoryProvider = function() {
        this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
            var INITIAL_STATE = 0;
            var DONE_PENDING_STATE = 1;
            var DONE_COMPLETE_STATE = 2;
            AnimateRunner.chain = function(chain, callback) {
                var index = 0;
                next();
                function next() {
                    if (index === chain.length) {
                        callback(true);
                        return;
                    }
                    chain[index](function(response) {
                        if (response === false) {
                            callback(false);
                            return;
                        }
                        index++;
                        next();
                    });
                }
            };
            AnimateRunner.all = function(runners, callback) {
                var count = 0;
                var status = true;
                forEach(runners, function(runner) {
                    runner.done(onProgress);
                });
                function onProgress(response) {
                    status = status && response;
                    if (++count === runners.length) {
                        callback(status);
                    }
                }
            };
            function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun();
                var timeoutTick = function(fn) {
                    $timeout(fn, 0, false);
                };
                this._doneCallbacks = [];
                this._tick = function(fn) {
                    if ($$isDocumentHidden()) {
                        timeoutTick(fn);
                    } else {
                        rafTick(fn);
                    }
                };
                this._state = 0;
            }
            AnimateRunner.prototype = {
                setHost: function(host) {
                    this.host = host || {};
                },
                done: function(fn) {
                    if (this._state === DONE_COMPLETE_STATE) {
                        fn();
                    } else {
                        this._doneCallbacks.push(fn);
                    }
                },
                progress: noop,
                getPromise: function() {
                    if (!this.promise) {
                        var self = this;
                        this.promise = $q(function(resolve, reject) {
                            self.done(function(status) {
                                if (status === false) {
                                    reject();
                                } else {
                                    resolve();
                                }
                            });
                        });
                    }
                    return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                    return this.getPromise().then(resolveHandler, rejectHandler);
                },
                catch: function(handler) {
                    return this.getPromise()["catch"](handler);
                },
                finally: function(handler) {
                    return this.getPromise()["finally"](handler);
                },
                pause: function() {
                    if (this.host.pause) {
                        this.host.pause();
                    }
                },
                resume: function() {
                    if (this.host.resume) {
                        this.host.resume();
                    }
                },
                end: function() {
                    if (this.host.end) {
                        this.host.end();
                    }
                    this._resolve(true);
                },
                cancel: function() {
                    if (this.host.cancel) {
                        this.host.cancel();
                    }
                    this._resolve(false);
                },
                complete: function(response) {
                    var self = this;
                    if (self._state === INITIAL_STATE) {
                        self._state = DONE_PENDING_STATE;
                        self._tick(function() {
                            self._resolve(response);
                        });
                    }
                },
                _resolve: function(response) {
                    if (this._state !== DONE_COMPLETE_STATE) {
                        forEach(this._doneCallbacks, function(fn) {
                            fn(response);
                        });
                        this._doneCallbacks.length = 0;
                        this._state = DONE_COMPLETE_STATE;
                    }
                }
            };
            return AnimateRunner;
        } ];
    };
    var $CoreAnimateCssProvider = function() {
        this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
            return function(element, initialOptions) {
                var options = initialOptions || {};
                if (!options.$$prepared) {
                    options = copy(options);
                }
                if (options.cleanupStyles) {
                    options.from = options.to = null;
                }
                if (options.from) {
                    element.css(options.from);
                    options.from = null;
                }
                var closed, runner = new $$AnimateRunner();
                return {
                    start: run,
                    end: run
                };
                function run() {
                    $$rAF(function() {
                        applyAnimationContents();
                        if (!closed) {
                            runner.complete();
                        }
                        closed = true;
                    });
                    return runner;
                }
                function applyAnimationContents() {
                    if (options.addClass) {
                        element.addClass(options.addClass);
                        options.addClass = null;
                    }
                    if (options.removeClass) {
                        element.removeClass(options.removeClass);
                        options.removeClass = null;
                    }
                    if (options.to) {
                        element.css(options.to);
                        options.to = null;
                    }
                }
            };
        } ];
    };
    function getHash(url) {
        var index = url.indexOf("#");
        return index === -1 ? "" : url.substr(index);
    }
    function trimEmptyHash(url) {
        return url.replace(/#$/, "");
    }
    function Browser(window, document, $log, $sniffer, $$taskTrackerFactory) {
        var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {}, taskTracker = $$taskTrackerFactory($log);
        self.isMock = false;
        self.$$completeOutstandingRequest = taskTracker.completeTask;
        self.$$incOutstandingRequestCount = taskTracker.incTaskCount;
        self.notifyWhenNoOutstandingRequests = taskTracker.notifyWhenNoPendingTasks;
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
            try {
                return history.state;
            } catch (e) {}
        };
        cacheState();
        self.url = function(url, replace, state) {
            if (isUndefined(state)) {
                state = null;
            }
            if (location !== window.location) location = window.location;
            if (history !== window.history) history = window.history;
            if (url) {
                var sameState = lastHistoryState === state;
                url = urlResolve(url).href;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                    return self;
                }
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                lastBrowserUrl = url;
                lastHistoryState = state;
                if ($sniffer.history && (!sameBase || !sameState)) {
                    history[replace ? "replaceState" : "pushState"](state, "", url);
                    cacheState();
                } else {
                    if (!sameBase) {
                        pendingLocation = url;
                    }
                    if (replace) {
                        location.replace(url);
                    } else if (!sameBase) {
                        location.href = url;
                    } else {
                        location.hash = getHash(url);
                    }
                    if (location.href !== url) {
                        pendingLocation = url;
                    }
                }
                if (pendingLocation) {
                    pendingLocation = url;
                }
                return self;
            } else {
                return trimEmptyHash(pendingLocation || location.href);
            }
        };
        self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
            pendingLocation = null;
            fireStateOrUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
            cachedState = getCurrentState();
            cachedState = isUndefined(cachedState) ? null : cachedState;
            if (equals(cachedState, lastCachedState)) {
                cachedState = lastCachedState;
            }
            lastCachedState = cachedState;
            lastHistoryState = cachedState;
        }
        function fireStateOrUrlChange() {
            var prevLastHistoryState = lastHistoryState;
            cacheState();
            if (lastBrowserUrl === self.url() && prevLastHistoryState === cachedState) {
                return;
            }
            lastBrowserUrl = self.url();
            lastHistoryState = cachedState;
            forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            });
        }
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                urlChangeInit = true;
            }
            urlChangeListeners.push(callback);
            return callback;
        };
        self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireStateOrUrlChange;
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
        };
        self.defer = function(fn, delay, taskType) {
            var timeoutId;
            delay = delay || 0;
            taskType = taskType || taskTracker.DEFAULT_TASK_TYPE;
            taskTracker.incTaskCount(taskType);
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                taskTracker.completeTask(fn, taskType);
            }, delay);
            pendingDeferIds[timeoutId] = taskType;
            return timeoutId;
        };
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds.hasOwnProperty(deferId)) {
                var taskType = pendingDeferIds[deferId];
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                taskTracker.completeTask(noop, taskType);
                return true;
            }
            return false;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", "$$taskTrackerFactory", function($window, $log, $sniffer, $document, $$taskTrackerFactory) {
            return new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            var caches = {};
            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                }
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (isUndefined(value)) return;
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (!(key in data)) size++;
                        data[key] = value;
                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                        return value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            if (lruEntry === freshEnd) freshEnd = lruEntry.p;
                            if (lruEntry === staleEnd) staleEnd = lruEntry.n;
                            link(lruEntry.n, lruEntry.p);
                            delete lruHash[key];
                        }
                        if (!(key in data)) return;
                        delete data[key];
                        size--;
                    },
                    removeAll: function() {
                        data = createMap();
                        size = 0;
                        lruHash = createMap();
                        freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
                function refresh(entry) {
                    if (entry !== freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd === entry) {
                            staleEnd = entry.n;
                        }
                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }
                function link(nextEntry, prevEntry) {
                    if (nextEntry !== prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry;
                        if (prevEntry) prevEntry.n = nextEntry;
                    }
                }
            }
            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };
            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };
            return cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    var $compileMinErr = minErr("$compile");
    function UNINITIALIZED_VALUE() {}
    var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/;
            var bindings = createMap();
            forEach(scope, function(definition, scopeName) {
                definition = definition.trim();
                if (definition in bindingCache) {
                    bindings[scopeName] = bindingCache[definition];
                    return;
                }
                var match = definition.match(LOCAL_REGEXP);
                if (!match) {
                    throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                }
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: match[2] === "*",
                    optional: match[3] === "?",
                    attrName: match[4] || scopeName
                };
                if (match[4]) {
                    bindingCache[definition] = bindings[scopeName];
                }
            });
            return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope)) {
                if (directive.bindToController === true) {
                    bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                    bindings.isolateScope = {};
                } else {
                    bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                }
            }
            if (isObject(directive.bindToController)) {
                bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
            }
            if (bindings.bindToController && !directive.controller) {
                throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            }
            return bindings;
        }
        function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) {
                throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
            }
            if (name !== name.trim()) {
                throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
            }
        }
        function getDirectiveRequire(directive) {
            var require = directive.require || directive.controller && directive.name;
            if (!isArray(require) && isObject(require)) {
                forEach(require, function(value, key) {
                    var match = value.match(REQUIRE_PREFIX_REGEXP);
                    var name = value.substring(match[0].length);
                    if (!name) require[key] = match[0] + key;
                });
            }
            return require;
        }
        function getDirectiveRestrict(restrict, name) {
            if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
                throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
            }
            return restrict || "EA";
        }
        this.directive = function registerDirective(name, directiveFactory) {
            assertArg(name, "name");
            assertNotHasOwnProperty(name, "directive");
            if (isString(name)) {
                assertValidDirectiveName(name);
                assertArg(directiveFactory, "directiveFactory");
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        forEach(hasDirectives[name], function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                if (isFunction(directive)) {
                                    directive = {
                                        compile: valueFn(directive)
                                    };
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link);
                                }
                                directive.priority = directive.priority || 0;
                                directive.index = index;
                                directive.name = directive.name || name;
                                directive.require = getDirectiveRequire(directive);
                                directive.restrict = getDirectiveRestrict(directive.restrict, name);
                                directive.$$moduleName = directiveFactory.$$moduleName;
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                        return directives;
                    } ]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };
        this.component = function registerComponent(name, options) {
            if (!isString(name)) {
                forEach(name, reverseParams(bind(this, registerComponent)));
                return this;
            }
            var controller = options.controller || function() {};
            function factory($injector) {
                function makeInjectable(fn) {
                    if (isFunction(fn) || isArray(fn)) {
                        return function(tElement, tAttrs) {
                            return $injector.invoke(fn, this, {
                                $element: tElement,
                                $attrs: tAttrs
                            });
                        };
                    } else {
                        return fn;
                    }
                }
                var template = !options.template && !options.templateUrl ? "" : options.template;
                var ddo = {
                    controller: controller,
                    controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                    template: makeInjectable(template),
                    templateUrl: makeInjectable(options.templateUrl),
                    transclude: options.transclude,
                    scope: {},
                    bindToController: options.bindings || {},
                    restrict: "E",
                    require: options.require
                };
                forEach(options, function(val, key) {
                    if (key.charAt(0) === "$") ddo[key] = val;
                });
                return ddo;
            }
            forEach(options, function(val, key) {
                if (key.charAt(0) === "$") {
                    factory[key] = val;
                    if (isFunction(controller)) controller[key] = val;
                }
            });
            factory.$inject = [ "$injector" ];
            return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
            }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                return this;
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
            }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
            if (isDefined(enabled)) {
                debugInfoEnabled = enabled;
                return this;
            }
            return debugInfoEnabled;
        };
        var strictComponentBindingsEnabled = false;
        this.strictComponentBindingsEnabled = function(enabled) {
            if (isDefined(enabled)) {
                strictComponentBindingsEnabled = enabled;
                return this;
            }
            return strictComponentBindingsEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
            if (arguments.length) {
                TTL = value;
                return this;
            }
            return TTL;
        };
        var commentDirectivesEnabledConfig = true;
        this.commentDirectivesEnabled = function(value) {
            if (arguments.length) {
                commentDirectivesEnabledConfig = value;
                return this;
            }
            return commentDirectivesEnabledConfig;
        };
        var cssClassDirectivesEnabledConfig = true;
        this.cssClassDirectivesEnabled = function(value) {
            if (arguments.length) {
                cssClassDirectivesEnabledConfig = value;
                return this;
            }
            return cssClassDirectivesEnabledConfig;
        };
        var PROP_CONTEXTS = createMap();
        this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
            var key = elementName.toLowerCase() + "|" + propertyName.toLowerCase();
            if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) {
                throw $compileMinErr("ctxoverride", "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.", elementName, propertyName, PROP_CONTEXTS[key], ctx);
            }
            PROP_CONTEXTS[key] = ctx;
            return this;
        };
        (function registerNativePropertyContexts() {
            function registerContext(ctx, values) {
                forEach(values, function(v) {
                    PROP_CONTEXTS[v.toLowerCase()] = ctx;
                });
            }
            registerContext(SCE_CONTEXTS.HTML, [ "iframe|srcdoc", "*|innerHTML", "*|outerHTML" ]);
            registerContext(SCE_CONTEXTS.CSS, [ "*|style" ]);
            registerContext(SCE_CONTEXTS.URL, [ "area|href", "area|ping", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "input|src", "ins|cite", "q|cite" ]);
            registerContext(SCE_CONTEXTS.MEDIA_URL, [ "audio|src", "img|src", "img|srcset", "source|src", "source|srcset", "track|src", "video|src", "video|poster" ]);
            registerContext(SCE_CONTEXTS.RESOURCE_URL, [ "*|formAction", "applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "form|action", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src" ]);
        })();
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
            var SIMPLE_ATTR_NAME = /^\w/;
            var specialAttrHolder = window.document.createElement("div");
            var commentDirectivesEnabled = commentDirectivesEnabledConfig;
            var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
            var onChangesTtl = TTL;
            var onChangesQueue;
            function flushOnChangesQueue() {
                try {
                    if (!--onChangesTtl) {
                        onChangesQueue = undefined;
                        throw $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                    }
                    $rootScope.$apply(function() {
                        for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                            try {
                                onChangesQueue[i]();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        onChangesQueue = undefined;
                    });
                } finally {
                    onChangesTtl++;
                }
            }
            function sanitizeSrcset(value, invokeType) {
                if (!value) {
                    return value;
                }
                if (!isString(value)) {
                    throw $compileMinErr("srcset", 'Can\'t pass trusted values to `{0}`: "{1}"', invokeType, value.toString());
                }
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                    var innerIdx = i * 2;
                    result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
                    result += " " + trim(rawUris[innerIdx + 1]);
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $sce.getTrustedMediaUrl(trim(lastTuple[0]));
                if (lastTuple.length === 2) {
                    result += " " + trim(lastTuple[1]);
                }
                return result;
            }
            function Attributes(element, attributesToCopy) {
                if (attributesToCopy) {
                    var keys = Object.keys(attributesToCopy);
                    var i, l, key;
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        this[key] = attributesToCopy[key];
                    }
                } else {
                    this.$attr = {};
                }
                this.$$element = element;
            }
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal);
                    }
                },
                $removeClass: function(classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal);
                    }
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    if (toAdd && toAdd.length) {
                        $animate.addClass(this.$$element, toAdd);
                    }
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    if (toRemove && toRemove.length) {
                        $animate.removeClass(this.$$element, toRemove);
                    }
                },
                $set: function(key, value, writeAttr, attrName) {
                    var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                    if (booleanKey) {
                        this.$$element.prop(key, value);
                        attrName = booleanKey;
                    } else if (aliasedKey) {
                        this[aliasedKey] = value;
                        observer = aliasedKey;
                    }
                    this[key] = value;
                    if (attrName) {
                        this.$attr[key] = attrName;
                    } else {
                        attrName = this.$attr[key];
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-");
                        }
                    }
                    nodeName = nodeName_(this.$$element);
                    if (nodeName === "img" && key === "srcset") {
                        this[key] = value = sanitizeSrcset(value, "$set('srcset', value)");
                    }
                    if (writeAttr !== false) {
                        if (value === null || isUndefined(value)) {
                            this.$$element.removeAttr(attrName);
                        } else {
                            if (SIMPLE_ATTR_NAME.test(attrName)) {
                                if (booleanKey && value === false) {
                                    this.$$element.removeAttr(attrName);
                                } else {
                                    this.$$element.attr(attrName, value);
                                }
                            } else {
                                setSpecialAttr(this.$$element[0], attrName, value);
                            }
                        }
                    }
                    var $$observers = this.$$observers;
                    if ($$observers) {
                        forEach($$observers[observer], function(fn) {
                            try {
                                fn(value);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                    }
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    listeners.push(fn);
                    $rootScope.$evalAsync(function() {
                        if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                            fn(attrs[key]);
                        }
                    });
                    return function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            function setSpecialAttr(element, attrName, value) {
                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                var attributes = specialAttrHolder.firstChild.attributes;
                var attribute = attributes[0];
                attributes.removeNamedItem(attribute.name);
                attribute.value = value;
                element.attributes.setNamedItem(attribute);
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol === "{{" && endSymbol === "}}" ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/;
            var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                var bindings = $element.data("$binding") || [];
                if (isArray(binding)) {
                    bindings = bindings.concat(binding);
                } else {
                    bindings.push(binding);
                }
                $element.data("$binding", bindings);
            } : noop;
            compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                safeAddClass($element, "ng-binding");
            } : noop;
            compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop;
            compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop;
            compile.$$createComment = function(directiveName, comment) {
                var content = "";
                if (debugInfoEnabled) {
                    content = " " + (directiveName || "") + ": ";
                    if (comment) content += comment + " ";
                }
                return window.document.createComment(content);
            };
            return compile;
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes);
                }
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function publicLinkFn(scope, cloneConnectFn, options) {
                    if (!$compileNodes) {
                        throw $compileMinErr("multilink", "This element has already been linked.");
                    }
                    assertArg(scope, "scope");
                    if (previousCompileContext && previousCompileContext.needsNewScope) {
                        scope = scope.$parent.$new();
                    }
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                        parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                    }
                    if (!namespace) {
                        namespace = detectNamespaceForChildElements(futureParentElement);
                    }
                    var $linkNode;
                    if (namespace !== "html") {
                        $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html()));
                    } else if (cloneConnectFn) {
                        $linkNode = JQLitePrototype.clone.call($compileNodes);
                    } else {
                        $linkNode = $compileNodes;
                    }
                    if (transcludeControllers) {
                        for (var controllerName in transcludeControllers) {
                            $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        }
                    }
                    compile.$$addScopeInfo($linkNode, scope);
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                    if (!cloneConnectFn) {
                        $compileNodes = compositeLinkFn = null;
                    }
                    return $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                if (!node) {
                    return "html";
                } else {
                    return nodeName_(node) !== "foreignobject" && toString.call(node).match(/SVG/) ? "svg" : "html";
                }
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes();
                    if (msie === 11) {
                        mergeConsecutiveTextNodes(nodeList, i, notLiveList);
                    }
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        compile.$$addScopeClass(attrs.$$element);
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                    if (nodeLinkFn || childLinkFn) {
                        linkFns.push(i, nodeLinkFn, childLinkFn);
                        linkFnFound = true;
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                    }
                    previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                    var stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        stableNodeList = new Array(nodeListLength);
                        for (i = 0; i < linkFns.length; i += 3) {
                            idx = linkFns[i];
                            stableNodeList[idx] = nodeList[idx];
                        }
                    } else {
                        stableNodeList = nodeList;
                    }
                    for (i = 0, ii = linkFns.length; i < ii; ) {
                        node = stableNodeList[linkFns[i++]];
                        nodeLinkFn = linkFns[i++];
                        childLinkFn = linkFns[i++];
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new();
                                compile.$$addScopeInfo(jqLite(node), childScope);
                            } else {
                                childScope = scope;
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn;
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                            } else {
                                childBoundTranscludeFn = null;
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                        }
                    }
                }
            }
            function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                var node = nodeList[idx];
                var parent = node.parentNode;
                var sibling;
                if (node.nodeType !== NODE_TYPE_TEXT) {
                    return;
                }
                while (true) {
                    sibling = parent ? node.nextSibling : nodeList[idx + 1];
                    if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {
                        break;
                    }
                    node.nodeValue = node.nodeValue + sibling.nodeValue;
                    if (sibling.parentNode) {
                        sibling.parentNode.removeChild(sibling);
                    }
                    if (notLiveList && sibling === nodeList[idx + 1]) {
                        nodeList.splice(idx + 1, 1);
                    }
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    if (!transcludedScope) {
                        transcludedScope = scope.$new(false, containingScope);
                        transcludedScope.$$transcluded = true;
                    }
                    return transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                }
                var boundSlots = boundTranscludeFn.$$slots = createMap();
                for (var slotName in transcludeFn.$$slots) {
                    if (transcludeFn.$$slots[slotName]) {
                        boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                    } else {
                        boundSlots[slotName] = null;
                    }
                }
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, nodeName, className;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node);
                    addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, value, ngPrefixMatch, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = false;
                        var attrEndName = false;
                        var isNgAttr = false, isNgProp = false, isNgEvent = false;
                        var multiElementMatch;
                        attr = nAttrs[j];
                        name = attr.name;
                        value = attr.value;
                        nName = directiveNormalize(name.toLowerCase());
                        if (ngPrefixMatch = nName.match(NG_PREFIX_BINDING)) {
                            isNgAttr = ngPrefixMatch[1] === "Attr";
                            isNgProp = ngPrefixMatch[1] === "Prop";
                            isNgEvent = ngPrefixMatch[1] === "On";
                            name = name.replace(PREFIX_REGEXP, "").toLowerCase().substr(4 + ngPrefixMatch[1].length).replace(/_(.)/g, function(match, letter) {
                                return letter.toUpperCase();
                            });
                        } else if ((multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && directiveIsMultiElement(multiElementMatch[1])) {
                            attrStartName = name;
                            attrEndName = name.substr(0, name.length - 5) + "end";
                            name = name.substr(0, name.length - 6);
                        }
                        if (isNgProp || isNgEvent) {
                            attrs[nName] = value;
                            attrsMap[nName] = attr.name;
                            if (isNgProp) {
                                addPropertyDirective(node, directives, nName, name);
                            } else {
                                addEventDirective(directives, nName, name);
                            }
                        } else {
                            nName = directiveNormalize(name.toLowerCase());
                            attrsMap[nName] = name;
                            if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                attrs[nName] = value;
                                if (getBooleanAttrName(node, nName)) {
                                    attrs[nName] = true;
                                }
                            }
                            addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                            addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                        }
                    }
                    if (nodeName === "input" && node.getAttribute("type") === "hidden") {
                        node.setAttribute("autocomplete", "off");
                    }
                    if (!cssClassDirectivesEnabled) break;
                    className = node.className;
                    if (isObject(className)) {
                        className = className.animVal;
                    }
                    if (isString(className) && className !== "") {
                        while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                            nName = directiveNormalize(match[2]);
                            if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                attrs[nName] = trim(match[3]);
                            }
                            className = className.substr(match.index + match[0].length);
                        }
                    }
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled) break;
                    collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                    break;
                }
                directives.sort(byPriority);
                return directives;
            }
            function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                    var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                    if (match) {
                        var nName = directiveNormalize(match[1]);
                        if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                            attrs[nName] = trim(match[2]);
                        }
                    }
                } catch (e) {}
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [];
                var depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        }
                        if (node.nodeType === NODE_TYPE_ELEMENT) {
                            if (node.hasAttribute(attrStart)) depth++;
                            if (node.hasAttribute(attrEnd)) depth--;
                        }
                        nodes.push(node);
                        node = node.nextSibling;
                    } while (depth > 0);
                } else {
                    nodes.push(node);
                }
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd);
                    return linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                if (eager) {
                    return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                }
                return function lazyCompilation() {
                    if (!compiled) {
                        compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                        $compileNodes = transcludeFn = previousCompileContext = null;
                    }
                    return compiled.apply(this, arguments);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue;
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start;
                    var attrEnd = directive.$$end;
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd);
                    }
                    $template = undefined;
                    if (terminalPriority > directive.priority) {
                        break;
                    }
                    directiveValue = directive.scope;
                    if (directiveValue) {
                        if (!directive.templateUrl) {
                            if (isObject(directiveValue)) {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                newIsolateScopeDirective = directive;
                            } else {
                                assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                            }
                        }
                        newScopeDirective = newScopeDirective || directive;
                    }
                    directiveName = directive.name;
                    if (!didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                        var candidateDirective;
                        for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                            if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                mightHaveMultipleTransclusionError = true;
                                break;
                            }
                        }
                        didScanForMultipleTransclusion = true;
                    }
                    if (!directive.templateUrl && directive.controller) {
                        controllerDirectives = controllerDirectives || createMap();
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                        controllerDirectives[directiveName] = directive;
                    }
                    directiveValue = directive.transclude;
                    if (directiveValue) {
                        hasTranscludeDirective = true;
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                            nonTlbTranscludeDirective = directive;
                        }
                        if (directiveValue === "element") {
                            hasElementTranscludeDirective = true;
                            terminalPriority = directive.priority;
                            $template = $compileNode;
                            $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                            compileNode = $compileNode[0];
                            replaceWith(jqCollection, sliceArgs($template), compileNode);
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            });
                        } else {
                            var slots = createMap();
                            if (!isObject(directiveValue)) {
                                $template = jqLite(jqLiteClone(compileNode)).contents();
                            } else {
                                $template = window.document.createDocumentFragment();
                                var slotMap = createMap();
                                var filledSlots = createMap();
                                forEach(directiveValue, function(elementSelector, slotName) {
                                    var optional = elementSelector.charAt(0) === "?";
                                    elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                                    slotMap[elementSelector] = slotName;
                                    slots[slotName] = null;
                                    filledSlots[slotName] = optional;
                                });
                                forEach($compileNode.contents(), function(node) {
                                    var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                    if (slotName) {
                                        filledSlots[slotName] = true;
                                        slots[slotName] = slots[slotName] || window.document.createDocumentFragment();
                                        slots[slotName].appendChild(node);
                                    } else {
                                        $template.appendChild(node);
                                    }
                                });
                                forEach(filledSlots, function(filled, slotName) {
                                    if (!filled) {
                                        throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                                    }
                                });
                                for (var slotName in slots) {
                                    if (slots[slotName]) {
                                        var slotCompileNodes = jqLite(slots[slotName].childNodes);
                                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn);
                                    }
                                }
                                $template = jqLite($template.childNodes);
                            }
                            $compileNode.empty();
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {
                                needsNewScope: directive.$$isolateScope || directive.$$newScope
                            });
                            childTranscludeFn.$$slots = slots;
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                        directiveValue = denormalizeTemplate(directiveValue);
                        if (directive.replace) {
                            replaceDirective = directive;
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = [];
                            } else {
                                $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                            }
                            compileNode = $template[0];
                            if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            }
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            };
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            if (newIsolateScopeDirective || newScopeDirective) {
                                markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                            ii = directives.length;
                        } else {
                            $compileNode.html(directiveValue);
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true;
                        assertNoDuplicate("template", templateDirective, directive, $compileNode);
                        templateDirective = directive;
                        if (directive.replace) {
                            replaceDirective = directive;
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        });
                        ii = directives.length;
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            var context = directive.$$originalDirective || directive;
                            if (isFunction(linkFn)) {
                                addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                            } else if (linkFn) {
                                addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode));
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true;
                        terminalPriority = Math.max(terminalPriority, directive.priority);
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                nodeLinkFn.templateOnThisElement = hasTemplate;
                nodeLinkFn.transclude = childTranscludeFn;
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return nodeLinkFn;
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                        pre.require = directive.require;
                        pre.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {
                                isolateScope: true
                            });
                        }
                        preLinkFns.push(pre);
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                        post.require = directive.require;
                        post.directiveName = directiveName;
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {
                                isolateScope: true
                            });
                        }
                        postLinkFns.push(post);
                    }
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                    if (compileNode === linkNode) {
                        attrs = templateAttrs;
                        $element = templateAttrs.$$element;
                    } else {
                        $element = jqLite(linkNode);
                        attrs = new Attributes($element, templateAttrs);
                    }
                    controllerScope = scope;
                    if (newIsolateScopeDirective) {
                        isolateScope = scope.$new(true);
                    } else if (newScopeDirective) {
                        controllerScope = scope.$parent;
                    }
                    if (boundTranscludeFn) {
                        transcludeFn = controllersBoundTransclude;
                        transcludeFn.$$boundTransclude = boundTranscludeFn;
                        transcludeFn.isSlotFilled = function(slotName) {
                            return !!boundTranscludeFn.$$slots[slotName];
                        };
                    }
                    if (controllerDirectives) {
                        elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                    }
                    if (newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                        compile.$$addScopeClass($element, true);
                        isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                        scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                        if (scopeBindingInfo.removeWatches) {
                            isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
                        }
                    }
                    for (var name in elementControllers) {
                        var controllerDirective = controllerDirectives[name];
                        var controller = elementControllers[name];
                        var bindings = controllerDirective.$$bindings.bindToController;
                        controller.instance = controller();
                        $element.data("$" + controllerDirective.name + "Controller", controller.instance);
                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                    }
                    forEach(controllerDirectives, function(controllerDirective, name) {
                        var require = controllerDirective.require;
                        if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                            extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                        }
                    });
                    forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$onChanges)) {
                            try {
                                controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (isFunction(controllerInstance.$onInit)) {
                            try {
                                controllerInstance.$onInit();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (isFunction(controllerInstance.$doCheck)) {
                            controllerScope.$watch(function() {
                                controllerInstance.$doCheck();
                            });
                            controllerInstance.$doCheck();
                        }
                        if (isFunction(controllerInstance.$onDestroy)) {
                            controllerScope.$on("$destroy", function callOnDestroyHook() {
                                controllerInstance.$onDestroy();
                            });
                        }
                    });
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        linkFn = preLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    var scopeToChild = scope;
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope;
                    }
                    if (childLinkFn) {
                        childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                    }
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        linkFn = postLinkFns[i];
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    }
                    forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$postLink)) {
                            controllerInstance.$postLink();
                        }
                    });
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        if (!isScope(scope)) {
                            slotName = futureParentElement;
                            futureParentElement = cloneAttachFn;
                            cloneAttachFn = scope;
                            scope = undefined;
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers;
                        }
                        if (!futureParentElement) {
                            futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                        }
                        if (slotName) {
                            var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                            if (slotTranscludeFn) {
                                return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            } else if (isUndefined(slotTranscludeFn)) {
                                throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". ' + "Element: {1}", slotName, startingTag($element));
                            }
                        } else {
                            return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        }
                    }
                }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
                var value;
                if (isString(require)) {
                    var match = require.match(REQUIRE_PREFIX_REGEXP);
                    var name = require.substring(match[0].length);
                    var inheritType = match[1] || match[3];
                    var optional = match[2] === "?";
                    if (inheritType === "^^") {
                        $element = $element.parent();
                    } else {
                        value = elementControllers && elementControllers[name];
                        value = value && value.instance;
                    }
                    if (!value) {
                        var dataName = "$" + name + "Controller";
                        if (inheritType === "^^" && $element[0] && $element[0].nodeType === NODE_TYPE_DOCUMENT) {
                            value = null;
                        } else {
                            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                        }
                    }
                    if (!value && !optional) {
                        throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                    }
                } else if (isArray(require)) {
                    value = [];
                    for (var i = 0, ii = require.length; i < ii; i++) {
                        value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                    }
                } else if (isObject(require)) {
                    value = {};
                    forEach(require, function(controller, property) {
                        value[property] = getControllers(directiveName, controller, $element, elementControllers);
                    });
                }
                return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                for (var controllerKey in controllerDirectives) {
                    var directive = controllerDirectives[controllerKey];
                    var locals = {
                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                        $element: $element,
                        $attrs: attrs,
                        $transclude: transcludeFn
                    };
                    var controller = directive.controller;
                    if (controller === "@") {
                        controller = attrs[directive.name];
                    }
                    var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                    elementControllers[directive.name] = controllerInstance;
                    $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                }
                return elementControllers;
            }
            function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: isolateScope,
                        $$newScope: newScope
                    });
                }
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                            if (startAttrName) {
                                directive = inherit(directive, {
                                    $$start: startAttrName,
                                    $$end: endAttrName
                                });
                            }
                            if (!directive.$$bindings) {
                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                if (isObject(bindings.isolateScope)) {
                                    directive.$$isolateBindings = bindings.isolateScope;
                                }
                            }
                            tDirectives.push(directive);
                            match = directive;
                        }
                    }
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        if (directive.multiElement) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function(value, key) {
                    if (key.charAt(0) !== "$") {
                        if (src[key] && src[key] !== value) {
                            if (value.length) {
                                value += (key === "style" ? ";" : " ") + src[key];
                            } else {
                                value = src[key];
                            }
                        }
                        dst.$set(key, value, true, srcAttr[key]);
                    }
                });
                forEach(src, function(value, key) {
                    if (!dst.hasOwnProperty(key) && key.charAt(0) !== "$") {
                        dst[key] = value;
                        if (key !== "class" && key !== "style") {
                            dstAttr[key] = srcAttr[key];
                        }
                    }
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                $compileNode.empty();
                $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    content = denormalizeTemplate(content);
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = [];
                        } else {
                            $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                        }
                        compileNode = $template[0];
                        if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        }
                        tempTemplateAttrs = {
                            $attr: {}
                        };
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectiveScope(templateDirectives, true);
                        }
                        directives = templateDirectives.concat(directives);
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else {
                        compileNode = beforeTemplateCompileNode;
                        $compileNode.html(content);
                    }
                    directives.unshift(derivedSyncDirective);
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                    forEach($rootElement, function(node, i) {
                        if (node === compileNode) {
                            $rootElement[i] = $compileNode[0];
                        }
                    });
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (scope.$$destroyed) continue;
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode);
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                            safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn;
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                }).catch(function(error) {
                    if (isError(error)) {
                        $exceptionHandler(error);
                    }
                });
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    if (scope.$$destroyed) return;
                    if (linkQueue) {
                        linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                    }
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                if (diff !== 0) return diff;
                if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                return a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                }
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                    directives.push({
                        priority: 0,
                        compile: function textInterpolateCompileFn(templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent();
                                if (!hasCompileParent) compile.$$addBindingClass(parent);
                                compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value;
                                });
                            };
                        }
                    });
                }
            }
            function wrapTemplate(type, template) {
                type = lowercase(type || "html");
                switch (type) {
                  case "svg":
                  case "math":
                    var wrapper = window.document.createElement("div");
                    wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                    return wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedAttrContext(nodeName, attrNormalizedName) {
                if (attrNormalizedName === "srcdoc") {
                    return $sce.HTML;
                }
                if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
                    if ([ "img", "video", "audio", "source", "track" ].indexOf(nodeName) === -1) {
                        return $sce.RESOURCE_URL;
                    }
                    return $sce.MEDIA_URL;
                } else if (attrNormalizedName === "xlinkHref") {
                    if (nodeName === "image") return $sce.MEDIA_URL;
                    if (nodeName === "a") return $sce.URL;
                    return $sce.RESOURCE_URL;
                } else if (nodeName === "form" && attrNormalizedName === "action" || nodeName === "base" && attrNormalizedName === "href" || nodeName === "link" && attrNormalizedName === "href") {
                    return $sce.RESOURCE_URL;
                } else if (nodeName === "a" && (attrNormalizedName === "href" || attrNormalizedName === "ngHref")) {
                    return $sce.URL;
                }
            }
            function getTrustedPropContext(nodeName, propNormalizedName) {
                var prop = propNormalizedName.toLowerCase();
                return PROP_CONTEXTS[nodeName + "|" + prop] || PROP_CONTEXTS["*|" + prop];
            }
            function sanitizeSrcsetPropertyValue(value) {
                return sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset");
            }
            function addPropertyDirective(node, directives, attrName, propName) {
                if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) {
                    throw $compileMinErr("nodomevents", "Property bindings for HTML DOM event properties are disallowed");
                }
                var nodeName = nodeName_(node);
                var trustedContext = getTrustedPropContext(nodeName, propName);
                var sanitizer = identity;
                if (propName === "srcset" && (nodeName === "img" || nodeName === "source")) {
                    sanitizer = sanitizeSrcsetPropertyValue;
                } else if (trustedContext) {
                    sanitizer = $sce.getTrusted.bind($sce, trustedContext);
                }
                directives.push({
                    priority: 100,
                    compile: function ngPropCompileFn(_, attr) {
                        var ngPropGetter = $parse(attr[attrName]);
                        var ngPropWatch = $parse(attr[attrName], function sceValueOf(val) {
                            return $sce.valueOf(val);
                        });
                        return {
                            pre: function ngPropPreLinkFn(scope, $element) {
                                function applyPropValue() {
                                    var propValue = ngPropGetter(scope);
                                    $element[0][propName] = sanitizer(propValue);
                                }
                                applyPropValue();
                                scope.$watch(ngPropWatch, applyPropValue);
                            }
                        };
                    }
                });
            }
            function addEventDirective(directives, attrName, eventName) {
                directives.push(createEventDirective($parse, $rootScope, $exceptionHandler, attrName, eventName, false));
            }
            function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                var nodeName = nodeName_(node);
                var trustedContext = getTrustedAttrContext(nodeName, name);
                var mustHaveExpression = !isNgAttr;
                var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
                var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                if (!interpolateFn) return;
                if (name === "multiple" && nodeName === "select") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                }
                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed");
                }
                directives.push({
                    priority: 100,
                    compile: function() {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                var newValue = attr[name];
                                if (newValue !== value) {
                                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                    value = newValue;
                                }
                                if (!interpolateFn) return;
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue !== oldValue) {
                                        attr.$updateClass(newValue, oldValue);
                                    } else {
                                        attr.$set(name, newValue);
                                    }
                                });
                            }
                        };
                    }
                });
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] === firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2];
                                } else {
                                    delete $rootElement[j];
                                }
                            }
                            $rootElement.length -= removeCount - 1;
                            if ($rootElement.context === firstElementToRemove) {
                                $rootElement.context = newNode;
                            }
                            break;
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove);
                }
                var fragment = window.document.createDocumentFragment();
                for (i = 0; i < removeCount; i++) {
                    fragment.appendChild(elementsToRemove[i]);
                }
                if (jqLite.hasData(firstElementToRemove)) {
                    jqLite.data(newNode, jqLite.data(firstElementToRemove));
                    jqLite(firstElementToRemove).off("$destroy");
                }
                jqLite.cleanData(fragment.querySelectorAll("*"));
                for (i = 1; i < removeCount; i++) {
                    delete elementsToRemove[i];
                }
                elementsToRemove[0] = newNode;
                elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function strictBindingsCheck(attrName, directiveName) {
                if (strictComponentBindingsEnabled) {
                    throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                var removeWatchCollection = [];
                var initialChanges = {};
                var changes;
                forEach(bindings, function initializeBinding(definition, scopeName) {
                    var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch;
                    switch (mode) {
                      case "@":
                        if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                            strictBindingsCheck(attrName, directive.name);
                            destination[scopeName] = attrs[attrName] = undefined;
                        }
                        removeWatch = attrs.$observe(attrName, function(value) {
                            if (isString(value) || isBoolean(value)) {
                                var oldValue = destination[scopeName];
                                recordChanges(scopeName, value, oldValue);
                                destination[scopeName] = value;
                            }
                        });
                        attrs.$$observers[attrName].$$scope = scope;
                        lastValue = attrs[attrName];
                        if (isString(lastValue)) {
                            destination[scopeName] = $interpolate(lastValue)(scope);
                        } else if (isBoolean(lastValue)) {
                            destination[scopeName] = lastValue;
                        }
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "=":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            strictBindingsCheck(attrName, directive.name);
                            attrs[attrName] = undefined;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]);
                        if (parentGet.literal) {
                            compare = equals;
                        } else {
                            compare = simpleCompare;
                        }
                        parentSet = parentGet.assign || function() {
                            lastValue = destination[scopeName] = parentGet(scope);
                            throw $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                        };
                        lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function parentValueWatch(parentValue) {
                            if (!compare(parentValue, destination[scopeName])) {
                                if (!compare(parentValue, lastValue)) {
                                    destination[scopeName] = parentValue;
                                } else {
                                    parentSet(scope, parentValue = destination[scopeName]);
                                }
                            }
                            lastValue = parentValue;
                            return lastValue;
                        };
                        parentValueWatch.$stateful = true;
                        if (definition.collection) {
                            removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                        } else {
                            removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                        }
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "<":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            strictBindingsCheck(attrName, directive.name);
                            attrs[attrName] = undefined;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]);
                        var isLiteral = parentGet.literal;
                        var initialValue = destination[scopeName] = parentGet(scope);
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                        removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, function parentValueWatchAction(newValue, oldValue) {
                            if (oldValue === newValue) {
                                if (oldValue === initialValue || isLiteral && equals(oldValue, initialValue)) {
                                    return;
                                }
                                oldValue = initialValue;
                            }
                            recordChanges(scopeName, newValue, oldValue);
                            destination[scopeName] = newValue;
                        });
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "&":
                        if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                            strictBindingsCheck(attrName, directive.name);
                        }
                        parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                        if (parentGet === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                        break;
                    }
                });
                function recordChanges(key, currentValue, previousValue) {
                    if (isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue)) {
                        if (!onChangesQueue) {
                            scope.$$postDigest(flushOnChangesQueue);
                            onChangesQueue = [];
                        }
                        if (!changes) {
                            changes = {};
                            onChangesQueue.push(triggerOnChangesHook);
                        }
                        if (changes[key]) {
                            previousValue = changes[key].previousValue;
                        }
                        changes[key] = new SimpleChange(previousValue, currentValue);
                    }
                }
                function triggerOnChangesHook() {
                    destination.$onChanges(changes);
                    changes = undefined;
                }
                return {
                    initialChanges: initialChanges,
                    removeWatches: removeWatchCollection.length && function removeWatches() {
                        for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                            removeWatchCollection[i]();
                        }
                    }
                };
            }
        } ];
    }
    function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
    }
    SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
    };
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
    var SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
    function directiveNormalize(name) {
        return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        });
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
                if (token === tokens2[j]) continue outer;
            }
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
            return jqNodes;
        }
        while (i--) {
            var node = jqNodes[i];
            if (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === "") {
                splice.call(jqNodes, i, 1);
            }
        }
        return jqNodes;
    }
    var $controllerMinErr = minErr("$controller");
    var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {};
        this.has = function(name) {
            return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller");
            if (isObject(name)) {
                extend(controllers, name);
            } else {
                controllers[name] = constructor;
            }
        };
        this.$get = [ "$injector", function($injector) {
            return function $controller(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                later = later === true;
                if (ident && isString(ident)) {
                    identifier = ident;
                }
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG);
                    if (!match) {
                        throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
                    }
                    constructor = match[1];
                    identifier = identifier || match[3];
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true);
                    if (!expression) {
                        throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                    }
                    assertArgFn(expression, constructor, true);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null);
                    if (identifier) {
                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                    }
                    return extend(function $controllerInit() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        if (result !== instance && (isObject(result) || isFunction(result))) {
                            instance = result;
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                        }
                        return instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                instance = $injector.instantiate(expression, locals, constructor);
                if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
                return instance;
            };
            function addIdentifier(locals, identifier, instance, name) {
                if (!(locals && isObject(locals.$scope))) {
                    throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                }
                locals.$scope[identifier] = instance;
            }
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $$IsDocumentHiddenProvider() {
        this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
            var doc = $document[0];
            var hidden = doc && doc.hidden;
            $document.on("visibilitychange", changeListener);
            $rootScope.$on("$destroy", function() {
                $document.off("visibilitychange", changeListener);
            });
            function changeListener() {
                hidden = doc.hidden;
            }
            return function() {
                return hidden;
            };
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    var $$ForceReflowProvider = function() {
        this.$get = [ "$document", function($document) {
            return function(domNode) {
                if (domNode) {
                    if (!domNode.nodeType && domNode instanceof jqLite) {
                        domNode = domNode[0];
                    }
                } else {
                    domNode = $document[0].body;
                }
                return domNode.offsetWidth + 1;
            };
        } ];
    };
    var APPLICATION_JSON = "application/json";
    var CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    };
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    };
    var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
    var $httpMinErr = minErr("$http");
    function serializeValue(v) {
        if (isObject(v)) {
            return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function ngParamSerializer(params) {
                if (!params) return "";
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value === null || isUndefined(value) || isFunction(value)) return;
                    if (isArray(value)) {
                        forEach(value, function(v) {
                            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                        });
                    } else {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value)));
                    }
                });
                return parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function jQueryLikeParamSerializer(params) {
                if (!params) return "";
                var parts = [];
                serialize(params, "", true);
                return parts.join("&");
                function serialize(toSerialize, prefix, topLevel) {
                    if (isArray(toSerialize)) {
                        forEach(toSerialize, function(value, index) {
                            serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                        });
                    } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                        forEachSorted(toSerialize, function(value, key) {
                            serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                        });
                    } else {
                        if (isFunction(toSerialize)) {
                            toSerialize = toSerialize();
                        }
                        parts.push(encodeUriQuery(prefix) + "=" + (toSerialize == null ? "" : encodeUriQuery(serializeValue(toSerialize))));
                    }
                }
            };
        };
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                var hasJsonContentType = contentType && contentType.indexOf(APPLICATION_JSON) === 0;
                if (hasJsonContentType || isJsonLike(tempData)) {
                    try {
                        data = fromJson(tempData);
                    } catch (e) {
                        if (!hasJsonContentType) {
                            return data;
                        }
                        throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". ' + 'Parse error: "{1}"', data, e);
                    }
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        var parsed = createMap(), i;
        function fillInParsed(key, val) {
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
        }
        if (isString(headers)) {
            forEach(headers.split("\n"), function(line) {
                i = line.indexOf(":");
                fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
            });
        } else if (isObject(headers)) {
            forEach(headers, function(headerVal, headerKey) {
                fillInParsed(lowercase(headerKey), trim(headerVal));
            });
        }
        return parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (!headersObj) headersObj = parseHeaders(headers);
            if (name) {
                var value = headersObj[lowercase(name)];
                if (value === undefined) {
                    value = null;
                }
                return value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
            return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
            data = fn(data, headers, status);
        });
        return data;
    }
    function isSuccess(status) {
        return 200 <= status && status < 300;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer",
            jsonpCallbackParam: "callback"
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
            if (isDefined(value)) {
                useApplyAsync = !!value;
                return this;
            }
            return useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [];
        var xsrfWhitelistedOrigins = this.xsrfWhitelistedOrigins = [];
        this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            var urlIsAllowedOrigin = urlIsAllowedOriginFactory(xsrfWhitelistedOrigins);
            function $http(requestConfig) {
                if (!isObject(requestConfig)) {
                    throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                }
                if (!isString($sce.valueOf(requestConfig.url))) {
                    throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                }
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer,
                    jsonpCallbackParam: defaults.jsonpCallbackParam
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig);
                config.method = uppercase(config.method);
                config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                $browser.$$incOutstandingRequestCount("$http");
                var requestInterceptors = [];
                var responseInterceptors = [];
                var promise = $q.resolve(config);
                forEach(reversedInterceptors, function(interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        requestInterceptors.unshift(interceptor.request, interceptor.requestError);
                    }
                    if (interceptor.response || interceptor.responseError) {
                        responseInterceptors.push(interceptor.response, interceptor.responseError);
                    }
                });
                promise = chainInterceptors(promise, requestInterceptors);
                promise = promise.then(serverRequest);
                promise = chainInterceptors(promise, responseInterceptors);
                promise = promise.finally(completeOutstandingRequest);
                return promise;
                function chainInterceptors(promise, interceptors) {
                    for (var i = 0, ii = interceptors.length; i < ii; ) {
                        var thenFn = interceptors[i++];
                        var rejectFn = interceptors[i++];
                        promise = promise.then(thenFn, rejectFn);
                    }
                    interceptors.length = 0;
                    return promise;
                }
                function completeOutstandingRequest() {
                    $browser.$$completeOutstandingRequest(noop, "$http");
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    forEach(headers, function(headerFn, header) {
                        if (isFunction(headerFn)) {
                            headerContent = headerFn(config);
                            if (headerContent != null) {
                                processedHeaders[header] = headerContent;
                            }
                        } else {
                            processedHeaders[header] = headerFn;
                        }
                    });
                    return processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration;
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
                function serverRequest(config) {
                    var headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    if (isUndefined(reqData)) {
                        forEach(headers, function(value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header];
                            }
                        });
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials;
                    }
                    return sendReq(config, reqData).then(transformResponse, transformResponse);
                }
                function transformResponse(response) {
                    var resp = extend({}, response);
                    resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head", "jsonp");
            createShortMethodsWithData("post", "put", "patch");
            $http.defaults = defaults;
            return $http;
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, isJsonp = lowercase(config.method) === "jsonp", url = config.url;
                if (isJsonp) {
                    url = $sce.getTrustedResourceUrl(url);
                } else if (!isString(url)) {
                    url = $sce.valueOf(url);
                }
                url = buildUrl(url, config.paramSerializer(config.params));
                if (isJsonp) {
                    url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam);
                }
                $http.pendingRequests.push(config);
                promise.then(removePendingReq, removePendingReq);
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                }
                if (cache) {
                    cachedResp = cache.get(url);
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]);
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK", "complete");
                            }
                        }
                    } else {
                        cache.put(url, promise);
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsAllowedOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                }
                return promise;
                function createApplyHandlers(eventHandlers) {
                    if (eventHandlers) {
                        var applyHandlers = {};
                        forEach(eventHandlers, function(eventHandler, key) {
                            applyHandlers[key] = function(event) {
                                if (useApplyAsync) {
                                    $rootScope.$applyAsync(callEventHandler);
                                } else if ($rootScope.$$phase) {
                                    callEventHandler();
                                } else {
                                    $rootScope.$apply(callEventHandler);
                                }
                                function callEventHandler() {
                                    eventHandler(event);
                                }
                            };
                        });
                        return applyHandlers;
                    }
                }
                function done(status, response, headersString, statusText, xhrStatus) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [ status, response, parseHeaders(headersString), statusText, xhrStatus ]);
                        } else {
                            cache.remove(url);
                        }
                    }
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText, xhrStatus);
                    }
                    if (useApplyAsync) {
                        $rootScope.$applyAsync(resolveHttpPromise);
                    } else {
                        resolveHttpPromise();
                        if (!$rootScope.$$phase) $rootScope.$apply();
                    }
                }
                function resolvePromise(response, status, headers, statusText, xhrStatus) {
                    status = status >= -1 ? status : 0;
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText,
                        xhrStatus: xhrStatus
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                }
            }
            function buildUrl(url, serializedParams) {
                if (serializedParams.length > 0) {
                    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
                }
                return url;
            }
            function sanitizeJsonpCallbackParam(url, cbKey) {
                var parts = url.split("?");
                if (parts.length > 2) {
                    throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                }
                var params = parseKeyValue(parts[1]);
                forEach(params, function(value, key) {
                    if (value === "JSON_CALLBACK") {
                        throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                    }
                    if (key === cbKey) {
                        throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                    }
                });
                url += (url.indexOf("?") === -1 ? "?" : "&") + cbKey + "=JSON_CALLBACK";
                return url;
            }
        } ];
    }
    function $xhrFactoryProvider() {
        this.$get = function() {
            return function createXhr() {
                return new window.XMLHttpRequest();
            };
        };
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
            url = url || $browser.url();
            if (lowercase(method) === "jsonp") {
                var callbackPath = callbacks.createCallback(url);
                var jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                    var response = status === 200 && callbacks.getResponse(callbackPath);
                    completeRequest(callback, status, response, "", text, "complete");
                    callbacks.removeCallback(callbackPath);
                });
            } else {
                var xhr = createXhr(method, url);
                var abortedByTimeout = false;
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value);
                    }
                });
                xhr.onload = function requestLoaded() {
                    var statusText = xhr.statusText || "";
                    var response = "response" in xhr ? xhr.response : xhr.responseText;
                    var status = xhr.status === 1223 ? 204 : xhr.status;
                    if (status === 0) {
                        status = response ? 200 : urlResolve(url).protocol === "file" ? 404 : 0;
                    }
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete");
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "", "error");
                };
                var requestAborted = function() {
                    completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort");
                };
                var requestTimeout = function() {
                    completeRequest(callback, -1, null, null, "", "timeout");
                };
                xhr.onerror = requestError;
                xhr.ontimeout = requestTimeout;
                xhr.onabort = requestAborted;
                forEach(eventHandlers, function(value, key) {
                    xhr.addEventListener(key, value);
                });
                forEach(uploadEventHandlers, function(value, key) {
                    xhr.upload.addEventListener(key, value);
                });
                if (withCredentials) {
                    xhr.withCredentials = true;
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType;
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e;
                        }
                    }
                }
                xhr.send(isUndefined(post) ? null : post);
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(function() {
                    timeoutRequest("timeout");
                }, timeout);
            } else if (isPromiseLike(timeout)) {
                timeout.then(function() {
                    timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort");
                });
            }
            function timeoutRequest(reason) {
                abortedByTimeout = reason === "timeout";
                if (jsonpDone) {
                    jsonpDone();
                }
                if (xhr) {
                    xhr.abort();
                }
            }
            function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                if (isDefined(timeoutId)) {
                    $browserDefer.cancel(timeoutId);
                }
                jsonpDone = xhr = null;
                callback(status, response, headersString, statusText, xhrStatus);
            }
        };
        function jsonpReq(url, callbackPath, done) {
            url = url.replace("JSON_CALLBACK", callbackPath);
            var script = rawDocument.createElement("script"), callback = null;
            script.type = "text/javascript";
            script.src = url;
            script.async = true;
            callback = function(event) {
                script.removeEventListener("load", callback);
                script.removeEventListener("error", callback);
                rawDocument.body.removeChild(script);
                script = null;
                var status = -1;
                var text = "unknown";
                if (event) {
                    if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
                        event = {
                            type: "error"
                        };
                    }
                    text = event.type;
                    status = event.type === "error" ? 404 : 200;
                }
                if (done) {
                    done(status, text);
                }
            };
            script.addEventListener("load", callback);
            script.addEventListener("error", callback);
            rawDocument.body.appendChild(script);
            return callback;
        }
    }
    var $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
    };
    $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    function $InterpolateProvider() {
        var startSymbol = "{{";
        var endSymbol = "}}";
        this.startSymbol = function(value) {
            if (value) {
                startSymbol = value;
                return this;
            }
            return startSymbol;
        };
        this.endSymbol = function(value) {
            if (value) {
                endSymbol = value;
                return this;
            }
            return endSymbol;
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                var unwatch = scope.$watch(function constantInterpolateWatch(scope) {
                    unwatch();
                    return constantInterp(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
                if (!text.length || text.indexOf(startSymbol) === -1) {
                    if (mustHaveExpression) return;
                    var unescapedText = unescapeText(text);
                    if (contextAllowsConcatenation) {
                        unescapedText = $sce.getTrusted(trustedContext, unescapedText);
                    }
                    var constantInterp = valueFn(unescapedText);
                    constantInterp.exp = text;
                    constantInterp.expressions = [];
                    constantInterp.$$watchDelegate = constantWatchDelegate;
                    return constantInterp;
                }
                allOrNothing = !!allOrNothing;
                var startIndex, endIndex, index = 0, expressions = [], parseFns, textLength = text.length, exp, concat = [], expressionPositions = [], singleExpression;
                while (index < textLength) {
                    if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {
                        if (index !== startIndex) {
                            concat.push(unescapeText(text.substring(index, startIndex)));
                        }
                        exp = text.substring(startIndex + startSymbolLength, endIndex);
                        expressions.push(exp);
                        index = endIndex + endSymbolLength;
                        expressionPositions.push(concat.length);
                        concat.push("");
                    } else {
                        if (index !== textLength) {
                            concat.push(unescapeText(text.substring(index)));
                        }
                        break;
                    }
                }
                singleExpression = concat.length === 1 && expressionPositions.length === 1;
                var interceptor = contextAllowsConcatenation && singleExpression ? undefined : parseStringifyInterceptor;
                parseFns = expressions.map(function(exp) {
                    return $parse(exp, interceptor);
                });
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        if (contextAllowsConcatenation) {
                            return $sce.getTrusted(trustedContext, singleExpression ? concat[0] : concat.join(""));
                        } else if (trustedContext && concat.length > 1) {
                            $interpolateMinErr.throwNoconcat(text);
                        }
                        return concat.join("");
                    };
                    return extend(function interpolationFn(context) {
                        var i = 0;
                        var ii = expressions.length;
                        var values = new Array(ii);
                        try {
                            for (;i < ii; i++) {
                                values[i] = parseFns[i](context);
                            }
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                var currValue = compute(values);
                                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                lastValue = currValue;
                            });
                        }
                    });
                }
                function parseStringifyInterceptor(value) {
                    try {
                        value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                        return allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
            }
            $interpolate.startSymbol = function() {
                return startSymbol;
            };
            $interpolate.endSymbol = function() {
                return endSymbol;
            };
            return $interpolate;
        } ];
    }
    var $intervalMinErr = minErr("$interval");
    function $IntervalProvider() {
        this.$get = [ "$$intervalFactory", "$window", function($$intervalFactory, $window) {
            var intervals = {};
            var setIntervalFn = function(tick, delay, deferred) {
                var id = $window.setInterval(tick, delay);
                intervals[id] = deferred;
                return id;
            };
            var clearIntervalFn = function(id) {
                $window.clearInterval(id);
                delete intervals[id];
            };
            var interval = $$intervalFactory(setIntervalFn, clearIntervalFn);
            interval.cancel = function(promise) {
                if (!promise) return false;
                if (!promise.hasOwnProperty("$$intervalId")) {
                    throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                }
                if (!intervals.hasOwnProperty(promise.$$intervalId)) return false;
                var id = promise.$$intervalId;
                var deferred = intervals[id];
                markQExceptionHandled(deferred.promise);
                deferred.reject("canceled");
                clearIntervalFn(id);
                return true;
            };
            return interval;
        } ];
    }
    function $$IntervalFactoryProvider() {
        this.$get = [ "$browser", "$q", "$$q", "$rootScope", function($browser, $q, $$q, $rootScope) {
            return function intervalFactory(setIntervalFn, clearIntervalFn) {
                return function intervalFn(fn, delay, count, invokeApply) {
                    var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                    count = isDefined(count) ? count : 0;
                    function callback() {
                        if (!hasParams) {
                            fn(iteration);
                        } else {
                            fn.apply(null, args);
                        }
                    }
                    function tick() {
                        if (skipApply) {
                            $browser.defer(callback);
                        } else {
                            $rootScope.$evalAsync(callback);
                        }
                        deferred.notify(iteration++);
                        if (count > 0 && iteration >= count) {
                            deferred.resolve(iteration);
                            clearIntervalFn(promise.$$intervalId);
                        }
                        if (!skipApply) $rootScope.$apply();
                    }
                    promise.$$intervalId = setIntervalFn(tick, delay, deferred, skipApply);
                    return promise;
                };
            };
        } ];
    }
    var $jsonpCallbacksProvider = function() {
        this.$get = function() {
            var callbacks = angular.callbacks;
            var callbackMap = {};
            function createCallback(callbackId) {
                var callback = function(data) {
                    callback.data = data;
                    callback.called = true;
                };
                callback.id = callbackId;
                return callback;
            }
            return {
                createCallback: function(url) {
                    var callbackId = "_" + (callbacks.$$counter++).toString(36);
                    var callbackPath = "angular.callbacks." + callbackId;
                    var callback = createCallback(callbackId);
                    callbackMap[callbackPath] = callbacks[callbackId] = callback;
                    return callbackPath;
                },
                wasCalled: function(callbackPath) {
                    return callbackMap[callbackPath].called;
                },
                getResponse: function(callbackPath) {
                    return callbackMap[callbackPath].data;
                },
                removeCallback: function(callbackPath) {
                    var callback = callbackMap[callbackPath];
                    delete callbacks[callback.id];
                    delete callbackMap[callbackPath];
                }
            };
        };
    };
    var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    };
    var $locationMinErr = minErr("$location");
    function encodePath(path) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
        }
        return segments.join("/");
    }
    function decodePath(path, html5Mode) {
        var segments = path.split("/"), i = segments.length;
        while (i--) {
            segments[i] = decodeURIComponent(segments[i]);
            if (html5Mode) {
                segments[i] = segments[i].replace(/\//g, "%2F");
            }
        }
        return segments.join("/");
    }
    function normalizePath(pathValue, searchValue, hashValue) {
        var search = toKeyValue(searchValue), hash = hashValue ? "#" + encodeUriSegment(hashValue) : "", path = encodePath(pathValue);
        return path + (search ? "?" + search : "") + hash;
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    var DOUBLE_SLASH_REGEX = /^\s*[\\\/]{2,}/;
    function parseAppUrl(url, locationObj, html5Mode) {
        if (DOUBLE_SLASH_REGEX.test(url)) {
            throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
        }
        var prefixed = url.charAt(0) !== "/";
        if (prefixed) {
            url = "/" + url;
        }
        var match = urlResolve(url);
        var path = prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname;
        locationObj.$$path = decodePath(path, html5Mode);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) !== "/") {
            locationObj.$$path = "/" + locationObj.$$path;
        }
    }
    function startsWith(str, search) {
        return str.slice(0, search.length) === search;
    }
    function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
            return url.substr(base.length);
        }
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return index === -1 ? url : url.substr(0, index);
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || "";
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            }
            parseAppUrl(pathUrl, this, true);
            if (!this.$$path) {
                this.$$path = "/";
            }
            this.$$compose();
        };
        this.$$normalizeUrl = function(url) {
            return appBaseNoFile + url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var appUrl, prevAppUrl;
            var rewrittenUrl;
            if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
                prevAppUrl = appUrl;
                if (basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
                    rewrittenUrl = appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
                } else {
                    rewrittenUrl = appBase + prevAppUrl;
                }
            } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
                rewrittenUrl = appBaseNoFile + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
            var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
            var withoutHashUrl;
            if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
                withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
                if (isUndefined(withoutHashUrl)) {
                    withoutHashUrl = withoutBaseUrl;
                }
            } else {
                if (this.$$html5) {
                    withoutHashUrl = withoutBaseUrl;
                } else {
                    withoutHashUrl = "";
                    if (isUndefined(withoutBaseUrl)) {
                        appBase = url;
                        this.replace();
                    }
                }
            }
            parseAppUrl(withoutHashUrl, this, false);
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
            this.$$compose();
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                var firstPathSegmentMatch;
                if (startsWith(url, base)) {
                    url = url.replace(base, "");
                }
                if (windowsFilePathExp.exec(url)) {
                    return path;
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path);
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            }
        };
        this.$$normalizeUrl = function(url) {
            return appBase + (url ? hashPrefix + url : "");
        };
        this.$$parseLinkUrl = function(url, relHref) {
            if (stripHash(appBase) === stripHash(url)) {
                this.$$parse(url);
                return true;
            }
            return false;
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && relHref[0] === "#") {
                this.hash(relHref.slice(1));
                return true;
            }
            var rewrittenUrl;
            var appUrl;
            if (appBase === stripHash(url)) {
                rewrittenUrl = url;
            } else if (appUrl = stripBaseUrl(appBaseNoFile, url)) {
                rewrittenUrl = appBase + hashPrefix + appUrl;
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile;
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
        };
        this.$$normalizeUrl = function(url) {
            return appBase + hashPrefix + url;
        };
    }
    var locationPrototype = {
        $$absUrl: "",
        $$html5: false,
        $$replace: false,
        $$compose: function() {
            this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash);
            this.$$absUrl = this.$$normalizeUrl(this.$$url);
            this.$$urlUpdatedByLocation = true;
        },
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) {
                return this.$$url;
            }
            var match = PATH_MATCH.exec(url);
            if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1] || url === "") this.search(match[3] || "");
            this.hash(match[5] || "");
            return this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            path = path !== null ? path.toString() : "";
            return path.charAt(0) === "/" ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) {
                    search = search.toString();
                    this.$$search = parseKeyValue(search);
                } else if (isObject(search)) {
                    search = copy(search, {});
                    forEach(search, function(value, key) {
                        if (value == null) delete search[key];
                    });
                    this.$$search = search;
                } else {
                    throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                }
                break;

              default:
                if (isUndefined(paramValue) || paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = paramValue;
                }
            }
            this.$$compose();
            return this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return hash !== null ? hash.toString() : "";
        }),
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
            if (!arguments.length) {
                return this.$$state;
            }
            if (Location !== LocationHtml5Url || !this.$$html5) {
                throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
            }
            this.$$state = isUndefined(state) ? null : state;
            this.$$urlUpdatedByLocation = true;
            return this;
        };
    });
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value)) {
                return this[property];
            }
            this[property] = preprocess(value);
            this.$$compose();
            return this;
        };
    }
    function $LocationProvider() {
        var hashPrefix = "!", html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
        };
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        };
        this.html5Mode = function(mode) {
            if (isBoolean(mode)) {
                html5Mode.enabled = mode;
                return this;
            } else if (isObject(mode)) {
                if (isBoolean(mode.enabled)) {
                    html5Mode.enabled = mode.enabled;
                }
                if (isBoolean(mode.requireBase)) {
                    html5Mode.requireBase = mode.requireBase;
                }
                if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
                    html5Mode.rewriteLinks = mode.rewriteLinks;
                }
                return this;
            } else {
                return html5Mode;
            }
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) {
                    throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                }
                appBase = serverBase(initialUrl) + (baseHref || "/");
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else {
                appBase = stripHash(initialUrl);
                LocationMode = LocationHashbangUrl;
            }
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
            $location.$$parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            function urlsEqual(a, b) {
                return a === b || urlResolve(a).href === urlResolve(b).href;
            }
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url();
                var oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state);
                    $location.$$state = $browser.state();
                } catch (e) {
                    $location.url(oldUrl);
                    $location.$$state = oldState;
                    throw e;
                }
            }
            $rootElement.on("click", function(event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2) return;
                var elm = jqLite(event.target);
                while (nodeName_(elm[0]) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                }
                if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks))) return;
                var absHref = elm.prop("href");
                var relHref = elm.attr("href") || elm.attr("xlink:href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault();
                        if ($location.absUrl() !== $browser.url()) {
                            $rootScope.$apply();
                        }
                    }
                }
            });
            if ($location.absUrl() !== initialUrl) {
                $browser.url($location.absUrl(), true);
            }
            var initializing = true;
            $browser.onUrlChange(function(newUrl, newState) {
                if (!startsWith(newUrl, appBaseNoFile)) {
                    $window.location.href = newUrl;
                    return;
                }
                $rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    var oldState = $location.$$state;
                    var defaultPrevented;
                    $location.$$parse(newUrl);
                    $location.$$state = newState;
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                    if ($location.absUrl() !== newUrl) return;
                    if (defaultPrevented) {
                        $location.$$parse(oldUrl);
                        $location.$$state = oldState;
                        setBrowserUrlWithFallback(oldUrl, false, oldState);
                    } else {
                        initializing = false;
                        afterLocationChange(oldUrl, oldState);
                    }
                });
                if (!$rootScope.$$phase) $rootScope.$digest();
            });
            $rootScope.$watch(function $locationWatch() {
                if (initializing || $location.$$urlUpdatedByLocation) {
                    $location.$$urlUpdatedByLocation = false;
                    var oldUrl = $browser.url();
                    var newUrl = $location.absUrl();
                    var oldState = $browser.state();
                    var currentReplace = $location.$$replace;
                    var urlOrStateChanged = !urlsEqual(oldUrl, newUrl) || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                    if (initializing || urlOrStateChanged) {
                        initializing = false;
                        $rootScope.$evalAsync(function() {
                            var newUrl = $location.absUrl();
                            var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                            if ($location.absUrl() !== newUrl) return;
                            if (defaultPrevented) {
                                $location.$$parse(oldUrl);
                                $location.$$state = oldState;
                            } else {
                                if (urlOrStateChanged) {
                                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                                }
                                afterLocationChange(oldUrl, oldState);
                            }
                        });
                    }
                }
                $location.$$replace = false;
            });
            return $location;
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
        } ];
    }
    function $LogProvider() {
        var debug = true, self = this;
        this.debugEnabled = function(flag) {
            if (isDefined(flag)) {
                debug = flag;
                return this;
            } else {
                return debug;
            }
        };
        this.$get = [ "$window", function($window) {
            var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        if (debug) {
                            fn.apply(self, arguments);
                        }
                    };
                }()
            };
            function formatError(arg) {
                if (isError(arg)) {
                    if (arg.stack && formatStackTrace) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                    }
                }
                return arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop;
                return function() {
                    var args = [];
                    forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    });
                    return Function.prototype.apply.call(logFn, console, args);
                };
            }
        } ];
    }
    var $parseMinErr = minErr("$parse");
    var objectValueOf = {}.constructor.prototype.valueOf;
    function getStringValue(name) {
        return name + "";
    }
    var OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = true;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "\t",
        v: "\v",
        "'": "'",
        '"': '"'
    };
    var Lexer = function Lexer(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            this.text = text;
            this.index = 0;
            this.tokens = [];
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                if (ch === '"' || ch === "'") {
                    this.readString(ch);
                } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                    this.readNumber();
                } else if (this.isIdentifierStart(this.peekMultichar())) {
                    this.readIdent();
                } else if (this.is(ch, "(){}[].,;:?")) {
                    this.tokens.push({
                        index: this.index,
                        text: ch
                    });
                    this.index++;
                } else if (this.isWhitespace(ch)) {
                    this.index++;
                } else {
                    var ch2 = ch + this.peek();
                    var ch3 = ch2 + this.peek(2);
                    var op1 = OPERATORS[ch];
                    var op2 = OPERATORS[ch2];
                    var op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: true
                        });
                        this.index += token.length;
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1);
                    }
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && typeof ch === "string";
        },
        isWhitespace: function(ch) {
            return ch === " " || ch === "\r" || ch === "\t" || ch === "\n" || ch === "\v" || ch === "";
        },
        isIdentifierStart: function(ch) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
        },
        isIdentifierContinue: function(ch) {
            return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
            return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
            if (ch.length === 1) return ch.charCodeAt(0);
            return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
        },
        peekMultichar: function() {
            var ch = this.text.charAt(this.index);
            var peek = this.peek();
            if (!peek) {
                return ch;
            }
            var cp1 = ch.charCodeAt(0);
            var cp2 = peek.charCodeAt(0);
            if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
                return ch + peek;
            }
            return ch;
        },
        isExpOperator: function(ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            var number = "";
            var start = this.index;
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index));
                if (ch === "." || this.isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = this.peek();
                    if (ch === "e" && this.isExpOperator(peekCh)) {
                        number += ch;
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === "e") {
                        number += ch;
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === "e") {
                        this.throwError("Invalid exponent");
                    } else {
                        break;
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: true,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            this.index += this.peekMultichar().length;
            while (this.index < this.text.length) {
                var ch = this.peekMultichar();
                if (!this.isIdentifierContinue(ch)) {
                    break;
                }
                this.index += ch.length;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: true
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index);
                rawString += ch;
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        if (!hex.match(/[\da-f]{4}/i)) {
                            this.throwError("Invalid unicode escape [\\u" + hex + "]");
                        }
                        this.index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string = string + (rep || ch);
                    }
                    escape = false;
                } else if (ch === "\\") {
                    escape = true;
                } else if (ch === quote) {
                    this.index++;
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: true,
                        value: string
                    });
                    return;
                } else {
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function AST(lexer, options) {
        this.lexer = lexer;
        this.options = options;
    };
    AST.Program = "Program";
    AST.ExpressionStatement = "ExpressionStatement";
    AST.AssignmentExpression = "AssignmentExpression";
    AST.ConditionalExpression = "ConditionalExpression";
    AST.LogicalExpression = "LogicalExpression";
    AST.BinaryExpression = "BinaryExpression";
    AST.UnaryExpression = "UnaryExpression";
    AST.CallExpression = "CallExpression";
    AST.MemberExpression = "MemberExpression";
    AST.Identifier = "Identifier";
    AST.Literal = "Literal";
    AST.ArrayExpression = "ArrayExpression";
    AST.Property = "Property";
    AST.ObjectExpression = "ObjectExpression";
    AST.ThisExpression = "ThisExpression";
    AST.LocalsExpression = "LocalsExpression";
    AST.NGValueParameter = "NGValueParameter";
    AST.prototype = {
        ast: function(text) {
            this.text = text;
            this.tokens = this.lexer.lex(text);
            var value = this.program();
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0]);
            }
            return value;
        },
        program: function() {
            var body = [];
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) body.push(this.expressionStatement());
                if (!this.expect(";")) {
                    return {
                        type: AST.Program,
                        body: body
                    };
                }
            }
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            var left = this.expression();
            while (this.expect("|")) {
                left = this.filter(left);
            }
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
                if (!isAssignable(result)) {
                    throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                }
                result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                };
            }
            return result;
        },
        ternary: function() {
            var test = this.logicalOR();
            var alternate;
            var consequent;
            if (this.expect("?")) {
                alternate = this.expression();
                if (this.consume(":")) {
                    consequent = this.expression();
                    return {
                        type: AST.ConditionalExpression,
                        test: test,
                        alternate: alternate,
                        consequent: consequent
                    };
                }
            }
            return test;
        },
        logicalOR: function() {
            var left = this.logicalAND();
            while (this.expect("||")) {
                left = {
                    type: AST.LogicalExpression,
                    operator: "||",
                    left: left,
                    right: this.logicalAND()
                };
            }
            return left;
        },
        logicalAND: function() {
            var left = this.equality();
            while (this.expect("&&")) {
                left = {
                    type: AST.LogicalExpression,
                    operator: "&&",
                    left: left,
                    right: this.equality()
                };
            }
            return left;
        },
        equality: function() {
            var left = this.relational();
            var token;
            while (token = this.expect("==", "!=", "===", "!==")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.relational()
                };
            }
            return left;
        },
        relational: function() {
            var left = this.additive();
            var token;
            while (token = this.expect("<", ">", "<=", ">=")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.additive()
                };
            }
            return left;
        },
        additive: function() {
            var left = this.multiplicative();
            var token;
            while (token = this.expect("+", "-")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.multiplicative()
                };
            }
            return left;
        },
        multiplicative: function() {
            var left = this.unary();
            var token;
            while (token = this.expect("*", "/", "%")) {
                left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.unary()
                };
            }
            return left;
        },
        unary: function() {
            var token;
            if (token = this.expect("+", "-", "!")) {
                return {
                    type: AST.UnaryExpression,
                    operator: token.text,
                    prefix: true,
                    argument: this.unary()
                };
            } else {
                return this.primary();
            }
        },
        primary: function() {
            var primary;
            if (this.expect("(")) {
                primary = this.filterChain();
                this.consume(")");
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration();
            } else if (this.expect("{")) {
                primary = this.object();
            } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
                primary = copy(this.selfReferential[this.consume().text]);
            } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
                primary = {
                    type: AST.Literal,
                    value: this.options.literals[this.consume().text]
                };
            } else if (this.peek().identifier) {
                primary = this.identifier();
            } else if (this.peek().constant) {
                primary = this.constant();
            } else {
                this.throwError("not a primary expression", this.peek());
            }
            var next;
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = {
                        type: AST.CallExpression,
                        callee: primary,
                        arguments: this.parseArguments()
                    };
                    this.consume(")");
                } else if (next.text === "[") {
                    primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.expression(),
                        computed: true
                    };
                    this.consume("]");
                } else if (next.text === ".") {
                    primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.identifier(),
                        computed: false
                    };
                } else {
                    this.throwError("IMPOSSIBLE");
                }
            }
            return primary;
        },
        filter: function(baseExpression) {
            var args = [ baseExpression ];
            var result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: true
            };
            while (this.expect(":")) {
                args.push(this.expression());
            }
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (this.peekToken().text !== ")") {
                do {
                    args.push(this.filterChain());
                } while (this.expect(","));
            }
            return args;
        },
        identifier: function() {
            var token = this.consume();
            if (!token.identifier) {
                this.throwError("is not a valid identifier", token);
            }
            return {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break;
                    }
                    elements.push(this.expression());
                } while (this.expect(","));
            }
            this.consume("]");
            return {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var properties = [], property;
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break;
                    }
                    property = {
                        type: AST.Property,
                        kind: "init"
                    };
                    if (this.peek().constant) {
                        property.key = this.constant();
                        property.computed = false;
                        this.consume(":");
                        property.value = this.expression();
                    } else if (this.peek().identifier) {
                        property.key = this.identifier();
                        property.computed = false;
                        if (this.peek(":")) {
                            this.consume(":");
                            property.value = this.expression();
                        } else {
                            property.value = property.key;
                        }
                    } else if (this.peek("[")) {
                        this.consume("[");
                        property.key = this.expression();
                        this.consume("]");
                        property.computed = true;
                        this.consume(":");
                        property.value = this.expression();
                    } else {
                        this.throwError("invalid key", this.peek());
                    }
                    properties.push(property);
                } while (this.expect(","));
            }
            this.consume("}");
            return {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            var token = this.expect(e1);
            if (!token) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
            }
            return token;
        },
        peekToken: function() {
            if (this.tokens.length === 0) {
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            }
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i];
                var t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token;
                }
            }
            return false;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            if (token) {
                this.tokens.shift();
                return token;
            }
            return false;
        },
        selfReferential: {
            this: {
                type: AST.ThisExpression
            },
            $locals: {
                type: AST.LocalsExpression
            }
        }
    };
    function ifDefined(v, d) {
        return typeof v !== "undefined" ? v : d;
    }
    function plusFn(l, r) {
        if (typeof l === "undefined") return r;
        if (typeof r === "undefined") return l;
        return l + r;
    }
    function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
    }
    var PURITY_ABSOLUTE = 1;
    var PURITY_RELATIVE = 2;
    function isPure(node, parentIsPure) {
        switch (node.type) {
          case AST.MemberExpression:
            if (node.computed) {
                return false;
            }
            break;

          case AST.UnaryExpression:
            return PURITY_ABSOLUTE;

          case AST.BinaryExpression:
            return node.operator !== "+" ? PURITY_ABSOLUTE : false;

          case AST.CallExpression:
            return false;
        }
        return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;
    }
    function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
        var allConstants;
        var argsToWatch;
        var isStatelessFilter;
        var astIsPure = ast.isPure = isPure(ast, parentIsPure);
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter, astIsPure);
                allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter, astIsPure);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
            findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
            findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter, astIsPure);
            findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure);
            findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter, astIsPure);
            if (ast.computed) {
                findConstantAndWatchExpressions(ast.property, $filter, astIsPure);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.CallExpression:
            isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
            allConstants = isStatelessFilter;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure);
                allConstants = allConstants && expr.constant;
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            });
            ast.constant = allConstants;
            ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
            findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure);
                allConstants = allConstants && expr.constant;
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter, astIsPure);
                allConstants = allConstants && property.value.constant;
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                if (property.computed) {
                    findConstantAndWatchExpressions(property.key, $filter, false);
                    allConstants = allConstants && property.key.constant;
                    argsToWatch.push.apply(argsToWatch, property.key.toWatch);
                }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;

          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
    }
    function getInputs(body) {
        if (body.length !== 1) return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1) return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
            return {
                type: AST.AssignmentExpression,
                left: ast.body[0].expression,
                right: {
                    type: AST.NGValueParameter
                },
                operator: "="
            };
        }
    }
    function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler($filter) {
        this.$filter = $filter;
    }
    ASTCompiler.prototype = {
        compile: function(ast) {
            var self = this;
            this.state = {
                nextId: 0,
                filters: {},
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            };
            findConstantAndWatchExpressions(ast, self.$filter);
            var extra = "";
            var assignable;
            this.stage = "assign";
            if (assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result);
                this.return_(result);
                extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs";
            forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                };
                self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId);
                self.return_(intoId);
                self.state.inputs.push({
                    name: fnKey,
                    isPure: watch.isPure
                });
                watch.watchId = key;
            });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;";
            var fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
            this.state = this.stage = undefined;
            return fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [];
            var inputs = this.state.inputs;
            var self = this;
            forEach(inputs, function(input) {
                result.push("var " + input.name + "=" + self.generateFunction(input.name, "s"));
                if (input.isPure) {
                    result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";");
                }
            });
            if (inputs.length) {
                result.push("fn.inputs=[" + inputs.map(function(i) {
                    return i.name;
                }).join(",") + "];");
            }
            return result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [];
            var self = this;
            forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            });
            if (parts.length) return "var " + parts.join(",") + ";";
            return "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, self = this, args, expression, computed;
            recursionFn = recursionFn || noop;
            if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                intoId = intoId || this.nextId();
                this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                return;
            }
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, undefined, undefined, function(expr) {
                        right = expr;
                    });
                    if (pos !== ast.body.length - 1) {
                        self.current().body.push(right, ";");
                    } else {
                        self.return_(right);
                    }
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value);
                this.assign(intoId, expression);
                recursionFn(intoId || expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, undefined, undefined, function(expr) {
                    right = expr;
                });
                expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, undefined, undefined, function(expr) {
                    left = expr;
                });
                this.recurse(ast.right, undefined, undefined, function(expr) {
                    right = expr;
                });
                if (ast.operator === "+") {
                    expression = this.plus(left, right);
                } else if (ast.operator === "-") {
                    expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                } else {
                    expression = "(" + left + ")" + ast.operator + "(" + right + ")";
                }
                this.assign(intoId, expression);
                recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId();
                self.recurse(ast.left, intoId);
                self.if_(ast.operator === "&&" ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId();
                self.recurse(ast.test, intoId);
                self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId();
                if (nameId) {
                    nameId.context = self.stage === "inputs" ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s");
                    nameId.computed = false;
                    nameId.name = ast.name;
                }
                self.if_(self.stage === "inputs" || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_(self.stage === "inputs" || "s", function() {
                        if (create && create !== 1) {
                            self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}"));
                        }
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name)));
                recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId();
                intoId = intoId || this.nextId();
                self.recurse(ast.object, left, undefined, function() {
                    self.if_(self.notNull(left), function() {
                        if (ast.computed) {
                            right = self.nextId();
                            self.recurse(ast.property, right);
                            self.getStringValue(right);
                            if (create && create !== 1) {
                                self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}"));
                            }
                            expression = self.computedMember(left, right);
                            self.assign(intoId, expression);
                            if (nameId) {
                                nameId.computed = true;
                                nameId.name = right;
                            }
                        } else {
                            if (create && create !== 1) {
                                self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}"));
                            }
                            expression = self.nonComputedMember(left, ast.property.name);
                            self.assign(intoId, expression);
                            if (nameId) {
                                nameId.computed = false;
                                nameId.name = ast.property.name;
                            }
                        }
                    }, function() {
                        self.assign(intoId, "undefined");
                    });
                    recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId();
                if (ast.filter) {
                    right = self.filter(ast.callee.name);
                    args = [];
                    forEach(ast.arguments, function(expr) {
                        var argument = self.nextId();
                        self.recurse(expr, argument);
                        args.push(argument);
                    });
                    expression = right + "(" + args.join(",") + ")";
                    self.assign(intoId, expression);
                    recursionFn(intoId);
                } else {
                    right = self.nextId();
                    left = {};
                    args = [];
                    self.recurse(ast.callee, right, left, function() {
                        self.if_(self.notNull(right), function() {
                            forEach(ast.arguments, function(expr) {
                                self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function(argument) {
                                    args.push(argument);
                                });
                            });
                            if (left.name) {
                                expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")";
                            } else {
                                expression = right + "(" + args.join(",") + ")";
                            }
                            self.assign(intoId, expression);
                        }, function() {
                            self.assign(intoId, "undefined");
                        });
                        recursionFn(intoId);
                    });
                }
                break;

              case AST.AssignmentExpression:
                right = this.nextId();
                left = {};
                this.recurse(ast.left, undefined, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right);
                        expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                        self.assign(intoId, expression);
                        recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                    self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function(argument) {
                        args.push(argument);
                    });
                });
                expression = "[" + args.join(",") + "]";
                this.assign(intoId, expression);
                recursionFn(intoId || expression);
                break;

              case AST.ObjectExpression:
                args = [];
                computed = false;
                forEach(ast.properties, function(property) {
                    if (property.computed) {
                        computed = true;
                    }
                });
                if (computed) {
                    intoId = intoId || this.nextId();
                    this.assign(intoId, "{}");
                    forEach(ast.properties, function(property) {
                        if (property.computed) {
                            left = self.nextId();
                            self.recurse(property.key, left);
                        } else {
                            left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value;
                        }
                        right = self.nextId();
                        self.recurse(property.value, right);
                        self.assign(self.member(intoId, left, property.computed), right);
                    });
                } else {
                    forEach(ast.properties, function(property) {
                        self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                            args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                        });
                    });
                    expression = "{" + args.join(",") + "}";
                    this.assign(intoId, expression);
                }
                recursionFn(intoId || expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s");
                recursionFn(intoId || "s");
                break;

              case AST.LocalsExpression:
                this.assign(intoId, "l");
                recursionFn(intoId || "l");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v");
                recursionFn(intoId || "v");
                break;
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property;
            var own = this.current().own;
            if (!own.hasOwnProperty(key)) {
                own[key] = this.nextId(false, element + "&&(" + this.escape(property) + " in " + element + ")");
            }
            return own[key];
        },
        assign: function(id, value) {
            if (!id) return;
            this.current().body.push(id, "=", value, ";");
            return id;
        },
        filter: function(filterName) {
            if (!this.state.filters.hasOwnProperty(filterName)) {
                this.state.filters[filterName] = this.nextId(true);
            }
            return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            if (test === true) {
                alternate();
            } else {
                var body = this.current().body;
                body.push("if(", test, "){");
                alternate();
                body.push("}");
                if (consequent) {
                    body.push("else{");
                    consequent();
                    body.push("}");
                }
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        isNull: function(expression) {
            return expression + "==null";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
            var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
            if (SAFE_IDENTIFIER.test(right)) {
                return left + "." + right;
            } else {
                return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
            }
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            if (computed) return this.computedMember(left, right);
            return this.nonComputedMember(left, right);
        },
        getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ")");
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (value === true) return "true";
            if (value === false) return "false";
            if (value === null) return "null";
            if (typeof value === "undefined") return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            if (!skip) {
                this.current().vars.push(id + (init ? "=" + init : ""));
            }
            return id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    };
    function ASTInterpreter($filter) {
        this.$filter = $filter;
    }
    ASTInterpreter.prototype = {
        compile: function(ast) {
            var self = this;
            findConstantAndWatchExpressions(ast, self.$filter);
            var assignable;
            var assign;
            if (assignable = assignableAST(ast)) {
                assign = this.recurse(assignable);
            }
            var toWatch = getInputs(ast.body);
            var inputs;
            if (toWatch) {
                inputs = [];
                forEach(toWatch, function(watch, key) {
                    var input = self.recurse(watch);
                    input.isPure = watch.isPure;
                    watch.input = input;
                    inputs.push(input);
                    watch.watchId = key;
                });
            }
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
                var lastValue;
                forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                });
                return lastValue;
            };
            if (assign) {
                fn.assign = function(scope, value, locals) {
                    return assign(scope, locals, value);
                };
            }
            if (inputs) {
                fn.inputs = inputs;
            }
            return fn;
        },
        recurse: function(ast, context, create) {
            var left, right, self = this, args;
            if (ast.input) {
                return this.inputs(ast.input, ast.watchId);
            }
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                right = this.recurse(ast.argument);
                return this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);

              case AST.LogicalExpression:
                left = this.recurse(ast.left);
                right = this.recurse(ast.right);
                return this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                return self.identifier(ast.name, context, create);

              case AST.MemberExpression:
                left = this.recurse(ast.object, false, !!create);
                if (!ast.computed) {
                    right = ast.property.name;
                }
                if (ast.computed) right = this.recurse(ast.property);
                return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

              case AST.CallExpression:
                args = [];
                forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                });
                if (ast.filter) right = this.$filter(ast.callee.name);
                if (!ast.filter) right = this.recurse(ast.callee, true);
                return ast.filter ? function(scope, locals, assign, inputs) {
                    var values = [];
                    for (var i = 0; i < args.length; ++i) {
                        values.push(args[i](scope, locals, assign, inputs));
                    }
                    var value = right.apply(undefined, values, inputs);
                    return context ? {
                        context: undefined,
                        name: undefined,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var rhs = right(scope, locals, assign, inputs);
                    var value;
                    if (rhs.value != null) {
                        var values = [];
                        for (var i = 0; i < args.length; ++i) {
                            values.push(args[i](scope, locals, assign, inputs));
                        }
                        value = rhs.value.apply(rhs.context, values);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                left = this.recurse(ast.left, true, 1);
                right = this.recurse(ast.right);
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    lhs.context[lhs.name] = rhs;
                    return context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                args = [];
                forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                });
                return function(scope, locals, assign, inputs) {
                    var value = [];
                    for (var i = 0; i < args.length; ++i) {
                        value.push(args[i](scope, locals, assign, inputs));
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                args = [];
                forEach(ast.properties, function(property) {
                    if (property.computed) {
                        args.push({
                            key: self.recurse(property.key),
                            computed: true,
                            value: self.recurse(property.value)
                        });
                    } else {
                        args.push({
                            key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                            computed: false,
                            value: self.recurse(property.value)
                        });
                    }
                });
                return function(scope, locals, assign, inputs) {
                    var value = {};
                    for (var i = 0; i < args.length; ++i) {
                        if (args[i].computed) {
                            value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                        } else {
                            value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                        }
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.LocalsExpression:
                return function(scope, locals) {
                    return context ? {
                        value: locals
                    } : locals;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                if (isDefined(arg)) {
                    arg = +arg;
                } else {
                    arg = 0;
                }
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                if (isDefined(arg)) {
                    arg = -arg;
                } else {
                    arg = -0;
                }
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                var arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: undefined,
                    name: undefined,
                    value: value
                } : value;
            };
        },
        identifier: function(name, context, create) {
            return function(scope, locals, assign, inputs) {
                var base = locals && name in locals ? locals : scope;
                if (create && create !== 1 && base && base[name] == null) {
                    base[name] = {};
                }
                var value = base ? base[name] : undefined;
                if (context) {
                    return {
                        context: base,
                        name: name,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        computedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs;
                var value;
                if (lhs != null) {
                    rhs = right(scope, locals, assign, inputs);
                    rhs = getStringValue(rhs);
                    if (create && create !== 1) {
                        if (lhs && !lhs[rhs]) {
                            lhs[rhs] = {};
                        }
                    }
                    value = lhs[rhs];
                }
                if (context) {
                    return {
                        context: lhs,
                        name: rhs,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        nonComputedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                if (create && create !== 1) {
                    if (lhs && lhs[right] == null) {
                        lhs[right] = {};
                    }
                }
                var value = lhs != null ? lhs[right] : undefined;
                if (context) {
                    return {
                        context: lhs,
                        name: right,
                        value: value
                    };
                } else {
                    return value;
                }
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                if (inputs) return inputs[watchId];
                return input(scope, value, locals);
            };
        }
    };
    function Parser(lexer, $filter, options) {
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
    }
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            var ast = this.getAst(text);
            var fn = this.astCompiler.compile(ast.ast);
            fn.literal = isLiteral(ast.ast);
            fn.constant = isConstant(ast.ast);
            fn.oneTime = ast.oneTime;
            return fn;
        },
        getAst: function(exp) {
            var oneTime = false;
            exp = exp.trim();
            if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                oneTime = true;
                exp = exp.substring(2);
            }
            return {
                ast: this.ast.ast(exp),
                oneTime: oneTime
            };
        }
    };
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cache = createMap();
        var literals = {
            true: true,
            false: false,
            null: null,
            undefined: undefined
        };
        var identStart, identContinue;
        this.addLiteral = function(literalName, literalValue) {
            literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
            identStart = identifierStart;
            identContinue = identifierContinue;
            return this;
        };
        this.$get = [ "$filter", function($filter) {
            var noUnsafeEval = csp().noUnsafeEval;
            var $parseOptions = {
                csp: noUnsafeEval,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            };
            $parse.$$getAst = $$getAst;
            return $parse;
            function $parse(exp, interceptorFn) {
                var parsedExpression, cacheKey;
                switch (typeof exp) {
                  case "string":
                    exp = exp.trim();
                    cacheKey = exp;
                    parsedExpression = cache[cacheKey];
                    if (!parsedExpression) {
                        var lexer = new Lexer($parseOptions);
                        var parser = new Parser(lexer, $filter, $parseOptions);
                        parsedExpression = parser.parse(exp);
                        cache[cacheKey] = addWatchDelegate(parsedExpression);
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            }
            function $$getAst(exp) {
                var lexer = new Lexer($parseOptions);
                var parser = new Parser(lexer, $filter, $parseOptions);
                return parser.getAst(exp).ast;
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                if (newValue == null || oldValueOfValue == null) {
                    return newValue === oldValueOfValue;
                }
                if (typeof newValue === "object") {
                    newValue = getValueOf(newValue);
                    if (typeof newValue === "object" && !compareObjectIdentity) {
                        return false;
                    }
                }
                return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var inputExpressions = parsedExpression.inputs;
                var lastResult;
                if (inputExpressions.length === 1) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    inputExpressions = inputExpressions[0];
                    return scope.$watch(function expressionInputWatch(scope) {
                        var newInputValue = inputExpressions(scope);
                        if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure)) {
                            lastResult = parsedExpression(scope, undefined, undefined, [ newInputValue ]);
                            oldInputValueOf = newInputValue && getValueOf(newInputValue);
                        }
                        return lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                var oldInputValueOfValues = [];
                var oldInputValues = [];
                for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                    oldInputValues[i] = null;
                }
                return scope.$watch(function expressionInputsWatch(scope) {
                    var changed = false;
                    for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) {
                            oldInputValues[i] = newInputValue;
                            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                        }
                    }
                    if (changed) {
                        lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                    }
                    return lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var isDone = parsedExpression.literal ? isAllDefined : isDefined;
                var unwatch, lastValue;
                var exp = parsedExpression.$$intercepted || parsedExpression;
                var post = parsedExpression.$$interceptor || identity;
                var useInputs = parsedExpression.inputs && !exp.inputs;
                oneTimeWatch.literal = parsedExpression.literal;
                oneTimeWatch.constant = parsedExpression.constant;
                oneTimeWatch.inputs = parsedExpression.inputs;
                addWatchDelegate(oneTimeWatch);
                unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);
                return unwatch;
                function unwatchIfDone() {
                    if (isDone(lastValue)) {
                        unwatch();
                    }
                }
                function oneTimeWatch(scope, locals, assign, inputs) {
                    lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs);
                    if (isDone(lastValue)) {
                        scope.$$postDigest(unwatchIfDone);
                    }
                    return post(lastValue);
                }
            }
            function isAllDefined(value) {
                var allDefined = true;
                forEach(value, function(val) {
                    if (!isDefined(val)) allDefined = false;
                });
                return allDefined;
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch = scope.$watch(function constantWatch(scope) {
                    unwatch();
                    return parsedExpression(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function addWatchDelegate(parsedExpression) {
                if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                } else if (parsedExpression.oneTime) {
                    parsedExpression.$$watchDelegate = oneTimeWatchDelegate;
                } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                }
                return parsedExpression;
            }
            function chainInterceptors(first, second) {
                function chainedInterceptor(value) {
                    return second(first(value));
                }
                chainedInterceptor.$stateful = first.$stateful || second.$stateful;
                chainedInterceptor.$$pure = first.$$pure && second.$$pure;
                return chainedInterceptor;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                if (parsedExpression.$$interceptor) {
                    interceptorFn = chainInterceptors(parsedExpression.$$interceptor, interceptorFn);
                    parsedExpression = parsedExpression.$$intercepted;
                }
                var useInputs = false;
                var fn = function interceptedExpression(scope, locals, assign, inputs) {
                    var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value);
                };
                fn.$$intercepted = parsedExpression;
                fn.$$interceptor = interceptorFn;
                fn.literal = parsedExpression.literal;
                fn.oneTime = parsedExpression.oneTime;
                fn.constant = parsedExpression.constant;
                if (!interceptorFn.$stateful) {
                    useInputs = !parsedExpression.inputs;
                    fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ];
                    if (!interceptorFn.$$pure) {
                        fn.inputs = fn.inputs.map(function(e) {
                            if (e.isPure === PURITY_RELATIVE) {
                                return function depurifier(s) {
                                    return e(s);
                                };
                            }
                            return e;
                        });
                    }
                }
                return addWatchDelegate(fn);
            }
        } ];
    }
    function $QProvider() {
        var errorOnUnhandledRejections = true;
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ];
        this.errorOnUnhandledRejections = function(value) {
            if (isDefined(value)) {
                errorOnUnhandledRejections = value;
                return this;
            } else {
                return errorOnUnhandledRejections;
            }
        };
    }
    function $$QProvider() {
        var errorOnUnhandledRejections = true;
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ];
        this.errorOnUnhandledRejections = function(value) {
            if (isDefined(value)) {
                errorOnUnhandledRejections = value;
                return this;
            } else {
                return errorOnUnhandledRejections;
            }
        };
    }
    function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
        var $qMinErr = minErr("$q", TypeError);
        var queueSize = 0;
        var checkQueue = [];
        function defer() {
            return new Deferred();
        }
        function Deferred() {
            var promise = this.promise = new Promise();
            this.resolve = function(val) {
                resolvePromise(promise, val);
            };
            this.reject = function(reason) {
                rejectPromise(promise, reason);
            };
            this.notify = function(progress) {
                notifyPromise(promise, progress);
            };
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        extend(Promise.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
                if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                    return this;
                }
                var result = new Promise();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]);
                if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                return result;
            },
            catch: function(callback) {
                return this.then(null, callback);
            },
            finally: function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, resolve, callback);
                }, function(error) {
                    return handleCallback(error, reject, callback);
                }, progressBack);
            }
        });
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending;
            state.processScheduled = false;
            state.pending = undefined;
            try {
                for (var i = 0, ii = pending.length; i < ii; ++i) {
                    markQStateExceptionHandled(state);
                    promise = pending[i][0];
                    fn = pending[i][state.status];
                    try {
                        if (isFunction(fn)) {
                            resolvePromise(promise, fn(state.value));
                        } else if (state.status === 1) {
                            resolvePromise(promise, state.value);
                        } else {
                            rejectPromise(promise, state.value);
                        }
                    } catch (e) {
                        rejectPromise(promise, e);
                        if (e && e.$$passToExceptionHandler === true) {
                            exceptionHandler(e);
                        }
                    }
                }
            } finally {
                --queueSize;
                if (errorOnUnhandledRejections && queueSize === 0) {
                    nextTick(processChecks);
                }
            }
        }
        function processChecks() {
            while (!queueSize && checkQueue.length) {
                var toCheck = checkQueue.shift();
                if (!isStateExceptionHandled(toCheck)) {
                    markQStateExceptionHandled(toCheck);
                    var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                    if (isError(toCheck.value)) {
                        exceptionHandler(toCheck.value, errorMessage);
                    } else {
                        exceptionHandler(errorMessage);
                    }
                }
            }
        }
        function scheduleProcessQueue(state) {
            if (errorOnUnhandledRejections && !state.pending && state.status === 2 && !isStateExceptionHandled(state)) {
                if (queueSize === 0 && checkQueue.length === 0) {
                    nextTick(processChecks);
                }
                checkQueue.push(state);
            }
            if (state.processScheduled || !state.pending) return;
            state.processScheduled = true;
            ++queueSize;
            nextTick(function() {
                processQueue(state);
            });
        }
        function resolvePromise(promise, val) {
            if (promise.$$state.status) return;
            if (val === promise) {
                $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
                $$resolve(promise, val);
            }
        }
        function $$resolve(promise, val) {
            var then;
            var done = false;
            try {
                if (isObject(val) || isFunction(val)) then = val.then;
                if (isFunction(then)) {
                    promise.$$state.status = -1;
                    then.call(val, doResolve, doReject, doNotify);
                } else {
                    promise.$$state.value = val;
                    promise.$$state.status = 1;
                    scheduleProcessQueue(promise.$$state);
                }
            } catch (e) {
                doReject(e);
            }
            function doResolve(val) {
                if (done) return;
                done = true;
                $$resolve(promise, val);
            }
            function doReject(val) {
                if (done) return;
                done = true;
                $$reject(promise, val);
            }
            function doNotify(progress) {
                notifyPromise(promise, progress);
            }
        }
        function rejectPromise(promise, reason) {
            if (promise.$$state.status) return;
            $$reject(promise, reason);
        }
        function $$reject(promise, reason) {
            promise.$$state.value = reason;
            promise.$$state.status = 2;
            scheduleProcessQueue(promise.$$state);
        }
        function notifyPromise(promise, progress) {
            var callbacks = promise.$$state.pending;
            if (promise.$$state.status <= 0 && callbacks && callbacks.length) {
                nextTick(function() {
                    var callback, result;
                    for (var i = 0, ii = callbacks.length; i < ii; i++) {
                        result = callbacks[i][0];
                        callback = callbacks[i][3];
                        try {
                            notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                        } catch (e) {
                            exceptionHandler(e);
                        }
                    }
                });
            }
        }
        function reject(reason) {
            var result = new Promise();
            rejectPromise(result, reason);
            return result;
        }
        function handleCallback(value, resolver, callback) {
            var callbackOutput = null;
            try {
                if (isFunction(callback)) callbackOutput = callback();
            } catch (e) {
                return reject(e);
            }
            if (isPromiseLike(callbackOutput)) {
                return callbackOutput.then(function() {
                    return resolver(value);
                }, reject);
            } else {
                return resolver(value);
            }
        }
        function when(value, callback, errback, progressBack) {
            var result = new Promise();
            resolvePromise(result, value);
            return result.then(callback, errback, progressBack);
        }
        var resolve = when;
        function all(promises) {
            var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
            forEach(promises, function(promise, key) {
                counter++;
                when(promise).then(function(value) {
                    results[key] = value;
                    if (!--counter) resolvePromise(result, results);
                }, function(reason) {
                    rejectPromise(result, reason);
                });
            });
            if (counter === 0) {
                resolvePromise(result, results);
            }
            return result;
        }
        function race(promises) {
            var deferred = defer();
            forEach(promises, function(promise) {
                when(promise).then(deferred.resolve, deferred.reject);
            });
            return deferred.promise;
        }
        function $Q(resolver) {
            if (!isFunction(resolver)) {
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            }
            var promise = new Promise();
            function resolveFn(value) {
                resolvePromise(promise, value);
            }
            function rejectFn(reason) {
                rejectPromise(promise, reason);
            }
            resolver(resolveFn, rejectFn);
            return promise;
        }
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        $Q.race = race;
        return $Q;
    }
    function isStateExceptionHandled(state) {
        return !!state.pur;
    }
    function markQStateExceptionHandled(state) {
        state.pur = true;
    }
    function markQExceptionHandled(q) {
        if (q.$$state) {
            markQStateExceptionHandled(q.$$state);
        }
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
            var rafSupported = !!requestAnimationFrame;
            var raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, false);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            raf.supported = rafSupported;
            return raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr("$rootScope");
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        };
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$id = nextUid();
                this.$$ChildScope = null;
                this.$$suspended = false;
            }
            ChildScope.prototype = parent;
            return ChildScope;
        }
        this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = true;
            }
            function cleanUpScope($scope) {
                if (msie === 9) {
                    if ($scope.$$childHead) {
                        cleanUpScope($scope.$$childHead);
                    }
                    if ($scope.$$nextSibling) {
                        cleanUpScope($scope.$$nextSibling);
                    }
                }
                $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
            }
            function Scope() {
                this.$id = nextUid();
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = false;
                this.$$suspended = false;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    parent = parent || this;
                    if (isolate) {
                        child = new Scope();
                        child.$root = this.$root;
                    } else {
                        if (!this.$$ChildScope) {
                            this.$$ChildScope = createChildScopeClass(this);
                        }
                        child = new this.$$ChildScope();
                    }
                    child.$parent = parent;
                    child.$$prevSibling = parent.$$childTail;
                    if (parent.$$childHead) {
                        parent.$$childTail.$$nextSibling = child;
                        parent.$$childTail = child;
                    } else {
                        parent.$$childHead = parent.$$childTail = child;
                    }
                    if (isolate || parent !== this) child.$on("$destroy", destroyChildScope);
                    return child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    var fn = isFunction(listener) ? listener : noop;
                    if (get.$$watchDelegate) {
                        return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                    }
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: fn,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    lastDirtyWatch = null;
                    if (!array) {
                        array = scope.$$watchers = [];
                        array.$$digestWatchIndex = -1;
                    }
                    array.unshift(watcher);
                    array.$$digestWatchIndex++;
                    incrementWatchersCount(this, 1);
                    return function deregisterWatch() {
                        var index = arrayRemove(array, watcher);
                        if (index >= 0) {
                            incrementWatchersCount(scope, -1);
                            if (index < array.$$digestWatchIndex) {
                                array.$$digestWatchIndex--;
                            }
                        }
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    var oldValues = new Array(watchExpressions.length);
                    var newValues = new Array(watchExpressions.length);
                    var deregisterFns = [];
                    var self = this;
                    var changeReactionScheduled = false;
                    var firstRun = true;
                    if (!watchExpressions.length) {
                        var shouldCall = true;
                        self.$evalAsync(function() {
                            if (shouldCall) listener(newValues, newValues, self);
                        });
                        return function deregisterWatchGroup() {
                            shouldCall = false;
                        };
                    }
                    if (watchExpressions.length === 1) {
                        return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                            newValues[0] = value;
                            oldValues[0] = oldValue;
                            listener(newValues, value === oldValue ? newValues : oldValues, scope);
                        });
                    }
                    forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function watchGroupSubAction(value) {
                            newValues[i] = value;
                            if (!changeReactionScheduled) {
                                changeReactionScheduled = true;
                                self.$evalAsync(watchGroupAction);
                            }
                        });
                        deregisterFns.push(unwatchFn);
                    });
                    function watchGroupAction() {
                        changeReactionScheduled = false;
                        try {
                            if (firstRun) {
                                firstRun = false;
                                listener(newValues, newValues, self);
                            } else {
                                listener(newValues, oldValues, self);
                            }
                        } finally {
                            for (var i = 0; i < watchExpressions.length; i++) {
                                oldValues[i] = newValues[i];
                            }
                        }
                    }
                    return function deregisterWatchGroup() {
                        while (deregisterFns.length) {
                            deregisterFns.shift()();
                        }
                    };
                },
                $watchCollection: function(obj, listener) {
                    $watchCollectionInterceptor.$$pure = $parse(obj).literal;
                    $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                    var self = this;
                    var newValue;
                    var oldValue;
                    var veryOldValue;
                    var trackVeryOldValue = listener.length > 1;
                    var changeDetected = 0;
                    var changeDetector = $parse(obj, $watchCollectionInterceptor);
                    var internalArray = [];
                    var internalObject = {};
                    var initRun = true;
                    var oldLength = 0;
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (isUndefined(newValue)) return;
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue;
                                changeDetected++;
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray;
                                oldLength = oldValue.length = 0;
                                changeDetected++;
                            }
                            newLength = newValue.length;
                            if (oldLength !== newLength) {
                                changeDetected++;
                                oldValue.length = oldLength = newLength;
                            }
                            for (var i = 0; i < newLength; i++) {
                                oldItem = oldValue[i];
                                newItem = newValue[i];
                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                if (!bothNaN && oldItem !== newItem) {
                                    changeDetected++;
                                    oldValue[i] = newItem;
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {};
                                oldLength = 0;
                                changeDetected++;
                            }
                            newLength = 0;
                            for (key in newValue) {
                                if (hasOwnProperty.call(newValue, key)) {
                                    newLength++;
                                    newItem = newValue[key];
                                    oldItem = oldValue[key];
                                    if (key in oldValue) {
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[key] = newItem;
                                        }
                                    } else {
                                        oldLength++;
                                        oldValue[key] = newItem;
                                        changeDetected++;
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) {
                                    if (!hasOwnProperty.call(newValue, key)) {
                                        oldLength--;
                                        delete oldValue[key];
                                    }
                                }
                            }
                        }
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false;
                            listener(newValue, newValue, self);
                        } else {
                            listener(newValue, veryOldValue, self);
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue;
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i];
                                }
                            } else {
                                veryOldValue = {};
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key];
                                    }
                                }
                            }
                        }
                    }
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, fn, get, watchers, dirty, ttl = TTL, next, current, target = asyncQueue.length ? $rootScope : this, watchLog = [], logIdx, asyncTask;
                    beginPhase("$digest");
                    $browser.$$checkUrlChange();
                    if (this === $rootScope && applyAsyncId !== null) {
                        $browser.defer.cancel(applyAsyncId);
                        flushApplyAsync();
                    }
                    lastDirtyWatch = null;
                    do {
                        dirty = false;
                        current = target;
                        for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                            try {
                                asyncTask = asyncQueue[asyncQueuePosition];
                                fn = asyncTask.fn;
                                fn(asyncTask.scope, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        asyncQueue.length = 0;
                        traverseScopesLoop: do {
                            if (watchers = !current.$$suspended && current.$$watchers) {
                                watchers.$$digestWatchIndex = watchers.length;
                                while (watchers.$$digestWatchIndex--) {
                                    try {
                                        watch = watchers[watchers.$$digestWatchIndex];
                                        if (watch) {
                                            get = watch.get;
                                            if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                dirty = true;
                                                lastDirtyWatch = watch;
                                                watch.last = watch.eq ? copy(value, null) : value;
                                                fn = watch.fn;
                                                fn(value, last === initWatchVal ? value : last, current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    watchLog[logIdx].push({
                                                        msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                        newVal: value,
                                                        oldVal: last
                                                    });
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false;
                                                break traverseScopesLoop;
                                            }
                                        }
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                            }
                            if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase();
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                        }
                    } while (dirty || asyncQueue.length);
                    clearPhase();
                    while (postDigestQueuePosition < postDigestQueue.length) {
                        try {
                            postDigestQueue[postDigestQueuePosition++]();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    }
                    postDigestQueue.length = postDigestQueuePosition = 0;
                    $browser.$$checkUrlChange();
                },
                $suspend: function() {
                    this.$$suspended = true;
                },
                $isSuspended: function() {
                    return this.$$suspended;
                },
                $resume: function() {
                    this.$$suspended = false;
                },
                $destroy: function() {
                    if (this.$$destroyed) return;
                    var parent = this.$parent;
                    this.$broadcast("$destroy");
                    this.$$destroyed = true;
                    if (this === $rootScope) {
                        $browser.$$applicationDestroyed();
                    }
                    incrementWatchersCount(this, -this.$$watchersCount);
                    for (var eventName in this.$$listenerCount) {
                        decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                    }
                    if (parent && parent.$$childHead === this) parent.$$childHead = this.$$nextSibling;
                    if (parent && parent.$$childTail === this) parent.$$childTail = this.$$prevSibling;
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                    this.$on = this.$watch = this.$watchGroup = function() {
                        return noop;
                    };
                    this.$$listeners = {};
                    this.$$nextSibling = null;
                    cleanUpScope(this);
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    if (!$rootScope.$$phase && !asyncQueue.length) {
                        $browser.defer(function() {
                            if (asyncQueue.length) {
                                $rootScope.$digest();
                            }
                        }, null, "$evalAsync");
                    }
                    asyncQueue.push({
                        scope: this,
                        fn: $parse(expr),
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            $exceptionHandler(e);
                            throw e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    var scope = this;
                    if (expr) {
                        applyAsyncQueue.push($applyAsyncExpression);
                    }
                    expr = $parse(expr);
                    scheduleApplyAsync();
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = [];
                    }
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0;
                        }
                        current.$$listenerCount[name]++;
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        if (indexOfListener !== -1) {
                            delete namedListeners[indexOfListener];
                            decrementListenerCount(self, 1, name);
                        }
                    };
                },
                $emit: function(name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = true;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    }, listenerArgs = concat([ event ], arguments, 1), i, length;
                    do {
                        namedListeners = scope.$$listeners[name] || empty;
                        event.currentScope = scope;
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (stopPropagation) {
                            break;
                        }
                        scope = scope.$parent;
                    } while (scope);
                    event.currentScope = null;
                    return event;
                },
                $broadcast: function(name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = true;
                        },
                        defaultPrevented: false
                    };
                    if (!target.$$listenerCount[name]) return event;
                    var listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                    while (current = next) {
                        event.currentScope = current;
                        listeners = current.$$listeners[name] || [];
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1);
                                i--;
                                length--;
                                continue;
                            }
                            try {
                                listeners[i].apply(null, listenerArgs);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent;
                            }
                        }
                    }
                    event.currentScope = null;
                    return event;
                }
            };
            var $rootScope = new Scope();
            var asyncQueue = $rootScope.$$asyncQueue = [];
            var postDigestQueue = $rootScope.$$postDigestQueue = [];
            var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            var postDigestQueuePosition = 0;
            return $rootScope;
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                }
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do {
                    current.$$watchersCount += count;
                } while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count;
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name];
                    }
                } while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                while (applyAsyncQueue.length) {
                    try {
                        applyAsyncQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                if (applyAsyncId === null) {
                    applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync);
                    }, null, "$applyAsync");
                }
            }
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|s?ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp;
                return this;
            }
            return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp;
                return this;
            }
            return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
            return function sanitizeUri(uri, isMediaUrl) {
                var regex = isMediaUrl ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                var normalizedVal = urlResolve(uri && uri.trim()).href;
                if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                    return "unsafe:" + normalizedVal;
                }
                return uri;
            };
        };
    }
    var $sceMinErr = minErr("$sce");
    var SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        MEDIA_URL: "mediaUrl",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    };
    var UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
    function snakeToCamel(name) {
        return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher;
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            }
            matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*");
            return new RegExp("^" + matcher + "$");
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$");
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
        }
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
            forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher));
            });
        }
        return adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value);
            }
            return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value);
            }
            return resourceUrlBlacklist;
        };
        this.$get = [ "$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl);
                } else {
                    return !!matcher.exec(parsedUrl.href);
                }
            }
            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString());
                var i, n, allowed = false;
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true;
                        break;
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false;
                            break;
                        }
                    }
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                if (Base) {
                    holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
            }
            var trustedValueHolderBase = generateHolderType(), byType = {};
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]);
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                }
                if (trustedValue === null || isUndefined(trustedValue) || trustedValue === "") {
                    return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                }
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue();
                } else {
                    return maybeTrusted;
                }
            }
            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === "") {
                    return maybeTrusted;
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue();
                }
                if (isFunction(maybeTrusted.$$unwrapTrustedValue)) {
                    maybeTrusted = maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) {
                    return $$sanitizeUri(maybeTrusted.toString(), type === SCE_CONTEXTS.MEDIA_URL);
                } else if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted;
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted);
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            return {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
            if (arguments.length) {
                enabled = !!value;
            }
            return enabled;
        };
        this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            }
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function(type, value) {
                    return value;
                };
                sce.valueOf = identity;
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr);
                if (parsed.literal && parsed.constant) {
                    return parsed;
                } else {
                    return $parse(expr, function(value) {
                        return sce.getTrusted(type, value);
                    });
                }
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                };
                sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                };
                sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            });
            return sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = false, animations = false;
            if (bodyStyle) {
                transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle);
                animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle);
            }
            return {
                history: !!(hasHistoryPushState && !(android < 4) && !boxee),
                hasEvent: function(event) {
                    if (event === "input" && msie) return false;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $$TaskTrackerFactoryProvider() {
        this.$get = valueFn(function(log) {
            return new TaskTracker(log);
        });
    }
    function TaskTracker(log) {
        var self = this;
        var taskCounts = {};
        var taskCallbacks = [];
        var ALL_TASKS_TYPE = self.ALL_TASKS_TYPE = "$$all$$";
        var DEFAULT_TASK_TYPE = self.DEFAULT_TASK_TYPE = "$$default$$";
        self.completeTask = completeTask;
        self.incTaskCount = incTaskCount;
        self.notifyWhenNoPendingTasks = notifyWhenNoPendingTasks;
        function completeTask(fn, taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            try {
                fn();
            } finally {
                decTaskCount(taskType);
                var countForType = taskCounts[taskType];
                var countForAll = taskCounts[ALL_TASKS_TYPE];
                if (!countForAll || !countForType) {
                    var getNextCallback = !countForAll ? getLastCallback : getLastCallbackForType;
                    var nextCb;
                    while (nextCb = getNextCallback(taskType)) {
                        try {
                            nextCb();
                        } catch (e) {
                            log.error(e);
                        }
                    }
                }
            }
        }
        function decTaskCount(taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            if (taskCounts[taskType]) {
                taskCounts[taskType]--;
                taskCounts[ALL_TASKS_TYPE]--;
            }
        }
        function getLastCallback() {
            var cbInfo = taskCallbacks.pop();
            return cbInfo && cbInfo.cb;
        }
        function getLastCallbackForType(taskType) {
            for (var i = taskCallbacks.length - 1; i >= 0; --i) {
                var cbInfo = taskCallbacks[i];
                if (cbInfo.type === taskType) {
                    taskCallbacks.splice(i, 1);
                    return cbInfo.cb;
                }
            }
        }
        function incTaskCount(taskType) {
            taskType = taskType || DEFAULT_TASK_TYPE;
            taskCounts[taskType] = (taskCounts[taskType] || 0) + 1;
            taskCounts[ALL_TASKS_TYPE] = (taskCounts[ALL_TASKS_TYPE] || 0) + 1;
        }
        function notifyWhenNoPendingTasks(callback, taskType) {
            taskType = taskType || ALL_TASKS_TYPE;
            if (!taskCounts[taskType]) {
                callback();
            } else {
                taskCallbacks.push({
                    type: taskType,
                    cb: callback
                });
            }
        }
    }
    var $templateRequestMinErr = minErr("$templateRequest");
    function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
            if (val) {
                httpOptions = val;
                return this;
            }
            return httpOptions;
        };
        this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                handleRequestFn.totalPendingRequests++;
                if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
                    tpl = $sce.getTrustedResourceUrl(tpl);
                }
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                if (isArray(transformResponse)) {
                    transformResponse = transformResponse.filter(function(transformer) {
                        return transformer !== defaultHttpResponseTransform;
                    });
                } else if (transformResponse === defaultHttpResponseTransform) {
                    transformResponse = null;
                }
                return $http.get(tpl, extend({
                    cache: $templateCache,
                    transformResponse: transformResponse
                }, httpOptions)).finally(function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return $templateCache.put(tpl, response.data);
                }, handleError);
                function handleError(resp) {
                    if (!ignoreRequestError) {
                        resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                        $exceptionHandler(resp);
                    }
                    return $q.reject(resp);
                }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding");
                var matches = [];
                forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    if (dataBinding) {
                        forEach(dataBinding, function(bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                if (matcher.test(bindingName)) {
                                    matches.push(binding);
                                }
                            } else {
                                if (bindingName.indexOf(expression) !== -1) {
                                    matches.push(binding);
                                }
                            }
                        });
                    }
                });
                return matches;
            };
            testability.findModels = function(element, expression, opt_exactMatch) {
                var prefixes = [ "ng-", "data-ng-", "ng\\:" ];
                for (var p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=";
                    var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                    var elements = element.querySelectorAll(selector);
                    if (elements.length) {
                        return elements;
                    }
                }
            };
            testability.getLocation = function() {
                return $location.url();
            };
            testability.setLocation = function(url) {
                if (url !== $location.url()) {
                    $location.url(url);
                    $rootScope.$digest();
                }
            };
            testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            };
            return testability;
        } ];
    }
    var $timeoutMinErr = minErr("$timeout");
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            var deferreds = {};
            function timeout(fn, delay, invokeApply) {
                if (!isFunction(fn)) {
                    invokeApply = delay;
                    delay = fn;
                    fn = noop;
                }
                var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e);
                        $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    if (!skipApply) $rootScope.$apply();
                }, delay, "$timeout");
                promise.$$timeoutId = timeoutId;
                deferreds[timeoutId] = deferred;
                return promise;
            }
            timeout.cancel = function(promise) {
                if (!promise) return false;
                if (!promise.hasOwnProperty("$$timeoutId")) {
                    throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                }
                if (!deferreds.hasOwnProperty(promise.$$timeoutId)) return false;
                var id = promise.$$timeoutId;
                var deferred = deferreds[id];
                markQExceptionHandled(deferred.promise);
                deferred.reject("canceled");
                delete deferreds[id];
                return $browser.defer.cancel(id);
            };
            return timeout;
        } ];
    }
    var urlParsingNode = window.document.createElement("a");
    var originUrl = urlResolve(window.location.href);
    var baseUrlParsingNode;
    urlParsingNode.href = "http://[::1]";
    var ipv6InBrackets = urlParsingNode.hostname === "[::1]";
    function urlResolve(url) {
        if (!isString(url)) return url;
        var href = url;
        if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        var hostname = urlParsingNode.hostname;
        if (!ipv6InBrackets && hostname.indexOf(":") > -1) {
            hostname = "[" + hostname + "]";
        }
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        return urlsAreSameOrigin(requestUrl, originUrl);
    }
    function urlIsSameOriginAsBaseUrl(requestUrl) {
        return urlsAreSameOrigin(requestUrl, getBaseUrl());
    }
    function urlIsAllowedOriginFactory(whitelistedOriginUrls) {
        var parsedAllowedOriginUrls = [ originUrl ].concat(whitelistedOriginUrls.map(urlResolve));
        return function urlIsAllowedOrigin(requestUrl) {
            var parsedUrl = urlResolve(requestUrl);
            return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl));
        };
    }
    function urlsAreSameOrigin(url1, url2) {
        url1 = urlResolve(url1);
        url2 = urlResolve(url2);
        return url1.protocol === url2.protocol && url1.host === url2.host;
    }
    function getBaseUrl() {
        if (window.document.baseURI) {
            return window.document.baseURI;
        }
        if (!baseUrlParsingNode) {
            baseUrlParsingNode = window.document.createElement("a");
            baseUrlParsingNode.href = ".";
            baseUrlParsingNode = baseUrlParsingNode.cloneNode(false);
        }
        return baseUrlParsingNode.href;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = "";
        function safeGetCookie(rawDocument) {
            try {
                return rawDocument.cookie || "";
            } catch (e) {
                return "";
            }
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        return function() {
            var cookieArray, cookie, i, index, name;
            var currentCookieString = safeGetCookie(rawDocument);
            if (currentCookieString !== lastCookieString) {
                lastCookieString = currentCookieString;
                cookieArray = lastCookieString.split("; ");
                lastCookies = {};
                for (i = 0; i < cookieArray.length; i++) {
                    cookie = cookieArray[i];
                    index = cookie.indexOf("=");
                    if (index > 0) {
                        name = safeDecodeURIComponent(cookie.substring(0, index));
                        if (isUndefined(lastCookies[name])) {
                            lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                        }
                    }
                }
            }
            return lastCookies;
        };
    }
    $$CookieReader.$inject = [ "$document" ];
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    $FilterProvider.$inject = [ "$provide" ];
    function $FilterProvider($provide) {
        var suffix = "Filter";
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                });
                return filters;
            } else {
                return $provide.factory(name + suffix, factory);
            }
        }
        this.register = register;
        this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ];
        register("currency", currencyFilter);
        register("date", dateFilter);
        register("filter", filterFilter);
        register("json", jsonFilter);
        register("limitTo", limitToFilter);
        register("lowercase", lowercaseFilter);
        register("number", numberFilter);
        register("orderBy", orderByFilter);
        register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
            if (!isArrayLike(array)) {
                if (array == null) {
                    return array;
                } else {
                    throw minErr("filter")("notarray", "Expected array but received: {0}", array);
                }
            }
            anyPropertyKey = anyPropertyKey || "$";
            var expressionType = getTypeForFilter(expression);
            var predicateFn;
            var matchAgainstAnyProp;
            switch (expressionType) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = true;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
        var predicateFn;
        if (comparator === true) {
            comparator = equals;
        } else if (!isFunction(comparator)) {
            comparator = function(actual, expected) {
                if (isUndefined(actual)) {
                    return false;
                }
                if (actual === null || expected === null) {
                    return actual === expected;
                }
                if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
                    return false;
                }
                actual = lowercase("" + actual);
                expected = lowercase("" + expected);
                return actual.indexOf(expected) !== -1;
            };
        }
        predicateFn = function(item) {
            if (shouldMatchPrimitives && !isObject(item)) {
                return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
            }
            return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
        };
        return predicateFn;
    }
    function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if (expectedType === "string" && expected.charAt(0) === "!") {
            return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
        } else if (isArray(actual)) {
            return actual.some(function(item) {
                return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
            });
        }
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) {
                    if (key.charAt && key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                        return true;
                    }
                }
                return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
            } else if (expectedType === "object") {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                        continue;
                    }
                    var matchAnyProperty = key === anyPropertyKey;
                    var actualVal = matchAnyProperty ? actual : actual[key];
                    if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                        return false;
                    }
                }
                return true;
            } else {
                return comparator(actual, expected);
            }

          case "function":
            return false;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return val === null ? "null" : typeof val;
    }
    var MAX_DIGITS = 22;
    var DECIMAL_SEP = ".";
    var ZERO_CHAR = "0";
    currencyFilter.$inject = [ "$locale" ];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            if (isUndefined(currencySymbol)) {
                currencySymbol = formats.CURRENCY_SYM;
            }
            if (isUndefined(fractionSize)) {
                fractionSize = formats.PATTERNS[1].maxFrac;
            }
            var currencySymbolRe = !currencySymbol ? /\s*\u00A4\s*/g : /\u00A4/g;
            return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);
        };
    }
    numberFilter.$inject = [ "$locale" ];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function parse(numStr) {
        var exponent = 0, digits, numberOfIntegerDigits;
        var i, j, zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
            numStr = numStr.replace(DECIMAL_SEP, "");
        }
        if ((i = numStr.search(/e/i)) > 0) {
            if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i;
            numberOfIntegerDigits += +numStr.slice(i + 1);
            numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
            numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {}
        if (i === (zeros = numStr.length)) {
            digits = [ 0 ];
            numberOfIntegerDigits = 1;
        } else {
            zeros--;
            while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
            numberOfIntegerDigits -= i;
            digits = [];
            for (j = 0; i <= zeros; i++, j++) {
                digits[j] = +numStr.charAt(i);
            }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
            digits = digits.splice(0, MAX_DIGITS - 1);
            exponent = numberOfIntegerDigits - 1;
            numberOfIntegerDigits = 1;
        }
        return {
            d: digits,
            e: exponent,
            i: numberOfIntegerDigits
        };
    }
    function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
            digits.splice(Math.max(parsedNumber.i, roundAt));
            for (var j = roundAt; j < digits.length; j++) {
                digits[j] = 0;
            }
        } else {
            fractionLen = Math.max(0, fractionLen);
            parsedNumber.i = 1;
            digits.length = Math.max(1, roundAt = fractionSize + 1);
            digits[0] = 0;
            for (var i = 1; i < roundAt; i++) digits[i] = 0;
        }
        if (digit >= 5) {
            if (roundAt - 1 < 0) {
                for (var k = 0; k > roundAt; k--) {
                    digits.unshift(0);
                    parsedNumber.i++;
                }
                digits.unshift(1);
                parsedNumber.i++;
            } else {
                digits[roundAt - 1]++;
            }
        }
        for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
            d = d + carry;
            digits[i] = d % 10;
            return Math.floor(d / 10);
        }, 0);
        if (carry) {
            digits.unshift(carry);
            parsedNumber.i++;
        }
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number)) return "";
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + "", formattedText = "", parsedNumber;
        if (isInfinity) {
            formattedText = "";
        } else {
            parsedNumber = parse(numStr);
            roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
            var digits = parsedNumber.d;
            var integerLen = parsedNumber.i;
            var exponent = parsedNumber.e;
            var decimals = [];
            isZero = digits.reduce(function(isZero, d) {
                return isZero && !d;
            }, true);
            while (integerLen < 0) {
                digits.unshift(0);
                integerLen++;
            }
            if (integerLen > 0) {
                decimals = digits.splice(integerLen, digits.length);
            } else {
                decimals = digits;
                digits = [ 0 ];
            }
            var groups = [];
            if (digits.length >= pattern.lgSize) {
                groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
            }
            while (digits.length > pattern.gSize) {
                groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            }
            if (digits.length) {
                groups.unshift(digits.join(""));
            }
            formattedText = groups.join(groupSep);
            if (decimals.length) {
                formattedText += decimalSep + decimals.join("");
            }
            if (exponent) {
                formattedText += "e+" + exponent;
            }
        }
        if (number < 0 && !isZero) {
            return pattern.negPre + formattedText + pattern.negSuf;
        } else {
            return pattern.posPre + formattedText + pattern.posSuf;
        }
    }
    function padNumber(num, digits, trim, negWrap) {
        var neg = "";
        if (num < 0 || negWrap && num <= 0) {
            if (negWrap) {
                num = -num + 1;
            } else {
                num = -num;
                neg = "-";
            }
        }
        num = "" + num;
        while (num.length < digits) num = ZERO_CHAR + num;
        if (trim) {
            num = num.substr(num.length - digits);
        }
        return neg + num;
    }
    function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
            var value = date["get" + name]();
            if (offset > 0 || value > -offset) {
                value += offset;
            }
            if (value === 0 && offset === -12) value = 12;
            return padNumber(value, size, trim, negWrap);
        };
    }
    function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
            var value = date["get" + name]();
            var propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "");
            var get = uppercase(propPrefix + name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = zone >= 0 ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
            var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4, 0, false, true),
        yy: dateGetter("FullYear", 2, 0, true, true),
        y: dateGetter("FullYear", 1, 0, false, true),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        LLLL: dateStrGetter("Month", false, true),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                if (match[9]) {
                    tzHour = toInt(match[9] + match[10]);
                    tzMin = toInt(match[9] + match[11]);
                }
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour;
                var m = toInt(match[5] || 0) - tzMin;
                var s = toInt(match[6] || 0);
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                timeSetter.call(date, h, m, s, ms);
                return date;
            }
            return string;
        }
        return function(date, format, timezone) {
            var text = "", parts = [], fn, match;
            format = format || "mediumDate";
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
            }
            if (isNumber(date)) {
                date = new Date(date);
            }
            if (!isDate(date) || !isFinite(date.getTime())) {
                return date;
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }
            var dateTimezoneOffset = date.getTimezoneOffset();
            if (timezone) {
                dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                date = convertTimezoneToLocal(date, timezone, true);
            }
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            if (isUndefined(spacing)) {
                spacing = 2;
            }
            return toJson(object, spacing);
        };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
        return function(input, limit, begin) {
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit);
            } else {
                limit = toInt(limit);
            }
            if (isNumberNaN(limit)) return input;
            if (isNumber(input)) input = input.toString();
            if (!isArrayLike(input)) return input;
            begin = !begin || isNaN(begin) ? 0 : toInt(begin);
            begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
            if (limit >= 0) {
                return sliceFn(input, begin, begin + limit);
            } else {
                if (begin === 0) {
                    return sliceFn(input, limit, input.length);
                } else {
                    return sliceFn(input, Math.max(0, begin + limit), begin);
                }
            }
        };
    }
    function sliceFn(input, begin, end) {
        if (isString(input)) return input.slice(begin, end);
        return slice.call(input, begin, end);
    }
    orderByFilter.$inject = [ "$parse" ];
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
            if (array == null) return array;
            if (!isArrayLike(array)) {
                throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
            }
            if (!isArray(sortPredicate)) {
                sortPredicate = [ sortPredicate ];
            }
            if (sortPredicate.length === 0) {
                sortPredicate = [ "+" ];
            }
            var predicates = processPredicates(sortPredicate);
            var descending = reverseOrder ? -1 : 1;
            var compare = isFunction(compareFn) ? compareFn : defaultCompare;
            var compareValues = Array.prototype.map.call(array, getComparisonObject);
            compareValues.sort(doComparison);
            array = compareValues.map(function(item) {
                return item.value;
            });
            return array;
            function getComparisonObject(value, index) {
                return {
                    value: value,
                    tieBreaker: {
                        value: index,
                        type: "number",
                        index: index
                    },
                    predicateValues: predicates.map(function(predicate) {
                        return getPredicateValue(predicate.get(value), index);
                    })
                };
            }
            function doComparison(v1, v2) {
                for (var i = 0, ii = predicates.length; i < ii; i++) {
                    var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                    if (result) {
                        return result * predicates[i].descending * descending;
                    }
                }
                return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
            }
        };
        function processPredicates(sortPredicates) {
            return sortPredicates.map(function(predicate) {
                var descending = 1, get = identity;
                if (isFunction(predicate)) {
                    get = predicate;
                } else if (isString(predicate)) {
                    if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
                        descending = predicate.charAt(0) === "-" ? -1 : 1;
                        predicate = predicate.substring(1);
                    }
                    if (predicate !== "") {
                        get = $parse(predicate);
                        if (get.constant) {
                            var key = get();
                            get = function(value) {
                                return value[key];
                            };
                        }
                    }
                }
                return {
                    get: get,
                    descending: descending
                };
            });
        }
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return true;

              default:
                return false;
            }
        }
        function objectValue(value) {
            if (isFunction(value.valueOf)) {
                value = value.valueOf();
                if (isPrimitive(value)) return value;
            }
            if (hasCustomToString(value)) {
                value = value.toString();
                if (isPrimitive(value)) return value;
            }
            return value;
        }
        function getPredicateValue(value, index) {
            var type = typeof value;
            if (value === null) {
                type = "null";
            } else if (type === "object") {
                value = objectValue(value);
            }
            return {
                value: value,
                type: type,
                index: index
            };
        }
        function defaultCompare(v1, v2) {
            var result = 0;
            var type1 = v1.type;
            var type2 = v2.type;
            if (type1 === type2) {
                var value1 = v1.value;
                var value2 = v2.value;
                if (type1 === "string") {
                    value1 = value1.toLowerCase();
                    value2 = value2.toLowerCase();
                } else if (type1 === "object") {
                    if (isObject(value1)) value1 = v1.index;
                    if (isObject(value2)) value2 = v2.index;
                }
                if (value1 !== value2) {
                    result = value1 < value2 ? -1 : 1;
                }
            } else {
                result = type1 === "undefined" ? 1 : type2 === "undefined" ? -1 : type1 === "null" ? 1 : type2 === "null" ? -1 : type1 < type2 ? -1 : 1;
            }
            return result;
        }
    }
    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            };
        }
        directive.restrict = directive.restrict || "AC";
        return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref) {
                return function(scope, element) {
                    if (element[0].nodeName.toLowerCase() !== "a") return;
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        if (!element.attr(href)) {
                            event.preventDefault();
                        }
                    });
                };
            }
        }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName === "multiple") return;
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                attr.$set(attrName, !!value);
            });
        }
        var normalized = directiveNormalize("ng-" + attrName);
        var linkFn = defaultLinkFn;
        if (propName === "checked") {
            linkFn = function(scope, element, attr) {
                if (attr.ngModel !== attr[normalized]) {
                    defaultLinkFn(scope, element, attr);
                }
            };
        }
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                restrict: "A",
                priority: 100,
                link: linkFn
            };
        };
    });
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) {
                            attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            return;
                        }
                    }
                    scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    });
    forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = [ "$sce", function($sce) {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref";
                        attr.$attr[name] = "xlink:href";
                        propName = null;
                    }
                    attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized]));
                    attr.$observe(normalized, function(value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null);
                            }
                            return;
                        }
                        attr.$set(name, value);
                        if (msie && propName) element.prop(propName, attr[name]);
                    });
                }
            };
        } ];
    });
    var nullFormCtrl = {
        $addControl: noop,
        $getControls: valueFn([]),
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop,
        $$setSubmitted: noop
    }, PENDING_CLASS = "ng-pending", SUBMITTED_CLASS = "ng-submitted";
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    function FormController($element, $attrs, $scope, $animate, $interpolate) {
        this.$$controls = [];
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope);
        this.$dirty = false;
        this.$pristine = true;
        this.$valid = true;
        this.$invalid = false;
        this.$submitted = false;
        this.$$parentForm = nullFormCtrl;
        this.$$element = $element;
        this.$$animate = $animate;
        setupValidity(this);
    }
    FormController.prototype = {
        $rollbackViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$rollbackViewValue();
            });
        },
        $commitViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$commitViewValue();
            });
        },
        $addControl: function(control) {
            assertNotHasOwnProperty(control.$name, "input");
            this.$$controls.push(control);
            if (control.$name) {
                this[control.$name] = control;
            }
            control.$$parentForm = this;
        },
        $getControls: function() {
            return shallowCopy(this.$$controls);
        },
        $$renameControl: function(control, newName) {
            var oldName = control.$name;
            if (this[oldName] === control) {
                delete this[oldName];
            }
            this[newName] = control;
            control.$name = newName;
        },
        $removeControl: function(control) {
            if (control.$name && this[control.$name] === control) {
                delete this[control.$name];
            }
            forEach(this.$pending, function(value, name) {
                this.$setValidity(name, null, control);
            }, this);
            forEach(this.$error, function(value, name) {
                this.$setValidity(name, null, control);
            }, this);
            forEach(this.$$success, function(value, name) {
                this.$setValidity(name, null, control);
            }, this);
            arrayRemove(this.$$controls, control);
            control.$$parentForm = nullFormCtrl;
        },
        $setDirty: function() {
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
            this.$$animate.addClass(this.$$element, DIRTY_CLASS);
            this.$dirty = true;
            this.$pristine = false;
            this.$$parentForm.$setDirty();
        },
        $setPristine: function() {
            this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
            this.$dirty = false;
            this.$pristine = true;
            this.$submitted = false;
            forEach(this.$$controls, function(control) {
                control.$setPristine();
            });
        },
        $setUntouched: function() {
            forEach(this.$$controls, function(control) {
                control.$setUntouched();
            });
        },
        $setSubmitted: function() {
            var rootForm = this;
            while (rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl) {
                rootForm = rootForm.$$parentForm;
            }
            rootForm.$$setSubmitted();
        },
        $$setSubmitted: function() {
            this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
            this.$submitted = true;
            forEach(this.$$controls, function(control) {
                if (control.$$setSubmitted) {
                    control.$$setSubmitted();
                }
            });
        }
    };
    addSetValidityMethod({
        clazz: FormController,
        set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
                object[property] = [ controller ];
            } else {
                var index = list.indexOf(controller);
                if (index === -1) {
                    list.push(controller);
                }
            }
        },
        unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
                return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
                delete object[property];
            }
        }
    });
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", "$parse", function($timeout, $parse) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: FormController,
                compile: function ngFormCompile(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                    return {
                        pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                            var controller = ctrls[0];
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue();
                                        controller.$setSubmitted();
                                    });
                                    event.preventDefault();
                                };
                                formElement[0].addEventListener("submit", handleFormSubmission);
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        formElement[0].removeEventListener("submit", handleFormSubmission);
                                    }, 0, false);
                                });
                            }
                            var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                            parentFormCtrl.$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            if (nameAttr) {
                                setter(scope, controller);
                                attr.$observe(nameAttr, function(newValue) {
                                    if (controller.$name === newValue) return;
                                    setter(scope, undefined);
                                    controller.$$parentForm.$$renameControl(controller, newValue);
                                    setter = getSetter(controller.$name);
                                    setter(scope, controller);
                                });
                            }
                            formElement.on("$destroy", function() {
                                controller.$$parentForm.$removeControl(controller);
                                setter(scope, undefined);
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
            function getSetter(expression) {
                if (expression === "") {
                    return $parse('this[""]').assign;
                }
                return $parse(expression).assign || noop;
            }
        } ];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    function setupValidity(instance) {
        instance.$$classCache = {};
        instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
    }
    function addSetValidityMethod(context) {
        var clazz = context.clazz, set = context.set, unset = context.unset;
        clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
            if (isUndefined(state)) {
                createAndSet(this, "$pending", validationErrorKey, controller);
            } else {
                unsetAndCleanup(this, "$pending", validationErrorKey, controller);
            }
            if (!isBoolean(state)) {
                unset(this.$error, validationErrorKey, controller);
                unset(this.$$success, validationErrorKey, controller);
            } else {
                if (state) {
                    unset(this.$error, validationErrorKey, controller);
                    set(this.$$success, validationErrorKey, controller);
                } else {
                    set(this.$error, validationErrorKey, controller);
                    unset(this.$$success, validationErrorKey, controller);
                }
            }
            if (this.$pending) {
                cachedToggleClass(this, PENDING_CLASS, true);
                this.$valid = this.$invalid = undefined;
                toggleValidationCss(this, "", null);
            } else {
                cachedToggleClass(this, PENDING_CLASS, false);
                this.$valid = isObjectEmpty(this.$error);
                this.$invalid = !this.$valid;
                toggleValidationCss(this, "", this.$valid);
            }
            var combinedState;
            if (this.$pending && this.$pending[validationErrorKey]) {
                combinedState = undefined;
            } else if (this.$error[validationErrorKey]) {
                combinedState = false;
            } else if (this.$$success[validationErrorKey]) {
                combinedState = true;
            } else {
                combinedState = null;
            }
            toggleValidationCss(this, validationErrorKey, combinedState);
            this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
        };
        function createAndSet(ctrl, name, value, controller) {
            if (!ctrl[name]) {
                ctrl[name] = {};
            }
            set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(ctrl, name, value, controller) {
            if (ctrl[name]) {
                unset(ctrl[name], value, controller);
            }
            if (isObjectEmpty(ctrl[name])) {
                ctrl[name] = undefined;
            }
        }
        function cachedToggleClass(ctrl, className, switchValue) {
            if (switchValue && !ctrl.$$classCache[className]) {
                ctrl.$$animate.addClass(ctrl.$$element, className);
                ctrl.$$classCache[className] = true;
            } else if (!switchValue && ctrl.$$classCache[className]) {
                ctrl.$$animate.removeClass(ctrl.$$element, className);
                ctrl.$$classCache[className] = false;
            }
        }
        function toggleValidationCss(ctrl, validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
            cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
            cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);
        }
    }
    function isObjectEmpty(obj) {
        if (obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }
        }
        return true;
    }
    var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
    var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
    var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
    var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
    var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
    var PARTIAL_VALIDATION_TYPES = createMap();
    forEach("date,datetime-local,month,time,week".split(","), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
    });
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        range: rangeInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    };
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = false;
            element.on("compositionstart", function() {
                composing = true;
            });
            element.on("compositionupdate", function(ev) {
                if (isUndefined(ev.data) || ev.data === "") {
                    composing = false;
                }
            });
            element.on("compositionend", function() {
                composing = false;
                listener();
            });
        }
        var timeout;
        var listener = function(ev) {
            if (timeout) {
                $browser.defer.cancel(timeout);
                timeout = null;
            }
            if (composing) return;
            var value = element.val(), event = ev && ev.type;
            if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                value = trim(value);
            }
            if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
                ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener);
        } else {
            var deferListener = function(ev, input, origValue) {
                if (!timeout) {
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (!input || input.value !== origValue) {
                            listener(ev);
                        }
                    });
                }
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                deferListener(event, this, this.value);
            });
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut drop", deferListener);
            }
        }
        element.on("change", listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
            element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
                if (!timeout) {
                    var validity = this[VALIDITY_STATE_PROPERTY];
                    var origBadInput = validity.badInput;
                    var origTypeMismatch = validity.typeMismatch;
                    timeout = $browser.defer(function() {
                        timeout = null;
                        if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                            listener(ev);
                        }
                    });
                }
            });
        }
        ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            if (element.val() !== value) {
                element.val(value);
            }
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
            return isoWeek;
        }
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                if (existingDate) {
                    hours = existingDate.getHours();
                    minutes = existingDate.getMinutes();
                    seconds = existingDate.getSeconds();
                    milliseconds = existingDate.getMilliseconds();
                }
                return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return NaN;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, previousDate) {
            var parts, map;
            if (isDate(iso)) {
                return iso;
            }
            if (isString(iso)) {
                if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
                    iso = iso.substring(1, iso.length - 1);
                }
                if (ISO_DATE_REGEXP.test(iso)) {
                    return new Date(iso);
                }
                regexp.lastIndex = 0;
                parts = regexp.exec(iso);
                if (parts) {
                    parts.shift();
                    if (previousDate) {
                        map = {
                            yyyy: previousDate.getFullYear(),
                            MM: previousDate.getMonth() + 1,
                            dd: previousDate.getDate(),
                            HH: previousDate.getHours(),
                            mm: previousDate.getMinutes(),
                            ss: previousDate.getSeconds(),
                            sss: previousDate.getMilliseconds() / 1e3
                        };
                    } else {
                        map = {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        };
                    }
                    forEach(parts, function(part, index) {
                        if (index < mapping.length) {
                            map[mapping[index]] = +part;
                        }
                    });
                    var date = new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                    if (map.yyyy < 100) {
                        date.setFullYear(map.yyyy);
                    }
                    return date;
                }
            }
            return NaN;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            badInputChecker(scope, element, attr, ctrl, type);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var isTimeType = type === "time" || type === "datetimelocal";
            var previousDate;
            var previousTimezone;
            ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    return parseDateAndConvertTimeZoneToLocal(value, previousDate);
                }
                ctrl.$$parserName = type;
                return undefined;
            });
            ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) {
                    throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                }
                if (isValidDate(value)) {
                    previousDate = value;
                    var timezone = ctrl.$options.getOption("timezone");
                    if (timezone) {
                        previousTimezone = timezone;
                        previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                    }
                    return formatter(value, timezone);
                } else {
                    previousDate = null;
                    previousTimezone = null;
                    return "";
                }
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal = attr.min || $parse(attr.ngMin)(scope);
                var parsedMinVal = parseObservedDateValue(minVal);
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(parsedMinVal) || parseDate(value) >= parsedMinVal;
                };
                attr.$observe("min", function(val) {
                    if (val !== minVal) {
                        parsedMinVal = parseObservedDateValue(val);
                        minVal = val;
                        ctrl.$validate();
                    }
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal = attr.max || $parse(attr.ngMax)(scope);
                var parsedMaxVal = parseObservedDateValue(maxVal);
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(parsedMaxVal) || parseDate(value) <= parsedMaxVal;
                };
                attr.$observe("max", function(val) {
                    if (val !== maxVal) {
                        parsedMaxVal = parseObservedDateValue(val);
                        maxVal = val;
                        ctrl.$validate();
                    }
                });
            }
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) && !isDate(val) ? parseDateAndConvertTimeZoneToLocal(val) || undefined : val;
            }
            function parseDateAndConvertTimeZoneToLocal(value, previousDate) {
                var timezone = ctrl.$options.getOption("timezone");
                if (previousTimezone && previousTimezone !== timezone) {
                    previousDate = addDateMinutes(previousDate, timezoneToOffset(previousTimezone));
                }
                var parsedDate = parseDate(value, previousDate);
                if (!isNaN(parsedDate) && timezone) {
                    parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                }
                return parsedDate;
            }
            function formatter(value, timezone) {
                var targetFormat = format;
                if (isTimeType && isString(ctrl.$options.getOption("timeSecondsFormat"))) {
                    targetFormat = format.replace("ss.sss", ctrl.$options.getOption("timeSecondsFormat")).replace(/:$/, "");
                }
                var formatted = $filter("date")(value, targetFormat, timezone);
                if (isTimeType && ctrl.$options.getOption("timeStripZeroSeconds")) {
                    formatted = formatted.replace(/(?::00)?(?:\.000)?$/, "");
                }
                return formatted;
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl, parserName) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
            ctrl.$parsers.push(function(value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                if (validity.badInput || validity.typeMismatch) {
                    ctrl.$$parserName = parserName;
                    return undefined;
                }
                return value;
            });
        }
    }
    function numberFormatterParser(ctrl) {
        ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value)) return null;
            if (NUMBER_REGEXP.test(value)) return parseFloat(value);
            ctrl.$$parserName = "number";
            return undefined;
        });
        ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) {
                    throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                }
                value = value.toString();
            }
            return value;
        });
    }
    function parseNumberAttrVal(val) {
        if (isDefined(val) && !isNumber(val)) {
            val = parseFloat(val);
        }
        return !isNumberNaN(val) ? val : undefined;
    }
    function isNumberInteger(num) {
        return (num | 0) === num;
    }
    function countDecimals(num) {
        var numString = num.toString();
        var decimalSymbolIndex = numString.indexOf(".");
        if (decimalSymbolIndex === -1) {
            if (-1 < num && num < 1) {
                var match = /e-(\d+)$/.exec(numString);
                if (match) {
                    return Number(match[1]);
                }
            }
            return 0;
        }
        return numString.length - decimalSymbolIndex - 1;
    }
    function isValidForStep(viewValue, stepBase, step) {
        var value = Number(viewValue);
        var isNonIntegerValue = !isNumberInteger(value);
        var isNonIntegerStepBase = !isNumberInteger(stepBase);
        var isNonIntegerStep = !isNumberInteger(step);
        if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
            var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
            var stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
            var stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;
            var decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals);
            var multiplier = Math.pow(10, decimalCount);
            value = value * multiplier;
            stepBase = stepBase * multiplier;
            step = step * multiplier;
            if (isNonIntegerValue) value = Math.round(value);
            if (isNonIntegerStepBase) stepBase = Math.round(stepBase);
            if (isNonIntegerStep) step = Math.round(step);
        }
        return (value - stepBase) % step === 0;
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        badInputChecker(scope, element, attr, ctrl, "number");
        numberFormatterParser(ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var parsedMinVal;
        if (isDefined(attr.min) || attr.ngMin) {
            var minVal = attr.min || $parse(attr.ngMin)(scope);
            parsedMinVal = parseNumberAttrVal(minVal);
            ctrl.$validators.min = function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(parsedMinVal) || viewValue >= parsedMinVal;
            };
            attr.$observe("min", function(val) {
                if (val !== minVal) {
                    parsedMinVal = parseNumberAttrVal(val);
                    minVal = val;
                    ctrl.$validate();
                }
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal = attr.max || $parse(attr.ngMax)(scope);
            var parsedMaxVal = parseNumberAttrVal(maxVal);
            ctrl.$validators.max = function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(parsedMaxVal) || viewValue <= parsedMaxVal;
            };
            attr.$observe("max", function(val) {
                if (val !== maxVal) {
                    parsedMaxVal = parseNumberAttrVal(val);
                    maxVal = val;
                    ctrl.$validate();
                }
            });
        }
        if (isDefined(attr.step) || attr.ngStep) {
            var stepVal = attr.step || $parse(attr.ngStep)(scope);
            var parsedStepVal = parseNumberAttrVal(stepVal);
            ctrl.$validators.step = function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(parsedStepVal) || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal);
            };
            attr.$observe("step", function(val) {
                if (val !== stepVal) {
                    parsedStepVal = parseNumberAttrVal(val);
                    stepVal = val;
                    ctrl.$validate();
                }
            });
        }
    }
    function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl, "range");
        numberFormatterParser(ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var supportsRange = ctrl.$$hasNativeValidators && element[0].type === "range", minVal = supportsRange ? 0 : undefined, maxVal = supportsRange ? 100 : undefined, stepVal = supportsRange ? 1 : undefined, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step);
        var originalRender = ctrl.$render;
        ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function rangeRender() {
            originalRender();
            ctrl.$setViewValue(element.val());
        } : originalRender;
        if (hasMinAttr) {
            minVal = parseNumberAttrVal(attr.min);
            ctrl.$validators.min = supportsRange ? function noopMinValidator() {
                return true;
            } : function minValidator(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
            };
            setInitialValueAndObserver("min", minChange);
        }
        if (hasMaxAttr) {
            maxVal = parseNumberAttrVal(attr.max);
            ctrl.$validators.max = supportsRange ? function noopMaxValidator() {
                return true;
            } : function maxValidator(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
            };
            setInitialValueAndObserver("max", maxChange);
        }
        if (hasStepAttr) {
            stepVal = parseNumberAttrVal(attr.step);
            ctrl.$validators.step = supportsRange ? function nativeStepValidator() {
                return !validity.stepMismatch;
            } : function stepValidator(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
            };
            setInitialValueAndObserver("step", stepChange);
        }
        function setInitialValueAndObserver(htmlAttrName, changeFn) {
            element.attr(htmlAttrName, attr[htmlAttrName]);
            var oldVal = attr[htmlAttrName];
            attr.$observe(htmlAttrName, function wrappedObserver(val) {
                if (val !== oldVal) {
                    oldVal = val;
                    changeFn(val);
                }
            });
        }
        function minChange(val) {
            minVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
                return;
            }
            if (supportsRange) {
                var elVal = element.val();
                if (minVal > elVal) {
                    elVal = minVal;
                    element.val(elVal);
                }
                ctrl.$setViewValue(elVal);
            } else {
                ctrl.$validate();
            }
        }
        function maxChange(val) {
            maxVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
                return;
            }
            if (supportsRange) {
                var elVal = element.val();
                if (maxVal < elVal) {
                    element.val(maxVal);
                    elVal = maxVal < minVal ? minVal : maxVal;
                }
                ctrl.$setViewValue(elVal);
            } else {
                ctrl.$validate();
            }
        }
        function stepChange(val) {
            stepVal = parseNumberAttrVal(val);
            if (isNumberNaN(ctrl.$modelValue)) {
                return;
            }
            if (!supportsRange) {
                ctrl.$validate();
            } else if (ctrl.$viewValue !== element.val()) {
                ctrl.$setViewValue(element.val());
            }
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        var doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid());
        }
        var listener = function(ev) {
            var value;
            if (element[0].checked) {
                value = attr.value;
                if (doTrim) {
                    value = trim(value);
                }
                ctrl.$setViewValue(value, ev && ev.type);
            }
        };
        element.on("change", listener);
        ctrl.$render = function() {
            var value = attr.value;
            if (doTrim) {
                value = trim(value);
            }
            element[0].checked = value === ctrl.$viewValue;
        };
        attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            parseFn = $parse(expression);
            if (!parseFn.constant) {
                throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
            }
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
        var listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("change", listener);
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
            return value === false;
        };
        ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    if (ctrls[0]) {
                        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                    }
                }
            }
        };
    } ];
    var hiddenInputBrowserCacheDirective = function() {
        var valueProperty = {
            configurable: true,
            enumerable: false,
            get: function() {
                return this.getAttribute("value") || "";
            },
            set: function(val) {
                this.setAttribute("value", val);
            }
        };
        return {
            restrict: "E",
            priority: 200,
            compile: function(_, attr) {
                if (lowercase(attr.type) !== "hidden") {
                    return;
                }
                return {
                    pre: function(scope, element, attr, ctrls) {
                        var node = element[0];
                        if (node.parentNode) {
                            node.parentNode.insertBefore(node, node.nextSibling);
                        }
                        if (Object.defineProperty) {
                            Object.defineProperty(node, "value", valueProperty);
                        }
                    }
                };
            }
        };
    };
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
        function updateElementValue(element, attr, value) {
            var propValue = isDefined(value) ? value : msie === 9 ? "" : null;
            element.prop("value", propValue);
            attr.$set("value", value);
        }
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        var value = scope.$eval(attr.ngValue);
                        updateElementValue(elm, attr, value);
                    };
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            updateElementValue(elm, attr, value);
                        });
                    };
                }
            }
        };
    };
    var ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function ngBindCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind);
                    element = element[0];
                    scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                        element.textContent = stringify(value);
                    });
                };
            }
        };
    } ];
    var ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function ngBindTemplateCompile(templateElement) {
                $compile.$$addBindingClass(templateElement);
                return function ngBindTemplateLink(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions);
                    element = element[0];
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ];
    var ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function ngBindHtmlCompile(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
                    return $sce.valueOf(val);
                });
                $compile.$$addBindingClass(tElement);
                return function ngBindHtmlLink(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml);
                    scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                        var value = ngBindHtmlGetter(scope);
                        element.html($sce.getTrustedHtml(value) || "");
                    });
                };
            }
        };
    } ];
    var ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });
    function classDirective(name, selector) {
        name = "ngClass" + name;
        var indexWatchExpression;
        return [ "$parse", function($parse) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    var classCounts = element.data("$classCounts");
                    var oldModulo = true;
                    var oldClassString;
                    if (!classCounts) {
                        classCounts = createMap();
                        element.data("$classCounts", classCounts);
                    }
                    if (name !== "ngClass") {
                        if (!indexWatchExpression) {
                            indexWatchExpression = $parse("$index", function moduloTwo($index) {
                                return $index & 1;
                            });
                        }
                        scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
                    }
                    scope.$watch($parse(attr[name], toClassString), ngClassWatchAction);
                    function addClasses(classString) {
                        classString = digestClassCounts(split(classString), 1);
                        attr.$addClass(classString);
                    }
                    function removeClasses(classString) {
                        classString = digestClassCounts(split(classString), -1);
                        attr.$removeClass(classString);
                    }
                    function updateClasses(oldClassString, newClassString) {
                        var oldClassArray = split(oldClassString);
                        var newClassArray = split(newClassString);
                        var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                        var toAddArray = arrayDifference(newClassArray, oldClassArray);
                        var toRemoveString = digestClassCounts(toRemoveArray, -1);
                        var toAddString = digestClassCounts(toAddArray, 1);
                        attr.$addClass(toAddString);
                        attr.$removeClass(toRemoveString);
                    }
                    function digestClassCounts(classArray, count) {
                        var classesToUpdate = [];
                        forEach(classArray, function(className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count;
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className);
                                }
                            }
                        });
                        return classesToUpdate.join(" ");
                    }
                    function ngClassIndexWatchAction(newModulo) {
                        if (newModulo === selector) {
                            addClasses(oldClassString);
                        } else {
                            removeClasses(oldClassString);
                        }
                        oldModulo = newModulo;
                    }
                    function ngClassWatchAction(newClassString) {
                        if (oldModulo === selector) {
                            updateClasses(oldClassString, newClassString);
                        }
                        oldClassString = newClassString;
                    }
                }
            };
        } ];
        function arrayDifference(tokens1, tokens2) {
            if (!tokens1 || !tokens1.length) return [];
            if (!tokens2 || !tokens2.length) return tokens1;
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
                var token = tokens1[i];
                for (var j = 0; j < tokens2.length; j++) {
                    if (token === tokens2[j]) continue outer;
                }
                values.push(token);
            }
            return values;
        }
        function split(classString) {
            return classString && classString.split(" ");
        }
        function toClassString(classValue) {
            if (!classValue) return classValue;
            var classString = classValue;
            if (isArray(classValue)) {
                classString = classValue.map(toClassString).join(" ");
            } else if (isObject(classValue)) {
                classString = Object.keys(classValue).filter(function(key) {
                    return classValue[key];
                }).join(" ");
            } else if (!isString(classValue)) {
                classString = classValue + "";
            }
            return classString;
        }
    }
    var ngClassDirective = classDirective("", true);
    var ngClassOddDirective = classDirective("Odd", 0);
    var ngClassEvenDirective = classDirective("Even", 1);
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined);
            element.removeClass("ng-cloak");
        }
    });
    var ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: true,
            controller: "@",
            priority: 500
        };
    } ];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
        blur: true,
        focus: true
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", "$exceptionHandler", function($parse, $rootScope, $exceptionHandler) {
            return createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsyncEvents[eventName]);
        } ];
    });
    function createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
        return {
            restrict: "A",
            compile: function($element, attr) {
                var fn = $parse(attr[directiveName]);
                return function ngEventHandler(scope, element) {
                    element.on(eventName, function(event) {
                        var callback = function() {
                            fn(scope, {
                                $event: event
                            });
                        };
                        if (!$rootScope.$$phase) {
                            scope.$apply(callback);
                        } else if (forceAsync) {
                            scope.$evalAsync(callback);
                        } else {
                            try {
                                callback();
                            } catch (error) {
                                $exceptionHandler(error);
                            }
                        }
                    });
                };
            }
        };
    }
    var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            multiElement: true,
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (value) {
                        if (!childScope) {
                            $transclude(function(clone, newScope) {
                                childScope = newScope;
                                clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf);
                                block = {
                                    clone: clone
                                };
                                $animate.enter(clone, $element.parent(), $element);
                            });
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove();
                            previousElements = null;
                        }
                        if (childScope) {
                            childScope.$destroy();
                            childScope = null;
                        }
                        if (block) {
                            previousElements = getBlockNodes(block.clone);
                            $animate.leave(previousElements).done(function(response) {
                                if (response !== false) previousElements = null;
                            });
                            block = null;
                        }
                    }
                });
            }
        };
    } ];
    var ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function() {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).done(function(response) {
                                if (response !== false) previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                        var afterAnimation = function(response) {
                            if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll();
                            }
                        };
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function(response) {
                                if (scope.$$destroyed) return;
                                if (thisChangeId !== changeCounter) return;
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, null, $element).done(afterAnimation);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit("$includeContentLoaded", src);
                                scope.$eval(onloadExp);
                            }, function() {
                                if (scope.$$destroyed) return;
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit("$includeContentError", src);
                                }
                            });
                            scope.$emit("$includeContentRequested", src);
                        } else {
                            cleanupLastIncludeContent();
                            ctrl.template = null;
                        }
                    });
                };
            }
        };
    } ];
    var ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (toString.call($element[0]).match(/SVG/)) {
                    $element.empty();
                    $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                        $element.append(clone);
                    }, {
                        futureParentElement: $element
                    });
                    return;
                }
                $element.html(ctrl.template);
                $compile($element.contents())(scope);
            }
        };
    } ];
    var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    });
    var ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = attr.ngList || ", ";
                var trimValues = attr.ngTrim !== "false";
                var separator = trimValues ? trim(ngList) : ngList;
                var parse = function(viewValue) {
                    if (isUndefined(viewValue)) return;
                    var list = [];
                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trimValues ? trim(value) : value);
                        });
                    }
                    return list;
                };
                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value)) {
                        return value.join(ngList);
                    }
                    return undefined;
                });
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    };
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", EMPTY_CLASS = "ng-empty", NOT_EMPTY_CLASS = "ng-not-empty";
    var ngModelMinErr = minErr("ngModel");
    NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ];
    function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || "", false)($scope);
        this.$$parentForm = nullFormCtrl;
        this.$options = defaultModelOptions;
        this.$$updateEvents = "";
        this.$$updateEventHandler = this.$$updateEventHandler.bind(this);
        this.$$parsedNgModel = $parse($attr.ngModel);
        this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
        this.$$ngModelGet = this.$$parsedNgModel;
        this.$$ngModelSet = this.$$parsedNgModelAssign;
        this.$$pendingDebounce = null;
        this.$$parserValid = undefined;
        this.$$parserName = "parse";
        this.$$currentValidationRunId = 0;
        this.$$scope = $scope;
        this.$$rootScope = $scope.$root;
        this.$$attr = $attr;
        this.$$element = $element;
        this.$$animate = $animate;
        this.$$timeout = $timeout;
        this.$$parse = $parse;
        this.$$q = $q;
        this.$$exceptionHandler = $exceptionHandler;
        setupValidity(this);
        setupModelWatcher(this);
    }
    NgModelController.prototype = {
        $$initGetterSetters: function() {
            if (this.$options.getOption("getterSetter")) {
                var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                this.$$ngModelGet = function($scope) {
                    var modelValue = this.$$parsedNgModel($scope);
                    if (isFunction(modelValue)) {
                        modelValue = invokeModelGetter($scope);
                    }
                    return modelValue;
                };
                this.$$ngModelSet = function($scope, newValue) {
                    if (isFunction(this.$$parsedNgModel($scope))) {
                        invokeModelSetter($scope, {
                            $$$p: newValue
                        });
                    } else {
                        this.$$parsedNgModelAssign($scope, newValue);
                    }
                };
            } else if (!this.$$parsedNgModel.assign) {
                throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
            }
        },
        $render: noop,
        $isEmpty: function(value) {
            return isUndefined(value) || value === "" || value === null || value !== value;
        },
        $$updateEmptyClasses: function(value) {
            if (this.$isEmpty(value)) {
                this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
                this.$$animate.addClass(this.$$element, EMPTY_CLASS);
            } else {
                this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
                this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
            }
        },
        $setPristine: function() {
            this.$dirty = false;
            this.$pristine = true;
            this.$$animate.removeClass(this.$$element, DIRTY_CLASS);
            this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
        },
        $setDirty: function() {
            this.$dirty = true;
            this.$pristine = false;
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
            this.$$animate.addClass(this.$$element, DIRTY_CLASS);
            this.$$parentForm.$setDirty();
        },
        $setUntouched: function() {
            this.$touched = false;
            this.$untouched = true;
            this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        },
        $setTouched: function() {
            this.$touched = true;
            this.$untouched = false;
            this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        },
        $rollbackViewValue: function() {
            this.$$timeout.cancel(this.$$pendingDebounce);
            this.$viewValue = this.$$lastCommittedViewValue;
            this.$render();
        },
        $validate: function() {
            if (isNumberNaN(this.$modelValue)) {
                return;
            }
            var viewValue = this.$$lastCommittedViewValue;
            var modelValue = this.$$rawModelValue;
            var prevValid = this.$valid;
            var prevModelValue = this.$modelValue;
            var allowInvalid = this.$options.getOption("allowInvalid");
            var that = this;
            this.$$runValidators(modelValue, viewValue, function(allValid) {
                if (!allowInvalid && prevValid !== allValid) {
                    that.$modelValue = allValid ? modelValue : undefined;
                    if (that.$modelValue !== prevModelValue) {
                        that.$$writeModelToScope();
                    }
                }
            });
        },
        $$runValidators: function(modelValue, viewValue, doneCallback) {
            this.$$currentValidationRunId++;
            var localValidationRunId = this.$$currentValidationRunId;
            var that = this;
            if (!processParseErrors()) {
                validationDone(false);
                return;
            }
            if (!processSyncValidators()) {
                validationDone(false);
                return;
            }
            processAsyncValidators();
            function processParseErrors() {
                var errorKey = that.$$parserName;
                if (isUndefined(that.$$parserValid)) {
                    setValidity(errorKey, null);
                } else {
                    if (!that.$$parserValid) {
                        forEach(that.$validators, function(v, name) {
                            setValidity(name, null);
                        });
                        forEach(that.$asyncValidators, function(v, name) {
                            setValidity(name, null);
                        });
                    }
                    setValidity(errorKey, that.$$parserValid);
                    return that.$$parserValid;
                }
                return true;
            }
            function processSyncValidators() {
                var syncValidatorsValid = true;
                forEach(that.$validators, function(validator, name) {
                    var result = Boolean(validator(modelValue, viewValue));
                    syncValidatorsValid = syncValidatorsValid && result;
                    setValidity(name, result);
                });
                if (!syncValidatorsValid) {
                    forEach(that.$asyncValidators, function(v, name) {
                        setValidity(name, null);
                    });
                    return false;
                }
                return true;
            }
            function processAsyncValidators() {
                var validatorPromises = [];
                var allValid = true;
                forEach(that.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) {
                        throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    }
                    setValidity(name, undefined);
                    validatorPromises.push(promise.then(function() {
                        setValidity(name, true);
                    }, function() {
                        allValid = false;
                        setValidity(name, false);
                    }));
                });
                if (!validatorPromises.length) {
                    validationDone(true);
                } else {
                    that.$$q.all(validatorPromises).then(function() {
                        validationDone(allValid);
                    }, noop);
                }
            }
            function setValidity(name, isValid) {
                if (localValidationRunId === that.$$currentValidationRunId) {
                    that.$setValidity(name, isValid);
                }
            }
            function validationDone(allValid) {
                if (localValidationRunId === that.$$currentValidationRunId) {
                    doneCallback(allValid);
                }
            }
        },
        $commitViewValue: function() {
            var viewValue = this.$viewValue;
            this.$$timeout.cancel(this.$$pendingDebounce);
            if (this.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !this.$$hasNativeValidators)) {
                return;
            }
            this.$$updateEmptyClasses(viewValue);
            this.$$lastCommittedViewValue = viewValue;
            if (this.$pristine) {
                this.$setDirty();
            }
            this.$$parseAndValidate();
        },
        $$parseAndValidate: function() {
            var viewValue = this.$$lastCommittedViewValue;
            var modelValue = viewValue;
            var that = this;
            this.$$parserValid = isUndefined(modelValue) ? undefined : true;
            this.$setValidity(this.$$parserName, null);
            this.$$parserName = "parse";
            if (this.$$parserValid) {
                for (var i = 0; i < this.$parsers.length; i++) {
                    modelValue = this.$parsers[i](modelValue);
                    if (isUndefined(modelValue)) {
                        this.$$parserValid = false;
                        break;
                    }
                }
            }
            if (isNumberNaN(this.$modelValue)) {
                this.$modelValue = this.$$ngModelGet(this.$$scope);
            }
            var prevModelValue = this.$modelValue;
            var allowInvalid = this.$options.getOption("allowInvalid");
            this.$$rawModelValue = modelValue;
            if (allowInvalid) {
                this.$modelValue = modelValue;
                writeToModelIfNeeded();
            }
            this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                if (!allowInvalid) {
                    that.$modelValue = allValid ? modelValue : undefined;
                    writeToModelIfNeeded();
                }
            });
            function writeToModelIfNeeded() {
                if (that.$modelValue !== prevModelValue) {
                    that.$$writeModelToScope();
                }
            }
        },
        $$writeModelToScope: function() {
            this.$$ngModelSet(this.$$scope, this.$modelValue);
            forEach(this.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    this.$$exceptionHandler(e);
                }
            }, this);
        },
        $setViewValue: function(value, trigger) {
            this.$viewValue = value;
            if (this.$options.getOption("updateOnDefault")) {
                this.$$debounceViewValueCommit(trigger);
            }
        },
        $$debounceViewValueCommit: function(trigger) {
            var debounceDelay = this.$options.getOption("debounce");
            if (isNumber(debounceDelay[trigger])) {
                debounceDelay = debounceDelay[trigger];
            } else if (isNumber(debounceDelay["default"]) && this.$options.getOption("updateOn").indexOf(trigger) === -1) {
                debounceDelay = debounceDelay["default"];
            } else if (isNumber(debounceDelay["*"])) {
                debounceDelay = debounceDelay["*"];
            }
            this.$$timeout.cancel(this.$$pendingDebounce);
            var that = this;
            if (debounceDelay > 0) {
                this.$$pendingDebounce = this.$$timeout(function() {
                    that.$commitViewValue();
                }, debounceDelay);
            } else if (this.$$rootScope.$$phase) {
                this.$commitViewValue();
            } else {
                this.$$scope.$apply(function() {
                    that.$commitViewValue();
                });
            }
        },
        $overrideModelOptions: function(options) {
            this.$options = this.$options.createChild(options);
            this.$$setUpdateOnEvents();
        },
        $processModelValue: function() {
            var viewValue = this.$$format();
            if (this.$viewValue !== viewValue) {
                this.$$updateEmptyClasses(viewValue);
                this.$viewValue = this.$$lastCommittedViewValue = viewValue;
                this.$render();
                this.$$runValidators(this.$modelValue, this.$viewValue, noop);
            }
        },
        $$format: function() {
            var formatters = this.$formatters, idx = formatters.length;
            var viewValue = this.$modelValue;
            while (idx--) {
                viewValue = formatters[idx](viewValue);
            }
            return viewValue;
        },
        $$setModelValue: function(modelValue) {
            this.$modelValue = this.$$rawModelValue = modelValue;
            this.$$parserValid = undefined;
            this.$processModelValue();
        },
        $$setUpdateOnEvents: function() {
            if (this.$$updateEvents) {
                this.$$element.off(this.$$updateEvents, this.$$updateEventHandler);
            }
            this.$$updateEvents = this.$options.getOption("updateOn");
            if (this.$$updateEvents) {
                this.$$element.on(this.$$updateEvents, this.$$updateEventHandler);
            }
        },
        $$updateEventHandler: function(ev) {
            this.$$debounceViewValueCommit(ev && ev.type);
        }
    };
    function setupModelWatcher(ctrl) {
        ctrl.$$scope.$watch(function ngModelWatch(scope) {
            var modelValue = ctrl.$$ngModelGet(scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$$setModelValue(modelValue);
            }
            return modelValue;
        });
    }
    addSetValidityMethod({
        clazz: NgModelController,
        set: function(object, property) {
            object[property] = true;
        },
        unset: function(object, property) {
            delete object[property];
        }
    });
    var ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function ngModelCompile(element) {
                element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                return {
                    pre: function ngModelPreLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                        if (optionsCtrl) {
                            modelCtrl.$options = optionsCtrl.$options;
                        }
                        modelCtrl.$$initGetterSetters();
                        formCtrl.$addControl(modelCtrl);
                        attr.$observe("name", function(newValue) {
                            if (modelCtrl.$name !== newValue) {
                                modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                            }
                        });
                        scope.$on("$destroy", function() {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function ngModelPostLink(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        modelCtrl.$$setUpdateOnEvents();
                        function setTouched() {
                            modelCtrl.$setTouched();
                        }
                        element.on("blur", function() {
                            if (modelCtrl.$touched) return;
                            if ($rootScope.$$phase) {
                                scope.$evalAsync(setTouched);
                            } else {
                                scope.$apply(setTouched);
                            }
                        });
                    }
                };
            }
        };
    } ];
    var defaultModelOptions;
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    function ModelOptions(options) {
        this.$$options = options;
    }
    ModelOptions.prototype = {
        getOption: function(name) {
            return this.$$options[name];
        },
        createChild: function(options) {
            var inheritAll = false;
            options = extend({}, options);
            forEach(options, function(option, key) {
                if (option === "$inherit") {
                    if (key === "*") {
                        inheritAll = true;
                    } else {
                        options[key] = this.$$options[key];
                        if (key === "updateOn") {
                            options.updateOnDefault = this.$$options.updateOnDefault;
                        }
                    }
                } else {
                    if (key === "updateOn") {
                        options.updateOnDefault = false;
                        options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                            options.updateOnDefault = true;
                            return " ";
                        }));
                    }
                }
            }, this);
            if (inheritAll) {
                delete options["*"];
                defaults(options, this.$$options);
            }
            defaults(options, defaultModelOptions.$$options);
            return new ModelOptions(options);
        }
    };
    defaultModelOptions = new ModelOptions({
        updateOn: "",
        updateOnDefault: true,
        debounce: 0,
        getterSetter: false,
        allowInvalid: false,
        timezone: null
    });
    var ngModelOptionsDirective = function() {
        NgModelOptionsController.$inject = [ "$attrs", "$scope" ];
        function NgModelOptionsController($attrs, $scope) {
            this.$$attrs = $attrs;
            this.$$scope = $scope;
        }
        NgModelOptionsController.prototype = {
            $onInit: function() {
                var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
                var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                this.$options = parentOptions.createChild(modelOptionsDefinition);
            }
        };
        return {
            restrict: "A",
            priority: 10,
            require: {
                parentCtrl: "?^^ngModelOptions"
            },
            bindToController: true,
            controller: NgModelOptionsController
        };
    };
    function defaults(dst, src) {
        forEach(src, function(value, key) {
            if (!isDefined(dst[key])) {
                dst[key] = value;
            }
        });
    }
    var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1e3
    });
    var ngOptionsMinErr = minErr("ngOptions");
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    var ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) {
                throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            }
            var valueName = match[5] || match[7];
            var keyName = match[6];
            var selectAs = / as /.test(match[0]) && match[1];
            var trackBy = match[9];
            var valueFn = $parse(match[2] ? match[1] : valueName);
            var selectAsFn = selectAs && $parse(selectAs);
            var viewValueFn = selectAsFn || valueFn;
            var trackByFn = trackBy && $parse(trackBy);
            var getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function getHashOfValue(value) {
                return hashKey(value);
            };
            var getTrackByValue = function(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            };
            var displayFn = $parse(match[2] || match[1]);
            var groupByFn = $parse(match[3] || "");
            var disableWhenFn = $parse(match[4] || "");
            var valuesFn = $parse(match[8]);
            var locals = {};
            var getLocals = keyName ? function(value, key) {
                locals[keyName] = key;
                locals[valueName] = value;
                return locals;
            } : function(value) {
                locals[valueName] = value;
                return locals;
            };
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue;
                this.viewValue = viewValue;
                this.label = label;
                this.group = group;
                this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) {
                    optionValuesKeys = optionValues;
                } else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) {
                        if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== "$") {
                            optionValuesKeys.push(itemKey);
                        }
                    }
                }
                return optionValuesKeys;
            }
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    var optionValuesKeys = getOptionValuesKeys(optionValues);
                    var optionValuesLength = optionValuesKeys.length;
                    for (var index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                        var value = optionValues[key];
                        var locals = getLocals(value, key);
                        var selectValue = getTrackByValueFn(value, locals);
                        watchedArray.push(selectValue);
                        if (match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    var optionItems = [];
                    var selectValueMap = {};
                    var optionValues = valuesFn(scope) || [];
                    var optionValuesKeys = getOptionValuesKeys(optionValues);
                    var optionValuesLength = optionValuesKeys.length;
                    for (var index = 0; index < optionValuesLength; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                        var value = optionValues[key];
                        var locals = getLocals(value, key);
                        var viewValue = viewValueFn(scope, locals);
                        var selectValue = getTrackByValueFn(viewValue, locals);
                        var label = displayFn(scope, locals);
                        var group = groupByFn(scope, locals);
                        var disabled = disableWhenFn(scope, locals);
                        var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem);
                        selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            var multiple = attr.multiple;
            for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                if (children[i].value === "") {
                    selectCtrl.hasEmptyOption = true;
                    selectCtrl.emptyOption = children.eq(i);
                    break;
                }
            }
            selectElement.empty();
            var providedEmptyOption = !!selectCtrl.emptyOption;
            var unknownOption = jqLite(optionTemplate.cloneNode(false));
            unknownOption.val("?");
            var options;
            var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
            var listFragment = $document[0].createDocumentFragment();
            selectCtrl.generateUnknownOptionValue = function(val) {
                return "?";
            };
            if (!multiple) {
                selectCtrl.writeValue = function writeNgOptionsValue(value) {
                    if (!options) return;
                    var selectedOption = selectElement[0].options[selectElement[0].selectedIndex];
                    var option = options.getOptionFromViewValue(value);
                    if (selectedOption) selectedOption.removeAttribute("selected");
                    if (option) {
                        if (selectElement[0].value !== option.selectValue) {
                            selectCtrl.removeUnknownOption();
                            selectElement[0].value = option.selectValue;
                            option.element.selected = true;
                        }
                        option.element.setAttribute("selected", "selected");
                    } else {
                        selectCtrl.selectUnknownOrEmptyOption(value);
                    }
                };
                selectCtrl.readValue = function readNgOptionsValue() {
                    var selectedOption = options.selectValueMap[selectElement.val()];
                    if (selectedOption && !selectedOption.disabled) {
                        selectCtrl.unselectEmptyOption();
                        selectCtrl.removeUnknownOption();
                        return options.getViewValueFromOption(selectedOption);
                    }
                    return null;
                };
                if (ngOptions.trackBy) {
                    scope.$watch(function() {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                    }, function() {
                        ngModelCtrl.$render();
                    });
                }
            } else {
                selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
                    if (!options) return;
                    var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                    options.items.forEach(function(option) {
                        if (option.element.selected && !includes(selectedOptions, option)) {
                            option.element.selected = false;
                        }
                    });
                };
                selectCtrl.readValue = function readNgOptionsMultiple() {
                    var selectedValues = selectElement.val() || [], selections = [];
                    forEach(selectedValues, function(value) {
                        var option = options.selectValueMap[value];
                        if (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
                    });
                    return selections;
                };
                if (ngOptions.trackBy) {
                    scope.$watchCollection(function() {
                        if (isArray(ngModelCtrl.$viewValue)) {
                            return ngModelCtrl.$viewValue.map(function(value) {
                                return ngOptions.getTrackByValue(value);
                            });
                        }
                    }, function() {
                        ngModelCtrl.$render();
                    });
                }
            }
            if (providedEmptyOption) {
                $compile(selectCtrl.emptyOption)(scope);
                selectElement.prepend(selectCtrl.emptyOption);
                if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
                    selectCtrl.hasEmptyOption = false;
                    selectCtrl.registerOption = function(optionScope, optionEl) {
                        if (optionEl.val() === "") {
                            selectCtrl.hasEmptyOption = true;
                            selectCtrl.emptyOption = optionEl;
                            selectCtrl.emptyOption.removeClass("ng-scope");
                            ngModelCtrl.$render();
                            optionEl.on("$destroy", function() {
                                var needsRerender = selectCtrl.$isEmptyOptionSelected();
                                selectCtrl.hasEmptyOption = false;
                                selectCtrl.emptyOption = undefined;
                                if (needsRerender) ngModelCtrl.$render();
                            });
                        }
                    };
                } else {
                    selectCtrl.emptyOption.removeClass("ng-scope");
                }
            }
            scope.$watchCollection(ngOptions.getWatchables, updateOptions);
            function addOptionElement(option, parent) {
                var optionElement = optionTemplate.cloneNode(false);
                parent.appendChild(optionElement);
                updateOptionElement(option, optionElement);
            }
            function getAndUpdateSelectedOption(viewValue) {
                var option = options.getOptionFromViewValue(viewValue);
                var element = option && option.element;
                if (element && !element.selected) element.selected = true;
                return option;
            }
            function updateOptionElement(option, element) {
                option.element = element;
                element.disabled = option.disabled;
                if (option.label !== element.label) {
                    element.label = option.label;
                    element.textContent = option.label;
                }
                element.value = option.selectValue;
            }
            function updateOptions() {
                var previousValue = options && selectCtrl.readValue();
                if (options) {
                    for (var i = options.items.length - 1; i >= 0; i--) {
                        var option = options.items[i];
                        if (isDefined(option.group)) {
                            jqLiteRemove(option.element.parentNode);
                        } else {
                            jqLiteRemove(option.element);
                        }
                    }
                }
                options = ngOptions.getOptions();
                var groupElementMap = {};
                options.items.forEach(function addOption(option) {
                    var groupElement;
                    if (isDefined(option.group)) {
                        groupElement = groupElementMap[option.group];
                        if (!groupElement) {
                            groupElement = optGroupTemplate.cloneNode(false);
                            listFragment.appendChild(groupElement);
                            groupElement.label = option.group === null ? "null" : option.group;
                            groupElementMap[option.group] = groupElement;
                        }
                        addOptionElement(option, groupElement);
                    } else {
                        addOptionElement(option, listFragment);
                    }
                });
                selectElement[0].appendChild(listFragment);
                ngModelCtrl.$render();
                if (!ngModelCtrl.$isEmpty(previousValue)) {
                    var nextValue = selectCtrl.readValue();
                    var isNotPrimitive = ngOptions.trackBy || multiple;
                    if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                        ngModelCtrl.$setViewValue(nextValue);
                        ngModelCtrl.$render();
                    }
                }
            }
        }
        return {
            restrict: "A",
            terminal: true,
            require: [ "select", "ngModel" ],
            link: {
                pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                    ctrls[0].registerOption = noop;
                },
                post: ngOptionsPostLink
            }
        };
    } ];
    var ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop, lastCount;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                });
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                });
                scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                    var count = parseFloat(newVal);
                    var countIsNaN = isNumberNaN(count);
                    if (!countIsNaN && !(count in whens)) {
                        count = $locale.pluralCat(count - offset);
                    }
                    if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        if (isUndefined(whenExpFn)) {
                            if (newVal != null) {
                                $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                            }
                            watchRemover = noop;
                            updateElementText();
                        } else {
                            watchRemover = scope.$watch(whenExpFn, updateElementText);
                        }
                        lastCount = count;
                    }
                });
                function updateElementText(newText) {
                    element.text(newText || "");
                }
            }
        };
    } ];
    var ngRefMinErr = minErr("ngRef");
    var ngRefDirective = [ "$parse", function($parse) {
        return {
            priority: -1,
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var controllerName = directiveNormalize(nodeName_(tElement));
                var getter = $parse(tAttrs.ngRef);
                var setter = getter.assign || function() {
                    throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef);
                };
                return function(scope, element, attrs) {
                    var refValue;
                    if (attrs.hasOwnProperty("ngRefRead")) {
                        if (attrs.ngRefRead === "$element") {
                            refValue = element;
                        } else {
                            refValue = element.data("$" + attrs.ngRefRead + "Controller");
                            if (!refValue) {
                                throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef);
                            }
                        }
                    } else {
                        refValue = element.data("$" + controllerName + "Controller");
                    }
                    refValue = refValue || element;
                    setter(scope, refValue);
                    element.on("$destroy", function() {
                        if (getter(scope) === refValue) {
                            setter(scope, null);
                        }
                    });
                };
            }
        };
    } ];
    var ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
        var NG_REMOVED = "$$NG_REMOVED";
        var ngRepeatMinErr = minErr("ngRepeat");
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value;
            if (keyIdentifier) scope[keyIdentifier] = key;
            scope.$index = index;
            scope.$first = index === 0;
            scope.$last = index === arrayLength - 1;
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
            return block.clone[0];
        };
        var getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        var trackByIdArrayFn = function($scope, key, value) {
            return hashKey(value);
        };
        var trackByIdObjFn = function($scope, key) {
            return key;
        };
        return {
            restrict: "A",
            multiElement: true,
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            compile: function ngRepeatCompile($element, $attr) {
                var expression = $attr.ngRepeat;
                var ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression);
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                }
                var lhs = match[1];
                var rhs = match[2];
                var aliasAs = match[3];
                var trackByExp = match[4];
                match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                }
                var valueIdentifier = match[3] || match[1];
                var keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                    throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                }
                var trackByIdExpFn;
                if (trackByExp) {
                    var hashFnLocals = {
                        $id: hashKey
                    };
                    var trackByExpGetter = $parse(trackByExp);
                    trackByIdExpFn = function($scope, key, value, index) {
                        if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                        hashFnLocals[valueIdentifier] = value;
                        hashFnLocals.$index = index;
                        return trackByExpGetter($scope, hashFnLocals);
                    };
                }
                return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                        var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                        if (aliasAs) {
                            $scope[aliasAs] = collection;
                        }
                        if (isArrayLike(collection)) {
                            collectionKeys = collection;
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        } else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                            collectionKeys = [];
                            for (var itemKey in collection) {
                                if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== "$") {
                                    collectionKeys.push(itemKey);
                                }
                            }
                        }
                        collectionLength = collectionKeys.length;
                        nextBlockOrder = new Array(collectionLength);
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            trackById = trackByIdFn($scope, key, value, index);
                            if (lastBlockMap[trackById]) {
                                block = lastBlockMap[trackById];
                                delete lastBlockMap[trackById];
                                nextBlockMap[trackById] = block;
                                nextBlockOrder[index] = block;
                            } else if (nextBlockMap[trackById]) {
                                forEach(nextBlockOrder, function(block) {
                                    if (block && block.scope) lastBlockMap[block.id] = block;
                                });
                                throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            } else {
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                };
                                nextBlockMap[trackById] = true;
                            }
                        }
                        if (hashFnLocals) {
                            hashFnLocals[valueIdentifier] = undefined;
                        }
                        for (var blockKey in lastBlockMap) {
                            block = lastBlockMap[blockKey];
                            elementsToRemove = getBlockNodes(block.clone);
                            $animate.leave(elementsToRemove);
                            if (elementsToRemove[0].parentNode) {
                                for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                    elementsToRemove[index][NG_REMOVED] = true;
                                }
                            }
                            block.scope.$destroy();
                        }
                        for (index = 0; index < collectionLength; index++) {
                            key = collection === collectionKeys ? index : collectionKeys[index];
                            value = collection[key];
                            block = nextBlockOrder[index];
                            if (block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling;
                                } while (nextNode && nextNode[NG_REMOVED]);
                                if (getBlockStart(block) !== nextNode) {
                                    $animate.move(getBlockNodes(block.clone), null, previousNode);
                                }
                                previousNode = getBlockEnd(block);
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                            } else {
                                $transclude(function ngRepeatTransclude(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(false);
                                    clone[clone.length++] = endNode;
                                    $animate.enter(clone, null, previousNode);
                                    previousNode = endNode;
                                    block.clone = clone;
                                    nextBlockMap[block.id] = block;
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                });
                            }
                        }
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ];
    var NG_HIDE_CLASS = "ng-hide";
    var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
    var ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: true,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watchCollection(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function(val, style) {
                    element.css(style, "");
                });
            }
            if (newStyles) element.css(newStyles);
        });
    });
    var ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function NgSwitchController() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                var spliceFactory = function(array, index) {
                    return function(response) {
                        if (response !== false) array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii;
                    while (previousLeaveAnimations.length) {
                        $animate.cancel(previousLeaveAnimations.pop());
                    }
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                        runner.done(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0;
                    selectedScopes.length = 0;
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        forEach(selectedTranscludes, function(selectedTransclude) {
                            selectedTransclude.transclude(function(caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                var block = {
                                    clone: caseElement
                                };
                                selectedElements.push(block);
                                $animate.enter(caseElement, anchor.parent(), anchor);
                            });
                        });
                    }
                });
            }
        };
    } ];
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
            var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                return array[index - 1] !== element;
            });
            forEach(cases, function(whenCase) {
                ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [];
                ctrl.cases["!" + whenCase].push({
                    transclude: $transclude,
                    element: element
                });
            });
        }
    });
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [];
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    });
    var ngTranscludeMinErr = minErr("ngTransclude");
    var ngTranscludeDirective = [ "$compile", function($compile) {
        return {
            restrict: "EAC",
            compile: function ngTranscludeCompile(tElement) {
                var fallbackLinkFn = $compile(tElement.contents());
                tElement.empty();
                return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
                    if (!$transclude) {
                        throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
                    }
                    if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                        $attrs.ngTransclude = "";
                    }
                    var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                    $transclude(ngTranscludeCloneAttachFn, null, slotName);
                    if (slotName && !$transclude.isSlotFilled(slotName)) {
                        useFallbackContent();
                    }
                    function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                        if (clone.length && notWhitespace(clone)) {
                            $element.append(clone);
                        } else {
                            useFallbackContent();
                            transcludedScope.$destroy();
                        }
                    }
                    function useFallbackContent() {
                        fallbackLinkFn($scope, function(clone) {
                            $element.append(clone);
                        });
                    }
                    function notWhitespace(nodes) {
                        for (var i = 0, ii = nodes.length; i < ii; i++) {
                            var node = nodes[i];
                            if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {
                                return true;
                            }
                        }
                    }
                };
            }
        };
    } ];
    var scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: true,
            compile: function(element, attr) {
                if (attr.type === "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ];
    var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    };
    function setOptionSelectedStatus(optionEl, value) {
        optionEl.prop("selected", value);
        optionEl.attr("selected", value);
    }
    var SelectController = [ "$element", "$scope", function($element, $scope) {
        var self = this, optionsMap = new NgMap();
        self.selectValueMap = {};
        self.ngModelCtrl = noopNgModelController;
        self.multiple = false;
        self.unknownOption = jqLite(window.document.createElement("option"));
        self.hasEmptyOption = false;
        self.emptyOption = undefined;
        self.renderUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal);
            $element.prepend(self.unknownOption);
            setOptionSelectedStatus(self.unknownOption, true);
            $element.val(unknownVal);
        };
        self.updateUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal);
            setOptionSelectedStatus(self.unknownOption, true);
            $element.val(unknownVal);
        };
        self.generateUnknownOptionValue = function(val) {
            return "? " + hashKey(val) + " ?";
        };
        self.removeUnknownOption = function() {
            if (self.unknownOption.parent()) self.unknownOption.remove();
        };
        self.selectEmptyOption = function() {
            if (self.emptyOption) {
                $element.val("");
                setOptionSelectedStatus(self.emptyOption, true);
            }
        };
        self.unselectEmptyOption = function() {
            if (self.hasEmptyOption) {
                setOptionSelectedStatus(self.emptyOption, false);
            }
        };
        $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        });
        self.readValue = function readSingleValue() {
            var val = $element.val();
            var realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
            if (self.hasOption(realVal)) {
                return realVal;
            }
            return null;
        };
        self.writeValue = function writeSingleValue(value) {
            var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
            if (currentlySelectedOption) setOptionSelectedStatus(jqLite(currentlySelectedOption), false);
            if (self.hasOption(value)) {
                self.removeUnknownOption();
                var hashedVal = hashKey(value);
                $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                var selectedOption = $element[0].options[$element[0].selectedIndex];
                setOptionSelectedStatus(jqLite(selectedOption), true);
            } else {
                self.selectUnknownOrEmptyOption(value);
            }
        };
        self.addOption = function(value, element) {
            if (element[0].nodeType === NODE_TYPE_COMMENT) return;
            assertNotHasOwnProperty(value, '"option value"');
            if (value === "") {
                self.hasEmptyOption = true;
                self.emptyOption = element;
            }
            var count = optionsMap.get(value) || 0;
            optionsMap.set(value, count + 1);
            scheduleRender();
        };
        self.removeOption = function(value) {
            var count = optionsMap.get(value);
            if (count) {
                if (count === 1) {
                    optionsMap.delete(value);
                    if (value === "") {
                        self.hasEmptyOption = false;
                        self.emptyOption = undefined;
                    }
                } else {
                    optionsMap.set(value, count - 1);
                }
            }
        };
        self.hasOption = function(value) {
            return !!optionsMap.get(value);
        };
        self.$hasEmptyOption = function() {
            return self.hasEmptyOption;
        };
        self.$isUnknownOptionSelected = function() {
            return $element[0].options[0] === self.unknownOption[0];
        };
        self.$isEmptyOptionSelected = function() {
            return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0];
        };
        self.selectUnknownOrEmptyOption = function(value) {
            if (value == null && self.emptyOption) {
                self.removeUnknownOption();
                self.selectEmptyOption();
            } else if (self.unknownOption.parent().length) {
                self.updateUnknownOption(value);
            } else {
                self.renderUnknownOption(value);
            }
        };
        var renderScheduled = false;
        function scheduleRender() {
            if (renderScheduled) return;
            renderScheduled = true;
            $scope.$$postDigest(function() {
                renderScheduled = false;
                self.ngModelCtrl.$render();
            });
        }
        var updateScheduled = false;
        function scheduleViewValueUpdate(renderAfter) {
            if (updateScheduled) return;
            updateScheduled = true;
            $scope.$$postDigest(function() {
                if ($scope.$$destroyed) return;
                updateScheduled = false;
                self.ngModelCtrl.$setViewValue(self.readValue());
                if (renderAfter) self.ngModelCtrl.$render();
            });
        }
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            if (optionAttrs.$attr.ngValue) {
                var oldVal, hashedVal;
                optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                    var removal;
                    var previouslySelected = optionElement.prop("selected");
                    if (isDefined(hashedVal)) {
                        self.removeOption(oldVal);
                        delete self.selectValueMap[hashedVal];
                        removal = true;
                    }
                    hashedVal = hashKey(newVal);
                    oldVal = newVal;
                    self.selectValueMap[hashedVal] = newVal;
                    self.addOption(newVal, optionElement);
                    optionElement.attr("value", hashedVal);
                    if (removal && previouslySelected) {
                        scheduleViewValueUpdate();
                    }
                });
            } else if (interpolateValueFn) {
                optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                    self.readValue();
                    var removal;
                    var previouslySelected = optionElement.prop("selected");
                    if (isDefined(oldVal)) {
                        self.removeOption(oldVal);
                        removal = true;
                    }
                    oldVal = newVal;
                    self.addOption(newVal, optionElement);
                    if (removal && previouslySelected) {
                        scheduleViewValueUpdate();
                    }
                });
            } else if (interpolateTextFn) {
                optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                    optionAttrs.$set("value", newVal);
                    var previouslySelected = optionElement.prop("selected");
                    if (oldVal !== newVal) {
                        self.removeOption(oldVal);
                    }
                    self.addOption(newVal, optionElement);
                    if (oldVal && previouslySelected) {
                        scheduleViewValueUpdate();
                    }
                });
            } else {
                self.addOption(optionAttrs.value, optionElement);
            }
            optionAttrs.$observe("disabled", function(newVal) {
                if (newVal === "true" || newVal && optionElement.prop("selected")) {
                    if (self.multiple) {
                        scheduleViewValueUpdate(true);
                    } else {
                        self.ngModelCtrl.$setViewValue(null);
                        self.ngModelCtrl.$render();
                    }
                }
            });
            optionElement.on("$destroy", function() {
                var currentValue = self.readValue();
                var removeValue = optionAttrs.value;
                self.removeOption(removeValue);
                scheduleRender();
                if (self.multiple && currentValue && currentValue.indexOf(removeValue) !== -1 || currentValue === removeValue) {
                    scheduleViewValueUpdate(true);
                }
            });
        };
    } ];
    var selectDirective = function() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            priority: 1,
            link: {
                pre: selectPreLink,
                post: selectPostLink
            }
        };
        function selectPreLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0];
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) {
                selectCtrl.registerOption = noop;
                return;
            }
            selectCtrl.ngModelCtrl = ngModelCtrl;
            element.on("change", function() {
                selectCtrl.removeUnknownOption();
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(selectCtrl.readValue());
                });
            });
            if (attr.multiple) {
                selectCtrl.multiple = true;
                selectCtrl.readValue = function readMultipleValue() {
                    var array = [];
                    forEach(element.find("option"), function(option) {
                        if (option.selected && !option.disabled) {
                            var val = option.value;
                            array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                        }
                    });
                    return array;
                };
                selectCtrl.writeValue = function writeMultipleValue(value) {
                    forEach(element.find("option"), function(option) {
                        var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                        var currentlySelected = option.selected;
                        if (shouldBeSelected !== currentlySelected) {
                            setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                        }
                    });
                };
                var lastView, lastViewRef = NaN;
                scope.$watch(function selectMultipleWatch() {
                    if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                        lastView = shallowCopy(ngModelCtrl.$viewValue);
                        ngModelCtrl.$render();
                    }
                    lastViewRef = ngModelCtrl.$viewValue;
                });
                ngModelCtrl.$isEmpty = function(value) {
                    return !value || value.length === 0;
                };
            }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) return;
            var selectCtrl = ctrls[0];
            ngModelCtrl.$render = function() {
                selectCtrl.writeValue(ngModelCtrl.$viewValue);
            };
        }
    };
    var optionDirective = [ "$interpolate", function($interpolate) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                var interpolateValueFn, interpolateTextFn;
                if (isDefined(attr.ngValue)) {} else if (isDefined(attr.value)) {
                    interpolateValueFn = $interpolate(attr.value, true);
                } else {
                    interpolateTextFn = $interpolate(element.text(), true);
                    if (!interpolateTextFn) {
                        attr.$set("value", element.text());
                    }
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (selectCtrl) {
                        selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                    }
                };
            }
        };
    } ];
    var requiredDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var value = attr.hasOwnProperty("required") || $parse(attr.ngRequired)(scope);
                if (!attr.ngRequired) {
                    attr.required = true;
                }
                ctrl.$validators.required = function(modelValue, viewValue) {
                    return !value || !ctrl.$isEmpty(viewValue);
                };
                attr.$observe("required", function(newVal) {
                    if (value !== newVal) {
                        value = newVal;
                        ctrl.$validate();
                    }
                });
            }
        };
    } ];
    var patternDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            compile: function(tElm, tAttr) {
                var patternExp;
                var parseFn;
                if (tAttr.ngPattern) {
                    patternExp = tAttr.ngPattern;
                    if (tAttr.ngPattern.charAt(0) === "/" && REGEX_STRING_REGEXP.test(tAttr.ngPattern)) {
                        parseFn = function() {
                            return tAttr.ngPattern;
                        };
                    } else {
                        parseFn = $parse(tAttr.ngPattern);
                    }
                }
                return function(scope, elm, attr, ctrl) {
                    if (!ctrl) return;
                    var attrVal = attr.pattern;
                    if (attr.ngPattern) {
                        attrVal = parseFn(scope);
                    } else {
                        patternExp = attr.pattern;
                    }
                    var regexp = parsePatternAttr(attrVal, patternExp, elm);
                    attr.$observe("pattern", function(newVal) {
                        var oldRegexp = regexp;
                        regexp = parsePatternAttr(newVal, patternExp, elm);
                        if ((oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString())) {
                            ctrl.$validate();
                        }
                    });
                    ctrl.$validators.pattern = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                };
            }
        };
    } ];
    var maxlengthDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope);
                var maxlengthParsed = parseLength(maxlength);
                attr.$observe("maxlength", function(value) {
                    if (maxlength !== value) {
                        maxlengthParsed = parseLength(value);
                        maxlength = value;
                        ctrl.$validate();
                    }
                });
                ctrl.$validators.maxlength = function(modelValue, viewValue) {
                    return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed;
                };
            }
        };
    } ];
    var minlengthDirective = [ "$parse", function($parse) {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;
                var minlength = attr.minlength || $parse(attr.ngMinlength)(scope);
                var minlengthParsed = parseLength(minlength) || -1;
                attr.$observe("minlength", function(value) {
                    if (minlength !== value) {
                        minlengthParsed = parseLength(value) || -1;
                        minlength = value;
                        ctrl.$validate();
                    }
                });
                ctrl.$validators.minlength = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;
                };
            }
        };
    } ];
    function parsePatternAttr(regex, patternExp, elm) {
        if (!regex) return undefined;
        if (isString(regex)) {
            regex = new RegExp("^" + regex + "$");
        }
        if (!regex.test) {
            throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
        }
        return regex;
    }
    function parseLength(val) {
        var intVal = toInt(val);
        return isNumberNaN(intVal) ? -1 : intVal;
    }
    if (window.angular.bootstrap) {
        if (window.console) {
            console.log("WARNING: Tried to load AngularJS more than once.");
        }
        return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    angular.module("ngLocale", [], [ "$provide", function($provide) {
        var PLURAL_CATEGORY = {
            ZERO: "zero",
            ONE: "one",
            TWO: "two",
            FEW: "few",
            MANY: "many",
            OTHER: "other"
        };
        function getDecimals(n) {
            n = n + "";
            var i = n.indexOf(".");
            return i == -1 ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
            var v = opt_precision;
            if (undefined === v) {
                v = Math.min(getDecimals(n), 3);
            }
            var base = Math.pow(10, v);
            var f = (n * base | 0) % base;
            return {
                v: v,
                f: f
            };
        }
        $provide.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                short: "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            localeID: "en_US",
            pluralCat: function(n, opt_precision) {
                var i = n | 0;
                var vf = getVF(n, opt_precision);
                if (i == 1 && vf.v == 0) {
                    return PLURAL_CATEGORY.ONE;
                }
                return PLURAL_CATEGORY.OTHER;
            }
        });
    } ]);
    jqLite(function() {
        angularInit(window.document, bootstrap);
    });
})(window);

!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');

(function(I, b) {
    "use strict";
    function z(b, h) {
        var d = [], c = b.replace(/([().])/g, "\\$1").replace(/(\/)?:(\w+)(\*\?|[?*])?/g, function(b, c, h, k) {
            b = "?" === k || "*?" === k;
            k = "*" === k || "*?" === k;
            d.push({
                name: h,
                optional: b
            });
            c = c || "";
            return (b ? "(?:" + c : c + "(?:") + (k ? "(.+?)" : "([^/]+)") + (b ? "?)?" : ")");
        }).replace(/([\/$*])/g, "\\$1");
        h.ignoreTrailingSlashes && (c = c.replace(/\/+$/, "") + "/*");
        return {
            keys: d,
            regexp: new RegExp("^" + c + "(?:[?#]|$)", h.caseInsensitiveMatch ? "i" : "")
        };
    }
    function A(b) {
        p && b.get("$route");
    }
    function v(u, h, d) {
        return {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            link: function(c, f, g, l, k) {
                function q() {
                    r && (d.cancel(r), r = null);
                    m && (m.$destroy(), m = null);
                    s && (r = d.leave(s), r.done(function(b) {
                        !1 !== b && (r = null);
                    }), s = null);
                }
                function C() {
                    var g = u.current && u.current.locals;
                    if (b.isDefined(g && g.$template)) {
                        var g = c.$new(), l = u.current;
                        s = k(g, function(g) {
                            d.enter(g, null, s || f).done(function(d) {
                                !1 === d || !b.isDefined(w) || w && !c.$eval(w) || h();
                            });
                            q();
                        });
                        m = l.scope = g;
                        m.$emit("$viewContentLoaded");
                        m.$eval(p);
                    } else q();
                }
                var m, s, r, w = g.autoscroll, p = g.onload || "";
                c.$on("$routeChangeSuccess", C);
                C();
            }
        };
    }
    function x(b, h, d) {
        return {
            restrict: "ECA",
            priority: -400,
            link: function(c, f) {
                var g = d.current, l = g.locals;
                f.html(l.$template);
                var k = b(f.contents());
                if (g.controller) {
                    l.$scope = c;
                    var q = h(g.controller, l);
                    g.controllerAs && (c[g.controllerAs] = q);
                    f.data("$ngControllerController", q);
                    f.children().data("$ngControllerController", q);
                }
                c[g.resolveAs || "$resolve"] = l;
                k(c);
            }
        };
    }
    var D, E, F, G, y = b.module("ngRoute", []).info({
        angularVersion: "1.7.9"
    }).provider("$route", function() {
        function u(d, c) {
            return b.extend(Object.create(d), c);
        }
        D = b.isArray;
        E = b.isObject;
        F = b.isDefined;
        G = b.noop;
        var h = {};
        this.when = function(d, c) {
            var f;
            f = void 0;
            if (D(c)) {
                f = f || [];
                for (var g = 0, l = c.length; g < l; g++) f[g] = c[g];
            } else if (E(c)) for (g in f = f || {}, c) if ("$" !== g.charAt(0) || "$" !== g.charAt(1)) f[g] = c[g];
            f = f || c;
            b.isUndefined(f.reloadOnUrl) && (f.reloadOnUrl = !0);
            b.isUndefined(f.reloadOnSearch) && (f.reloadOnSearch = !0);
            b.isUndefined(f.caseInsensitiveMatch) && (f.caseInsensitiveMatch = this.caseInsensitiveMatch);
            h[d] = b.extend(f, {
                originalPath: d
            }, d && z(d, f));
            d && (g = "/" === d[d.length - 1] ? d.substr(0, d.length - 1) : d + "/", h[g] = b.extend({
                originalPath: d,
                redirectTo: d
            }, z(g, f)));
            return this;
        };
        this.caseInsensitiveMatch = !1;
        this.otherwise = function(b) {
            "string" === typeof b && (b = {
                redirectTo: b
            });
            this.when(null, b);
            return this;
        };
        p = !0;
        this.eagerInstantiationEnabled = function(b) {
            return F(b) ? (p = b, this) : p;
        };
        this.$get = [ "$rootScope", "$location", "$routeParams", "$q", "$injector", "$templateRequest", "$sce", "$browser", function(d, c, f, g, l, k, q, p) {
            function m(a) {
                var e = t.current;
                n = A();
                (x = !B && n && e && n.$$route === e.$$route && (!n.reloadOnUrl || !n.reloadOnSearch && b.equals(n.pathParams, e.pathParams))) || !e && !n || d.$broadcast("$routeChangeStart", n, e).defaultPrevented && a && a.preventDefault();
            }
            function s() {
                var a = t.current, e = n;
                if (x) a.params = e.params, b.copy(a.params, f), d.$broadcast("$routeUpdate", a); else if (e || a) {
                    B = !1;
                    t.current = e;
                    var c = g.resolve(e);
                    p.$$incOutstandingRequestCount("$route");
                    c.then(r).then(w).then(function(g) {
                        return g && c.then(y).then(function(c) {
                            e === t.current && (e && (e.locals = c, b.copy(e.params, f)), d.$broadcast("$routeChangeSuccess", e, a));
                        });
                    }).catch(function(b) {
                        e === t.current && d.$broadcast("$routeChangeError", e, a, b);
                    }).finally(function() {
                        p.$$completeOutstandingRequest(G, "$route");
                    });
                }
            }
            function r(a) {
                var e = {
                    route: a,
                    hasRedirection: !1
                };
                if (a) if (a.redirectTo) if (b.isString(a.redirectTo)) e.path = v(a.redirectTo, a.params), 
                e.search = a.params, e.hasRedirection = !0; else {
                    var d = c.path(), f = c.search();
                    a = a.redirectTo(a.pathParams, d, f);
                    b.isDefined(a) && (e.url = a, e.hasRedirection = !0);
                } else if (a.resolveRedirectTo) return g.resolve(l.invoke(a.resolveRedirectTo)).then(function(a) {
                    b.isDefined(a) && (e.url = a, e.hasRedirection = !0);
                    return e;
                });
                return e;
            }
            function w(a) {
                var b = !0;
                if (a.route !== t.current) b = !1; else if (a.hasRedirection) {
                    var g = c.url(), d = a.url;
                    d ? c.url(d).replace() : d = c.path(a.path).search(a.search).replace().url();
                    d !== g && (b = !1);
                }
                return b;
            }
            function y(a) {
                if (a) {
                    var e = b.extend({}, a.resolve);
                    b.forEach(e, function(a, c) {
                        e[c] = b.isString(a) ? l.get(a) : l.invoke(a, null, null, c);
                    });
                    a = z(a);
                    b.isDefined(a) && (e.$template = a);
                    return g.all(e);
                }
            }
            function z(a) {
                var e, c;
                b.isDefined(e = a.template) ? b.isFunction(e) && (e = e(a.params)) : b.isDefined(c = a.templateUrl) && (b.isFunction(c) && (c = c(a.params)), 
                b.isDefined(c) && (a.loadedTemplateUrl = q.valueOf(c), e = k(c)));
                return e;
            }
            function A() {
                var a, e;
                b.forEach(h, function(d, g) {
                    var f;
                    if (f = !e) {
                        var h = c.path();
                        f = d.keys;
                        var l = {};
                        if (d.regexp) if (h = d.regexp.exec(h)) {
                            for (var k = 1, p = h.length; k < p; ++k) {
                                var m = f[k - 1], n = h[k];
                                m && n && (l[m.name] = n);
                            }
                            f = l;
                        } else f = null; else f = null;
                        f = a = f;
                    }
                    f && (e = u(d, {
                        params: b.extend({}, c.search(), a),
                        pathParams: a
                    }), e.$$route = d);
                });
                return e || h[null] && u(h[null], {
                    params: {},
                    pathParams: {}
                });
            }
            function v(a, c) {
                var d = [];
                b.forEach((a || "").split(":"), function(a, b) {
                    if (0 === b) d.push(a); else {
                        var f = a.match(/(\w+)(?:[?*])?(.*)/), g = f[1];
                        d.push(c[g]);
                        d.push(f[2] || "");
                        delete c[g];
                    }
                });
                return d.join("");
            }
            var B = !1, n, x, t = {
                routes: h,
                reload: function() {
                    B = !0;
                    var a = {
                        defaultPrevented: !1,
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                            B = !1;
                        }
                    };
                    d.$evalAsync(function() {
                        m(a);
                        a.defaultPrevented || s();
                    });
                },
                updateParams: function(a) {
                    if (this.current && this.current.$$route) a = b.extend({}, this.current.params, a), 
                    c.path(v(this.current.$$route.originalPath, a)), c.search(a); else throw H("norout");
                }
            };
            d.$on("$locationChangeStart", m);
            d.$on("$locationChangeSuccess", s);
            return t;
        } ];
    }).run(A), H = b.$$minErr("ngRoute"), p;
    A.$inject = [ "$injector" ];
    y.provider("$routeParams", function() {
        this.$get = function() {
            return {};
        };
    });
    y.directive("ngView", v);
    y.directive("ngView", x);
    v.$inject = [ "$route", "$anchorScroll", "$animate" ];
    x.$inject = [ "$compile", "$controller", "$route" ];
})(window, window.angular);

"use strict";

angular.module("rev", [ "ngRoute", "rev.dashboard" ]).config([ "$locationProvider", "$routeProvider", function($locationProvider, $routeProvider) {
    $locationProvider.hashPrefix("!");
    $routeProvider.otherwise({
        redirectTo: "/viewDashboard"
    });
} ]).factory("setupService", function() {
    var setupData = {
        startDate: new Date(2020, 0, 1),
        pi: Math.PI,
        items: [ {
            name: "CUST1",
            ten: "1/1/2020",
            fifty: "1/1/2020",
            ninety: "1/1/2020",
            revenue: 134e3
        }, {
            name: "CUST2",
            ten: "2/1/2020",
            fifty: "3/1/2020",
            ninety: "1/1/2021",
            revenue: 199e3
        }, {
            name: "CUST3",
            ten: "1/29/2020",
            fifty: "2/15/2020",
            ninety: "3/1/2020",
            revenue: 122800
        }, {
            name: "CUST4",
            ten: "12/1/2020",
            fifty: "12/2/2020",
            ninety: "12/3/2020",
            revenue: 25e4
        }, {
            name: "CUST5",
            ten: "3/31/2020",
            fifty: "4/30/2020",
            ninety: "5/31/2020",
            revenue: 300611
        }, {
            name: "CUST6",
            ten: "5/1/2020",
            fifty: "6/1/2020",
            ninety: "7/30/2020",
            revenue: 234200
        }, {
            name: "CUST7",
            ten: "3/1/2020",
            fifty: "3/30/2020",
            ninety: "5/30/2020",
            revenue: 330400
        }, {
            name: "CUST8",
            ten: "4/30/2020",
            fifty: "1/1/2021",
            ninety: "6/1/2021",
            revenue: 452368
        }, {
            name: "CUST9",
            ten: "5/1/2020",
            fifty: "6/1/2020",
            ninety: "1/1/2021",
            revenue: 112e3
        }, {
            name: "CUST10",
            ten: "5/1/2020",
            fifty: "6/1/2020",
            ninety: "10/1/2020",
            revenue: 213200
        }, {
            name: "CUST11",
            ten: "5/1/2020",
            fifty: "6/1/2020",
            ninety: "7/1/2020",
            revenue: 324880
        } ],
        units: "dates"
    };
    var getData = function() {
        return setupData;
    };
    return {
        getData: getData
    };
});

"use strict";

angular.module("rev.dashboard", [ "ngRoute", "rev" ]).config([ "$routeProvider", function($routeProvider) {
    $routeProvider.when("/viewDashboard", {
        templateUrl: "viewDashboard/viewDashboard.html",
        controller: "ViewDashboardCtrl"
    });
} ]).controller("ViewDashboardCtrl", [ "$scope", "$http", "setupService", "$location", "$timeout", function($scope, $http, setupService, $location, $timeout) {
    $scope.data = setupService.getData();
    $scope.months = getMonthList();
    $scope.simulationFinished = true;
    $scope.data.items = $scope.data.items.map(function(item) {
        item["editing"] = false;
        item["tenDate"] = toDate(item["ten"]);
        item["fiftyDate"] = toDate(item["fifty"]);
        item["ninetyDate"] = toDate(item["ninety"]);
        item["daysFromToday"] = {
            ten: diffInDays(item["tenDate"], $scope.data.startDate),
            fifty: diffInDays(item["fiftyDate"], $scope.data.startDate),
            ninety: diffInDays(item["ninetyDate"], $scope.data.startDate)
        };
        return item;
    });
    var p = [ .1, .5, .9 ];
    $scope.oneSimResults = simulateAllCustomersOnce($scope.data.items, $scope.data.startDate, p);
    function dateStringFor(dateItem) {
        return getMonthNameFor(dateItem) + " " + dateItem.getDate() + ", " + dateItem.getFullYear();
    }
    function rediff() {
        $scope.data.items = $scope.data.items.map(function(item) {
            item["daysFromToday"]["ten"] = diffInDays(item["tenDate"], $scope.data.startDate);
            item["daysFromToday"]["fifty"] = diffInDays(item["fiftyDate"], $scope.data.startDate);
            item["daysFromToday"]["ninety"] = diffInDays(item["ninetyDate"], $scope.data.startDate);
            return item;
        });
        draw();
    }
    function zip(arr1, arr2) {
        var arr3 = arr1.map(function(item) {
            return item;
        });
        for (var i = 0; i < arr2.length; i++) {
            arr3.push(arr2[i]);
        }
        return arr3;
    }
    function addBusinessDays(d, n) {
        d = new Date(d.getTime());
        var day = d.getDay();
        d.setDate(d.getDate() + n + (day === 6 ? 2 : +!day) + Math.floor((n - 1 + (day % 6 || 1)) / 5) * 2);
        return d;
    }
    function addDays(d, n) {
        d = new Date(d.getTime());
        d.setDate(d.getDate() + n);
        return d;
    }
    function makeChartUsing(series, units, chartTitle, subTitle, yAxisTitle, startDate, showDate, showProbability) {
        return {
            chart: {
                type: "line",
                zoomType: "xy"
            },
            title: {
                text: chartTitle
            },
            subtitle: {
                text: subTitle
            },
            xAxis: {
                title: {
                    enabled: true,
                    text: units
                },
                startOnTick: true,
                endOnTick: true,
                showLastLabel: true,
                min: 0,
                max: 700,
                labels: {
                    formatter: function(val) {
                        if (showDate === undefined || showDate == false) {
                            return val.value;
                        } else {
                            return dateStringFor(addDays(startDate, val.value));
                        }
                    }
                }
            },
            tooltip: {
                formatter: function(val) {
                    if (showDate === undefined || showDate == false) {
                        return this.point.x;
                    } else {
                        var msg = "<b>" + this.point.series.name + "</b><br/>";
                        if (showProbability) {
                            msg += "Probability: " + Math.round(this.point.y * 100) + "%<br/>";
                        }
                        return msg + "Date: " + dateStringFor(addDays(startDate, this.point.x));
                    }
                }
            },
            yAxis: {
                title: {
                    text: yAxisTitle
                }
            },
            legend: {
                layout: "vertical",
                align: "right",
                verticalAlign: "bottom",
                floating: true,
                backgroundColor: Highcharts.theme && Highcharts.theme.legendBackgroundColor || "#FFFFFF",
                borderWidth: 1,
                visible: true
            },
            plotOptions: {
                scatter: {
                    showInLegend: true,
                    marker: {
                        radius: 5,
                        states: {
                            hover: {
                                enabled: true,
                                lineColor: "rgb(100,100,100)"
                            }
                        }
                    },
                    states: {
                        hover: {
                            marker: {
                                enabled: false
                            }
                        }
                    },
                    tooltip: {
                        headerFormat: "<b>{series.name}</b><br>",
                        pointFormat: "{point.x} cm, {point.y} kg"
                    }
                }
            },
            series: series
        };
    }
    function draw() {
        var simResult = simulate($scope.data.items, p, $scope.data.startDate, $scope.numRuns);
        $scope.monthBuckets = simResult.monthBuckets;
        $scope.totalResult = simResult.totalResult;
        $scope.activations = simResult.activations;
        var cdfSeries = $scope.data.items.map(function(item, i) {
            var yVector = [];
            var sum = 0;
            for (var i = 0; i < 1e3; i++) {
                yVector.push(i / 1e3);
            }
            return {
                name: item.name,
                data: yVector.map(function(y, j) {
                    return [ j === 0 ? 0 : cdfInverse(y, item.daysFromToday, p), y ];
                })
            };
        });
        var pdfSeries = $scope.data.items.map(function(item, index) {
            var yVector = [];
            var sum = 0;
            for (var i = 0; i < 1e3; i++) {
                yVector.push(i / 1e3);
            }
            return {
                name: item.name,
                data: yVector.map(function(y, j) {
                    return [ cdfSeries[index].data[j][0], j === 0 ? 0 : 1 / (1 / 2 * (1 / Math.log((1 - p[0]) / p[0])) * Math.log(item.daysFromToday.ninety / item.daysFromToday.ten) / (y * (1 - y)) + 1 / ((1 - 2 * p[0]) * Math.log((1 - p[0]) / p[0])) * Math.log(item.daysFromToday.ninety * item.daysFromToday.ten / Math.pow(item.daysFromToday.fifty, 2)) * ((y - .5) / (y * (1 - y)) + Math.log(y / (1 - y)))) * Math.exp(-(Math.log(item.daysFromToday.fifty) + 1 / 2 * (1 / Math.log((1 - p[0]) / p[0])) * Math.log(item.daysFromToday.ninety / item.daysFromToday.ten) * Math.log(y / (1 - y)) + 1 / ((1 - 2 * p[0]) * Math.log((1 - p[0]) / p[0])) * Math.log(item.daysFromToday.ninety * item.daysFromToday.ten / Math.pow(item.daysFromToday.fifty, 2)) * (y - .5) * Math.log(y / (1 - y)))) ];
                })
            };
        });
        Highcharts.chart("pdf", makeChartUsing(pdfSeries, $scope.data.units, "Probability Density Function", "Source: Input Features", "Probability Dist Function", $scope.data.startDate, true, false));
        Highcharts.chart("cdf", makeChartUsing(cdfSeries, $scope.data.units, "Cumulative Distribution Function", "Source: Input Features", "Cumulative Dist Function", $scope.data.startDate, true, true));
    }
    draw();
    $scope.addRow = function() {
        $scope.data.items.push({
            name: "New",
            ten: 0,
            fifty: 0,
            ninety: 0,
            editing: false
        });
        draw();
    };
    $scope.edit = function(index) {
        $scope.data.items[index].editing = !$scope.data.items[index].editing;
    };
    $scope.update = function(index) {
        var item = $scope.data.items[index];
        item.ten = toDateString(item.tenDate);
        item.fifty = toDateString(item.fiftyDate);
        item.ninety = toDateString(item.ninetyDate);
        item.editing = false;
        draw();
    };
    $scope.remove = function(index) {
        $scope.data.items = $scope.data.items.filter(function(item, i) {
            return index !== i;
        });
        draw();
    };
    $scope.simulate = function() {
        console.log("Simulating " + $scope.numRuns + " times.");
        var that = $scope;
        that.simulationFinished = false;
        $timeout(function() {
            var simResult = simulate(that.data.items, p, that.data.startDate, that.numRuns);
            that.monthBuckets = simResult.monthBuckets;
            that.totalResult = simResult.totalResult;
            that.activations = simResult.activations;
            that.simulationFinished = true;
        }, 50);
    };
    $scope.simulateOnce = function() {
        console.log("Simulating once");
        $scope.oneSimResults = simulateAllCustomersOnce($scope.data.items, $scope.data.startDate, p);
    };
    $scope.recalcDate = function() {
        rediff();
        draw();
    };
    $scope.formatMoney = function(amount) {
        try {
            var decimalCount = 0;
            var decimal = ".";
            var thousands = ",";
            var negativeSign = amount < 0 ? "-$" : "$";
            var i = parseInt(amount = Math.abs(Number(amount) || 0).toFixed(decimalCount)).toString();
            var j = i.length > 3 ? i.length % 3 : 0;
            return negativeSign + (j ? i.substr(0, j) + thousands : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + thousands) + (decimalCount ? decimal + Math.abs(amount - i).toFixed(decimalCount).slice(2) : "");
        } catch (e) {
            console.log(e);
        }
    };
    $scope.expand = function(itemToExpand) {
        if (itemToExpand.expanded === undefined) {
            itemToExpand.expanded = true;
        } else {
            itemToExpand.expanded = !itemToExpand.expanded;
        }
    };
    $scope.expand10 = function(i) {
        console.log("Expanding 10% for " + i);
        $scope.expand($scope.monthBuckets[i].ten);
    };
    $scope.expand10total = function() {
        console.log("Expanding 10% Total");
        $scope.expand($scope.totalResult.ten);
    };
    $scope.expand50 = function(i) {
        console.log("Expanding 50% for " + i);
        $scope.expand($scope.monthBuckets[i].fifty);
    };
    $scope.expand50total = function() {
        console.log("Expanding 50% Total");
        $scope.expand($scope.totalResult.fifty);
    };
    $scope.expand90 = function(i) {
        console.log("Expanding 90% for " + i);
        $scope.expand($scope.monthBuckets[i].ninety);
    };
    $scope.expand90total = function() {
        console.log("Expanding 90% Total");
        $scope.expand($scope.totalResult.ninety);
    };
    $scope.downloadCSV = function() {
        var d = new Date();
        var csv = "Number of Runs," + $scope.numRuns + ",,Date," + d.toString() + "\n\n";
        csv += "Percentile";
        $scope.months.forEach(function(month) {
            csv += "," + month;
        });
        csv += ",Total\n";
        csv += "10% chance of being below";
        $scope.monthBuckets.forEach(function(monthBucket) {
            csv += "," + monthBucket.ten;
        });
        csv += "," + $scope.totalResult.ten + "\n";
        csv += "50% chance of being below";
        $scope.monthBuckets.forEach(function(monthBucket) {
            csv += "," + monthBucket.fifty;
        });
        csv += "," + $scope.totalResult.fifty + "\n";
        csv += "90% chance of being below";
        $scope.monthBuckets.forEach(function(monthBucket) {
            csv += "," + monthBucket.ninety;
        });
        csv += "," + $scope.totalResult.ninety + "\n";
        console.log(csv);
        var hiddenElement = document.createElement("a");
        hiddenElement.href = "data:text/csv;charset=utf-8," + encodeURI(csv);
        hiddenElement.target = "_blank";
        hiddenElement.download = "revenueForecast.csv";
        hiddenElement.click();
    };
} ]);

function toDate(dateText) {
    var parts = dateText.split("/");
    return new Date(parts[2], parts[0] - 1, parts[1]);
}

function addDays(d, n) {
    d = new Date(d.getTime());
    d.setDate(d.getDate() + n);
    return d;
}

function toDateString(d) {
    return d.getMonth() + 1 + "/" + d.getDate() + "/" + d.getFullYear();
}

function diffInDays(d1, d2) {
    var Difference_In_Time = Math.max(d1.getTime() - d2.getTime(), 0);
    return Difference_In_Time / (1e3 * 3600 * 24);
}

function getMonthNameFor(d) {
    var month = getMonthList();
    return month[d.getMonth()];
}

function getMonthList() {
    return [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
}

function simulate(items, p, startDate, numRuns) {
    console.log("Starting simulation...");
    var monthBuckets = [];
    var totals = [];
    var monthList = getMonthList();
    for (var i = 0; i < 12; i++) {
        monthBuckets[i] = {
            month: monthList[i],
            data: [],
            ten: 0,
            fifty: 0,
            ninety: 0
        };
    }
    for (var i = 0; i < numRuns; i++) {
        var simResults = simulateAllCustomersOnce(items, startDate, p);
        simResults.eachMonth.forEach(function(monthRevenue, i) {
            monthBuckets[i].data.push({
                monthRevenue: monthRevenue,
                monthDetails: simResults.eachMonthDetails[i]
            });
        });
        totals.push({
            total: simResults.total,
            totalDetails: simResults.totalDetails,
            monthlyTotals: makeMonthlyTotalsFrom(simResults)
        });
    }
    monthBuckets = monthBuckets.map(function(monthBucket) {
        var result = fillTenFiftyNinety(monthBucket.data, monthBucketSorter);
        monthBucket.ten = result.ten;
        monthBucket.fifty = result.fifty;
        monthBucket.ninety = result.ninety;
        return monthBucket;
    });
    var totalResult = fillTenFiftyNinety(totals, totalSort);
    console.log(monthBuckets);
    console.log(totalResult);
    return {
        monthBuckets: monthBuckets,
        totalResult: totalResult
    };
}

function cdfInverse(y, days, p) {
    return Math.exp(Math.log(days.fifty) + 1 / 2 * (1 / Math.log((1 - p[0]) / p[0])) * Math.log(days.ninety / days.ten) * Math.log(y / (1 - y)) + 1 / ((1 - 2 * p[0]) * Math.log((1 - p[0]) / p[0])) * Math.log(days.ninety * days.ten / Math.pow(days.fifty, 2)) * (y - .5) * Math.log(y / (1 - y)));
}

function totalSort(a, b) {
    return a.total - b.total;
}

function monthBucketSorter(a, b) {
    return a.monthRevenue - b.monthRevenue;
}

function fillTenFiftyNinety(dataBucket, sorter) {
    dataBucket.sort(sorter);
    var tenIndex = dataBucket.length * .1 | 0;
    var fiftyIndex = dataBucket.length * .5 | 0;
    var ninetyIndex = dataBucket.length * .9 | 0;
    return {
        ten: dataBucket[tenIndex],
        fifty: dataBucket[fiftyIndex],
        ninety: dataBucket[ninetyIndex]
    };
}

function simulateAllCustomersOnce(items, startDate, p) {
    var eachMonth = [];
    var eachMonthDetails = [];
    var totalDetails = [];
    var monthList = getMonthList();
    for (var i = 0; i < 12; i++) {
        eachMonth.push(0);
        eachMonthDetails.push([]);
    }
    var activations = [];
    var total = 0;
    var rnd = Math.random();
    items.map(function(item) {
        var x = cdfInverse(rnd, item.daysFromToday, p);
        if (isNaN(x)) {
            x = 0;
        }
        var dateOfActivation = addDays(startDate, x);
        var monthOfActivation = dateOfActivation.getMonth();
        var yearOfActivation = dateOfActivation.getFullYear();
        if (yearOfActivation === 2020) {
            eachMonth[monthOfActivation] += item.revenue;
            eachMonthDetails[monthOfActivation].push({
                name: item.name,
                revenue: item.revenue
            });
            total += item.revenue;
            totalDetails.push({
                name: item.name,
                revenue: item.revenue,
                month: monthList[monthOfActivation],
                monthIndex: monthOfActivation
            });
            activations.push({
                name: item.name,
                month: monthOfActivation,
                revenue: item.revenue
            });
        } else {
            activations.push({
                name: item.name,
                month: 13,
                revenue: item.revenue
            });
        }
    });
    return {
        eachMonth: eachMonth,
        eachMonthDetails: eachMonthDetails,
        total: total,
        totalDetails: totalDetails,
        activations: activations
    };
}

function makeMonthlyTotalsFrom(simResults) {
    var monthlyTotals = [];
    for (var j = 0; j < 12; j++) {
        monthlyTotals[j] = 0;
    }
    simResults.totalDetails.forEach(function(totalDetail) {
        monthlyTotals[totalDetail.monthIndex] += totalDetail.revenue;
    });
    return monthlyTotals;
}

var module;

try {
    module = angular.module("rev");
} catch (e) {
    module = angular.module("rev", []);
}

module.run([ "$templateCache", function($templateCache) {
    $templateCache.put("viewDashboard/viewDashboard.html", '<div class="container">\n' + '    <div class="panel">\n' + '        <div class="row">\n' + '            <div class="col-md-6 scrollable">\n' + "                <h2>Inputs</h2>\n" + '                Start Date: <input type="date" ng-model="data.startDate" class="form-control" ng-change="recalcDate()"/><br/>\n' + '                <table class="table table-bordered">\n' + "                    <thead>\n" + "                        <th>Action</th>\n" + "                        <th>Feature</th>\n" + "                        <th>Ten</th>\n" + "                        <th>Fifty</th>\n" + "                        <th>Ninety</th>\n" + "                    </thead>\n" + "                    <tbody>\n" + '                        <tr ng-repeat="item in data.items track by $index">\n' + "                            <td>\n" + '                                <i ng-if="item.editing===false" class="far fa-edit fa-lg" ng-click="edit($index)"></i>\n' + '                                <i ng-if="item.editing===true" style="color:#00FF00;" class="fas fa-check fa-lg" ng-click="update($index)"></i>\n' + '                                <i ng-if="item.editing===false" class="far fa-trash-alt fa-lg" style="color:#FF0000  ;" ng-click="remove($index)"></i>\n' + "                            </td>\n" + "                            <td>\n" + '                                <span ng-if="item.editing===false">{{item.name}}</span>\n' + '                                <span ng-if="item.editing===true"><input type="text" class="form-control" ng-model="item.name"/></span>\n' + "                            </td>\n" + "\n" + "                            <td>\n" + '                                <span ng-if="item.editing===false">{{item.ten}}</span>\n' + '                                <span ng-if="item.editing===true"><input type="date" class="form-control" ng-model="item.tenDate"/></span>\n' + "                            </td>\n" + "                            <td>\n" + '                                <span ng-if="item.editing===false">{{item.fifty}}</span>\n' + '                                <span ng-if="item.editing===true"><input type="date" class="form-control" ng-model="item.fiftyDate"/></span>\n' + "                            </td>\n" + "                            <td>\n" + '                                <span ng-if="item.editing===false">{{item.ninety}}</span>\n' + '                                <span ng-if="item.editing===true"><input type="date" class="form-control" ng-model="item.ninetyDate"/></span>\n' + "                            </td>\n" + "                        </div>\n" + "                    </tbody>\n" + "                </table>\n" + '                <button class="btn btn-primary" ng-click="addRow()">Add</button><br/>\n' + "\n" + "\n" + "            </div>\n" + '            <div class="col-md-6">\n' + '                <div id="pdf" style="min-width: 310px; height: 400px; max-width: 800px; margin: 0 auto"></div>\n' + '                <div id="cdf" style="min-width: 310px; height: 400px; max-width: 800px; margin: 0 auto"></div>\n' + "            </div>\n" + "    </div>\n" + '    <div class="row">\n' + '            <div class="col-md-12">\n' + "                <hr/>\n" + "                <h2>Test Simulation</h2>\n" + "                This is the result of one round of simulation.<br/>\n" + "\n" + '                <button class="btn btn-primary" ng-click="simulateOnce()">Simulate once</button>\n' + '                <table class="table table-bordered">\n' + "                    <thead>\n" + '                        <th>Customer</th><th ng-repeat="month in months">{{month}}</th>\n' + "                    </thead>\n" + "                    <tbody>\n" + '                        <tr ng-repeat="activation in oneSimResults.activations">\n' + "                            <td>{{activation.name}}</td>\n" + '                            <td ng-repeat="month in months track by $index">\n' + '                                <span ng-if="$index === activation.month">{{formatMoney(activation.revenue)}}</span>\n' + "                            </td>\n" + "                        </tr>\n" + "                        <tr>\n" + "                            <td>Month Totals</td>\n" + '                            <td ng-repeat="month in months track by $index">{{formatMoney(oneSimResults.eachMonth[$index])}}</td>\n' + "                        </tr>\n" + "                    </tbody>\n" + "                </table>\n" + "                Total: {{formatMoney(oneSimResults.total)}}\n" + "            </div>\n" + "    </div>\n" + '    <div class="row">\n' + '        <div class="col-md-12">\n' + "            <hr/>\n" + "            <h2>Simulation Results</h2>\n" + '            Number of Runs: <select ng-model="numRuns"><option value="1000000">1,000,000</option><option value="100000">100,000</option><option value="10000">10,0000</option><option value="1000">1,000</option><option value="100">100</option></select>\n' + '            <button ng-show="simulationFinished===true" class="btn btn-primary" ng-click="simulate()">Simulate</button>\n' + '            <i ng-show="simulationFinished===false" class="fas fa-spinner fa-spin"></i>&nbsp;<button class="btn btn-primary" ng-click="downloadCSV()">Download</button>\n' + "            <h4>Simulation results for {{numRuns}} runs</h4>\n" + '            <table class="table table-striped table-bordered">\n' + "                <thead>\n" + '                    <th>Percentile</th><th ng-repeat="month in months">{{month}}</th><th>Total</th>\n' + "                </thead>\n" + "                <tbody>\n" + "                    <tr>\n" + "                        <td>10% chance of being below</td>\n" + '                        <td ng-repeat="monthBucket in monthBuckets track by $index" ng-click="expand10($index)">\n' + "                            {{formatMoney(monthBucket.ten.monthRevenue)}}\n" + '                            <span ng-if="monthBucket.ten.expanded===true">\n' + "                                <br/>\n" + '                                    <p ng-repeat="detail in monthBucket.ten.monthDetails">{{detail.name}}: {{formatMoney(detail.revenue)}}</p>\n' + "                            </span>\n" + "                        </td>\n" + '                        <td ng-click="expand10total()">{{formatMoney(totalResult.ten.total)}}\n' + '                            <span ng-if="totalResult.ten.expanded===true">\n' + "                                <br/>\n" + '                                    <p ng-repeat="detail in totalResult.ten.totalDetails">{{detail.name}}: {{formatMoney(detail.revenue)}} ({{detail.month}})</p>\n' + "                            </span>\n" + "                        </td>\n" + "                    </tr>\n" + "                    <tr>\n" + "                        <td>50% chance above or below</td>\n" + '                        <td ng-repeat="monthBucket in monthBuckets track by $index" ng-click="expand50($index)">{{formatMoney(monthBucket.fifty.monthRevenue)}}\n' + '                            <span ng-if="monthBucket.fifty.expanded===true">\n' + "                                <br/>\n" + '                                    <p ng-repeat="detail in monthBucket.fifty.monthDetails">{{detail.name}}: {{formatMoney(detail.revenue)}}</p>\n' + "                            </span>\n" + "                        </td>\n" + '                        <td ng-click="expand50total()">{{formatMoney(totalResult.fifty.total)}}\n' + '                            <span ng-if="totalResult.fifty.expanded===true">\n' + "                                <br/>\n" + '                                    <p ng-repeat="detail in totalResult.fifty.totalDetails">{{detail.name}}: {{formatMoney(detail.revenue)}} ({{detail.month}})</p>\n' + "                            </span>\n" + "                        </td>\n" + "                    </tr>\n" + "                    <tr>\n" + "                        <td>90% chance below (10% chance above)</td>\n" + '                        <td ng-repeat="monthBucket in monthBuckets track by $index" ng-click="expand90($index)">{{formatMoney(monthBucket.ninety.monthRevenue)}}\n' + '                            <span ng-if="monthBucket.ninety.expanded===true">\n' + "                                <br/>\n" + '                                    <p ng-repeat="detail in monthBucket.ninety.monthDetails">{{detail.name}}: {{formatMoney(detail.revenue)}}</p>\n' + "                            </span>\n" + "                        </td>\n" + '                        <td ng-click="expand90total()">{{formatMoney(totalResult.ninety.total)}}\n' + '                            <span ng-if="totalResult.ninety.expanded===true">\n' + "                                <br/>\n" + '                                    <p ng-repeat="detail in totalResult.ninety.totalDetails">{{detail.name}}: {{formatMoney(detail.revenue)}} ({{detail.month}})</p>\n' + "                            </span>\n" + "                        </td>\n" + "                    </tr>\n" + "                </tbody>\n" + "            </table>\n" + "            <p/>\n" + "            As the total column contents (seen when you click on any cell in that column) are hard to intuitively interpret, below is a table that lays this column out.\n" + '            <table class="table table-striped table-bordered">\n' + "                <thead>\n" + '                    <th>Scenario for Percentile</th><th ng-repeat="month in months">{{month}}</th><th>Total</th>\n' + "                </thead>\n" + "                <tbody>\n" + "                    <tr>\n" + "                        <td>Customers in 10% scenario</td>\n" + '                        <td ng-repeat="month in months">\n' + '                            <span ng-repeat="detail in totalResult.ten.totalDetails">\n' + '                                <span ng-if="detail.month===month">{{detail.name}}</span>\n' + "                            </span>\n" + "                        </td>\n" + "                        <td>{{formatMoney(totalResult.ten.total)}}</td>\n" + "                    </tr>\n" + "                    <tr>\n" + "                        <td>Customers in 50% scenario</td>\n" + '                        <td ng-repeat="month in months">\n' + '                            <span ng-repeat="detail in totalResult.fifty.totalDetails">\n' + '                                <span ng-if="detail.month===month">{{detail.name}}</span>\n' + "                            </span>\n" + "                        </td>\n" + "                        <td>{{formatMoney(totalResult.fifty.total)}}</td>\n" + "                    </tr>\n" + "                    <tr>\n" + "                        <td>Customers in 90% scenario</td>\n" + '                        <td ng-repeat="month in months">\n' + '                            <span ng-repeat="detail in totalResult.ninety.totalDetails">\n' + '                                <span ng-if="detail.month===month">{{detail.name}}</span>\n' + "                            </span>\n" + "                        </td>\n" + "                        <td>{{formatMoney(totalResult.ninety.total)}}</td>\n" + "                    </tr>\n" + "                    <tr>\n" + "                        <td>Revenue in 10% scenario</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[0])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[1])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[2])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[3])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[4])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[5])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[6])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[7])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[8])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[9])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[10])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.monthlyTotals[11])}}</td>\n" + "                        <td>{{formatMoney(totalResult.ten.total)}}</td>\n" + "                    </tr>\n" + "                    <tr>\n" + "                        <td>Revenue in 50% scenario</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[0])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[1])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[2])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[3])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[4])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[5])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[6])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[7])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[8])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[9])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[10])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.monthlyTotals[11])}}</td>\n" + "                        <td>{{formatMoney(totalResult.fifty.total)}}</td>\n" + "                    </tr>\n" + "                     <tr>\n" + "                         <td>Revenue in 90% scenario</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[0])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[1])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[2])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[3])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[4])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[5])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[6])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[7])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[8])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[9])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[10])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.monthlyTotals[11])}}</td>\n" + "                         <td>{{formatMoney(totalResult.ninety.total)}}</td>\n" + "                    </tr>\n" + "                </tbody>\n" + "\n" + "        </div>\n" + "    </div>\n" + "</div>\n" + "\n" + "\n" + "\n" + "\n" + "");
} ]);</script>
</body>
</html>

